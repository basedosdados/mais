{"config":{"indexing":"full","lang":["en","pt","es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello, world! A miss\u00e3o da Base dos Dados \u00e9 universalizar o uso de dados de qualidade no Brasil e no mundo. Para isso, criamos uma ferramenta que te permite acessar recursos importantes de diversos conjuntos de dados p\u00fablicos , como: Tabelas tratadas : Tabelas completas, j\u00e1 tratadas e prontas para an\u00e1lise, dispon\u00edveis no nosso datalake p\u00fablico. Dados originais : Links com informa\u00e7\u00f5es \u00fateis para explorar mais sobre o conjunto de dados, como a fonte original e outros. Temos um time de Dados e volunt\u00e1rios(as) de todo o Brasil que ajudam a limpar e manter as tabelas tratadas BD. Saiba como fazer parte Acessando tabelas tratadas BD No nosso site voc\u00ea encontra a lista de todas as tabelas tratadas de cada conjunto de dados. Apresentamos tamb\u00e9m informa\u00e7\u00f5es importantes de todas as tabelas, como a lista de colunas, cobertura temporal, periodicidade, entre outras informa\u00e7\u00f5es. Voc\u00ea pode consultar os dados das tabelas via: Download Voc\u00ea pode baixar o arquivo CSV completo da tabela direto no site. Este tipo de Consulta n\u00e3o est\u00e1 dispon\u00edvel para arquivos que ultrapassem 200 mil linhas. BigQuery (SQL) O BigQuery \u00e9 o um servi\u00e7o de banco de dados em nuvem da Google. Direto do navegador, voc\u00ea pode fazer consultas \u00e0s tabelas tratadas com: Rapidez: Mesmo queries muito longas demoram apenas minutos para serem processadas. Escala: O BigQuery escala magicamente para hexabytes se necess\u00e1rio. Economia: Todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consulta aos dados . Aprenda Pacotes Os pacotes da Base dos Dados permitem o acesso ao data lake p\u00fablico direto do seu computador ou ambiente de desenvolvimento. Os pacotes atualmente dispon\u00edveis s\u00e3o: Python R Stata Aprenda Dicas para melhor uso dos dados Nosso time de dados trabalha constantemente em desenvolver melhores padr\u00f5es e metodologias para facilitar o processo de an\u00e1lise de dados. Separamos alguns materiais \u00fateis para voc\u00ea entender melhor o que fazemos e como tirar o melhor proveito dos dados: Cruzar dados de diferentes organiza\u00e7\u00f5es de forma r\u00e1pida Entender padr\u00f5es de tabelas, conjuntos e vari\u00e1veis","title":"Home"},{"location":"#hello-world","text":"A miss\u00e3o da Base dos Dados \u00e9 universalizar o uso de dados de qualidade no Brasil e no mundo. Para isso, criamos uma ferramenta que te permite acessar recursos importantes de diversos conjuntos de dados p\u00fablicos , como: Tabelas tratadas : Tabelas completas, j\u00e1 tratadas e prontas para an\u00e1lise, dispon\u00edveis no nosso datalake p\u00fablico. Dados originais : Links com informa\u00e7\u00f5es \u00fateis para explorar mais sobre o conjunto de dados, como a fonte original e outros. Temos um time de Dados e volunt\u00e1rios(as) de todo o Brasil que ajudam a limpar e manter as tabelas tratadas BD. Saiba como fazer parte","title":"Hello, world!"},{"location":"#acessando-tabelas-tratadas-bd","text":"No nosso site voc\u00ea encontra a lista de todas as tabelas tratadas de cada conjunto de dados. Apresentamos tamb\u00e9m informa\u00e7\u00f5es importantes de todas as tabelas, como a lista de colunas, cobertura temporal, periodicidade, entre outras informa\u00e7\u00f5es. Voc\u00ea pode consultar os dados das tabelas via:","title":"Acessando tabelas tratadas BD"},{"location":"#download","text":"Voc\u00ea pode baixar o arquivo CSV completo da tabela direto no site. Este tipo de Consulta n\u00e3o est\u00e1 dispon\u00edvel para arquivos que ultrapassem 200 mil linhas.","title":"Download"},{"location":"#bigquery-sql","text":"O BigQuery \u00e9 o um servi\u00e7o de banco de dados em nuvem da Google. Direto do navegador, voc\u00ea pode fazer consultas \u00e0s tabelas tratadas com: Rapidez: Mesmo queries muito longas demoram apenas minutos para serem processadas. Escala: O BigQuery escala magicamente para hexabytes se necess\u00e1rio. Economia: Todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consulta aos dados . Aprenda","title":"BigQuery (SQL)"},{"location":"#pacotes","text":"Os pacotes da Base dos Dados permitem o acesso ao data lake p\u00fablico direto do seu computador ou ambiente de desenvolvimento. Os pacotes atualmente dispon\u00edveis s\u00e3o: Python R Stata Aprenda","title":"Pacotes"},{"location":"#dicas-para-melhor-uso-dos-dados","text":"Nosso time de dados trabalha constantemente em desenvolver melhores padr\u00f5es e metodologias para facilitar o processo de an\u00e1lise de dados. Separamos alguns materiais \u00fateis para voc\u00ea entender melhor o que fazemos e como tirar o melhor proveito dos dados: Cruzar dados de diferentes organiza\u00e7\u00f5es de forma r\u00e1pida Entender padr\u00f5es de tabelas, conjuntos e vari\u00e1veis","title":"Dicas para melhor uso dos dados"},{"location":"access_data_bq/","text":"BigQuery O BigQuery \u00e9 o um servi\u00e7o de banco de dados em nuvem da Google. Voc\u00ea faz consultas ao banco em SQL direto do navegador com: Rapidez : Mesmo queries muito longas demoram apenas minutos para serem processadas. Escala : O BigQuery escala magicamente para hexabytes se necess\u00e1rio. Economia : Todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consulta aos dados . Pronto(a) para come\u00e7ar? Nesta p\u00e1gina voc\u00ea encontra: Primeiros passos Entenda o uso gratuito do Big Query BQ Tutoriais Manuais e Cursos de SQL Primeiros passos Antes de come\u00e7ar: Crie o seu projeto no Google Cloud Para criar um projeto no Google Cloud basta ter um email cadastrado no Google. \u00c9 necess\u00e1rio ter um projeto seu, mesmo que vazio, para voc\u00ea fazer queries em nosso datalake p\u00fablico. Acesse o Google Cloud . Caso for a sua primeira vez, aceite o Termo de Servi\u00e7os. Clique em Create Project/Criar Projeto . Escolha um nome bacana para o projeto. Clique em Create/Criar Por que eu preciso criar um projeto no Google Cloud? A Google fornece 1 TB gratuito por m\u00eas de uso do BigQuery para cada projeto que voc\u00ea possui. Um projeto \u00e9 necess\u00e1rio para ativar os servi\u00e7os do Google Cloud, incluindo a permiss\u00e3o de uso do BigQuery. Pense no projeto como a \"conta\" na qual a Google vai contabilizar o quanto de processamento voc\u00ea j\u00e1 utilizou. N\u00e3o \u00e9 necess\u00e1rio adicionar nenhum cart\u00e3o ou forma de pagamento - O BigQuery inicia automaticamente no modo Sandbox, que permite voc\u00ea utilizar seus recursos sem adicionar um modo de pagamento. Leia mais aqui . Acessando o datalake da basedosdados O bot\u00e3o abaixo via te direcionar ao nosso projeto no Google BigQuery: Ir para BigQuery Agora voc\u00ea precisa fixar o projeto da BD no seu BigQuery, \u00e9 bem simples, veja: !!! Warning A op\u00e7\u00e3o Fixar um projeto pode aparecer tamb\u00e9m como Marcar projeto com estrela por nome Dentro do projeto existem dois n\u00edveis de organiza\u00e7\u00e3o dos dados, datasets (conjuntos de dados) e tables (tabelas), nos quais: Todas as tabelas est\u00e3o organizadas dentro de cojuntos de dados , que representaam sua organiza\u00e7\u00e3o/tema (ex: o conjunto br_ibge_populacao cont\u00e9m uma tabela municipio com a s\u00e9rie hist\u00f3rica de popula\u00e7\u00e3o a n\u00edvel municipal) Cada tabela pertence a um \u00fanico conjunto de dados (ex: a tabela municipio em br_ibge_populacao \u00e9 diferente de municipio em br_bd_diretorios ) Veja aqui o guia do Google de como funciona a interface do BigQuery . Caso n\u00e3o apare\u00e7am as tabelas na 1\u00aa vez que voc\u00ea acessar, atualize a p\u00e1gina. Fa\u00e7a sua primeira consulta! Que tal fazer uma consulta simples? Vamos usar o Editor de Consultas do BigQuery para ver as informa\u00e7\u00f5es sobre munic\u00edpios direto na nossa base de diret\u00f3rios brasileiros. Para isso, copiar e colar o c\u00f3digo abaixo: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` S\u00f3 clicar em Executar e pronto! Dica Clicando no bot\u00e3o \ud83d\udd0d Consultar tabela/Query View , o BigQuery cria automaticamente a estrutura b\u00e1sica da sua query em Query Editor/Editor de consultas - basta voc\u00ea completar com os campos e filtros que achar necess\u00e1rios. Entenda o uso gratuito do Big Query BQ Est\u00e1 se\u00e7\u00e3o \u00e9 dedicada a apresentar dicas de como reduzir custos de processamento para aproveitar ao m\u00e1ximo os dados da BD! Para usu\u00e1rios que acessam os dados em projetos p\u00fablicos como o da Base dos Dados o \u00fanico tipo de custo associado se refere ao custo de processamento das consultas . A not\u00edcia boa, como mencionado acima, \u00e9 que todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consultar livremente os dados do maior data lake p\u00fablico do Brasil . Se voc\u00ea ainda n\u00e3o possui um projeto no BQ consulte a sess\u00e3o acima para cri\u00e1-lo. Conhecer o b\u00e1sico da interface do BQ \u00e9 importante para o entendimento do artigo. Caso voc\u00ea n\u00e3o tenha familiariadade ou queria revisitar a interface, sugerimos 3 trilhas: Nosso guia utilizando as tabelas da RAIS - Rela\u00e7\u00e3o Anual de Informa\u00e7\u00f5es Sociais Nosso acervo de v\u00eddeos no youtube A introdu\u00e7\u00e3o a interface feita pelo Google Veja como usufruir ao m\u00e1ximo das consultas gratuitas Nesta se\u00e7\u00e3o, apresentamos algumas dicas simples para reduzir os custos das consultas no Big Query e aproveitar ao m\u00e1ximo os dados da BD! Antes de partir para os exemplos, apresentaremos o mecanismo b\u00e1sico de previs\u00e3o de custos de processamento de consultas no Big Query (BQ). Estimativas de custos No canto superior direito da interface do BQ \u00e9 informado um aviso com estimativa do custo de processamento que ser\u00e1 cobrado do seu projeto apos a execu\u00e7\u00e3o da consulta. Este \u00e9 o mecanismo b\u00e1sico e prontamente acess\u00edvel de previsibilidade dos custos de processamento. Infelizmente, n\u00e3o funciona para todas as tabelas. Por motivos de limita\u00e7\u00e3o interna do pr\u00f3prio Big Query, consultas \u00e0 tabelas espec\u00edficas n\u00e3o exibem estimativas de custos. \u00c9 o caso das tabelas que possuem Row Access Policy . Isto \u00e9, tabelas onde o n\u00famero de linhas acess\u00edveis \u00e9 limitada a depender do usu\u00e1rio. Este \u00e9 o caso das tabelas que fazem parte do servi\u00e7o BDpro Exemplo da tabela agencia do conjunto br_bcb_estban . { width=100% } DICA 1: Selecione somente as colunas de interesse A arquitetura do Big Query utiliza o armazenamento orientado a colunas, isto \u00e9, cada coluna \u00e9 armazenada separadamente. Esta caracter\u00edstica tem uma implica\u00e7\u00e3o clara quanto aos custos de processamento: quanto mais colunas forem selecionadas, maior ser\u00e1 o custo. Evite : Selecionar colunas em excesso SELECT * Pr\u00e1tica recomendada : selecione somente as colunas de interesse para reduzir o custo final da consulta. SELECT coluna1 , coluna2 - Veja este a diferen\u00e7a obtida com a tabela microdados do conjunto br_ms_sim . Sem sele\u00e7\u00e3o de colunas: custo estimado 5.83 GB Selecionando 3 colunas: custo estimado 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` Para entender mais a fundo a arquitetura colunar, consulte a documenta\u00e7\u00e3o oficial do Big Query DICA 2: Utilize colunas particionadas e clusterizadas para filtrar os dados As parti\u00e7\u00f5es s\u00e3o divis\u00f5es feitas em uma tabela para facilitar o gerenciamento e a consulta dos dados. No momento de execu\u00e7\u00e3o da consulta, o Big Query ignora linhas que possuem um valor da parti\u00e7\u00e3o diferente do utilizado no filtro. Isto normalmente reduz significativamente a quantidade de linhas lidas e, o que nos interessa, reduz o custo de processamento . Clusters s\u00e3o agrupamentos organizados em uma tabela com base nos valores de uma ou mais colunas especificadas. Durante a execu\u00e7\u00e3o de uma consulta, o BigQuery otimiza a leitura dos dados, acessando apenas os segmentos que cont\u00eam os valores relevantes das colunas de cluster. Isso significa que, ao inv\u00e9s de escanear toda a tabela, apenas as partes necess\u00e1rias s\u00e3o lidas, o que geralmente reduz a quantidade de dados processados e, consequentemente, reduz o custo de processamento. Como saber qual coluna foi utilizada para particionar e clusterizar uma tabela espec\u00edfica? Pelos metadados na p\u00e1gina de tabela no site da BD Note que o campo Parti\u00e7\u00f5es no Big Query elenca tanto as parti\u00e7\u00f5es quanto os clusters. Pelos metadados na p\u00e1gina de 'Detalhes' no Big Query Note que s\u00e3o elencadas ambas informa\u00e7\u00f5es: parti\u00e7\u00f5es e clusters . Neste caso, a coluna ano foi definida como parti\u00e7\u00e3o e a coluna sigla_uf como cluster. Pr\u00e1tica recomendada : sempre que poss\u00edvel, utilize colunas particionadas e clusterizadas para filtrar/agregar os dados. Exemplo Consulta utilizado a coluna particionada como filtro: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 custo estimado : 31.32 MB. A combina\u00e7\u00e3o de t\u00e9cnicas de sele\u00e7\u00e3o de colunas e filtro utilizando parti\u00e7\u00e3o reduziu o custo estimado da consulta inicial de 5.83 GB para somente 31.32 MB DICA 3: Muita aten\u00e7\u00e3o ao realizar joins entre tabelas Avalie a real necessidade do JOIN Certifique-se de que o join \u00e9 realmente necess\u00e1rio para a an\u00e1lise que voc\u00ea est\u00e1 realizando. \u00c0s vezes, opera\u00e7\u00f5es alternativas como subconsultas ou agrega\u00e7\u00f5es podem ser mais eficientes. Entenda a L\u00f3gica do JOIN Diferentes tipos de joins (INNER, LEFT, RIGHT, FULL) t\u00eam diferentes implica\u00e7\u00f5es de desempenho e resultado. Gastar um tempinho entendo a melhor op\u00e7\u00e3o para seu objetivo de an\u00e1lise pode ajudar a ter um controle de custos mais eficiente. Um dos problemas mais comuns \u00e9 a multiplica\u00e7\u00e3o de linhas indesejadas no resultado final. Para entender a fundo boas pr\u00e1ticas e problemas recorrentes com joins sugerimos os guias SQL Joins na pr\u00e1tica e Maximizando a Efici\u00eancia com JOIN em Consultas SQL para Combinar Tabelas Utilize as dicas anteriores Selecione somente colunas de interesse Fa\u00e7a uso das colunas particionadas para filtrar os dados Atente-se a estimativa de custos antes de executar a consulta Tutoriais Como navegar pelo BigQuery Para entender mais sobre a interface do BigQuery e como explorar os dados, preparamos um texto completo no blog com um exemplo de busca dos dados da RAIS - Minist\u00e9rio da Economia . Cansado(a) da leitura? Temos tamb\u00e9m um v\u00eddeo completo no nosso Youtube . Entenda os dados O BigQuery possui um mecanismo de busca que permite buscar por nomes de datasets (conjuntos), tables (tabelas) ou labels (grupos). Constru\u00edmos regras de nomea\u00e7\u00e3o simples e pr\u00e1ticas para facilitar sua busca - veja mais . Entenda o uso gratuito do Big Query (BQ) Conectando com o PowerBI O Power BI \u00e9 uma das tecnologias mais populares para o desenvolvimento de dashboards com dados relacionais. Por isso, preparamos um tutorial para voc\u00ea descobrir como usar os dados do datalake no desenvolvimento dos seus dashboards . Manuais e Cursos de SQL Est\u00e1 come\u00e7ando a aprender sobre SQL para fazer suas consultas? Abaixo colocamos algumas recomenda\u00e7\u00f5es usadas pela nossa equipe tanto no aprendizado quanto no dia-a-dia: Lista de fun\u00e7\u00f5es em SQL da W3 Curso SQL na Codeacademy Curso de SQL do Programa\u00e7\u00e3o Din\u00e2mica","title":"BigQuery"},{"location":"access_data_bq/#bigquery","text":"O BigQuery \u00e9 o um servi\u00e7o de banco de dados em nuvem da Google. Voc\u00ea faz consultas ao banco em SQL direto do navegador com: Rapidez : Mesmo queries muito longas demoram apenas minutos para serem processadas. Escala : O BigQuery escala magicamente para hexabytes se necess\u00e1rio. Economia : Todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consulta aos dados . Pronto(a) para come\u00e7ar? Nesta p\u00e1gina voc\u00ea encontra: Primeiros passos Entenda o uso gratuito do Big Query BQ Tutoriais Manuais e Cursos de SQL","title":"BigQuery"},{"location":"access_data_bq/#primeiros-passos","text":"","title":"Primeiros passos"},{"location":"access_data_bq/#antes-de-comecar-crie-o-seu-projeto-no-google-cloud","text":"Para criar um projeto no Google Cloud basta ter um email cadastrado no Google. \u00c9 necess\u00e1rio ter um projeto seu, mesmo que vazio, para voc\u00ea fazer queries em nosso datalake p\u00fablico. Acesse o Google Cloud . Caso for a sua primeira vez, aceite o Termo de Servi\u00e7os. Clique em Create Project/Criar Projeto . Escolha um nome bacana para o projeto. Clique em Create/Criar Por que eu preciso criar um projeto no Google Cloud? A Google fornece 1 TB gratuito por m\u00eas de uso do BigQuery para cada projeto que voc\u00ea possui. Um projeto \u00e9 necess\u00e1rio para ativar os servi\u00e7os do Google Cloud, incluindo a permiss\u00e3o de uso do BigQuery. Pense no projeto como a \"conta\" na qual a Google vai contabilizar o quanto de processamento voc\u00ea j\u00e1 utilizou. N\u00e3o \u00e9 necess\u00e1rio adicionar nenhum cart\u00e3o ou forma de pagamento - O BigQuery inicia automaticamente no modo Sandbox, que permite voc\u00ea utilizar seus recursos sem adicionar um modo de pagamento. Leia mais aqui .","title":"Antes de come\u00e7ar: Crie o seu projeto no Google Cloud"},{"location":"access_data_bq/#acessando-o-datalake-da-basedosdados","text":"O bot\u00e3o abaixo via te direcionar ao nosso projeto no Google BigQuery: Ir para BigQuery Agora voc\u00ea precisa fixar o projeto da BD no seu BigQuery, \u00e9 bem simples, veja: !!! Warning A op\u00e7\u00e3o Fixar um projeto pode aparecer tamb\u00e9m como Marcar projeto com estrela por nome Dentro do projeto existem dois n\u00edveis de organiza\u00e7\u00e3o dos dados, datasets (conjuntos de dados) e tables (tabelas), nos quais: Todas as tabelas est\u00e3o organizadas dentro de cojuntos de dados , que representaam sua organiza\u00e7\u00e3o/tema (ex: o conjunto br_ibge_populacao cont\u00e9m uma tabela municipio com a s\u00e9rie hist\u00f3rica de popula\u00e7\u00e3o a n\u00edvel municipal) Cada tabela pertence a um \u00fanico conjunto de dados (ex: a tabela municipio em br_ibge_populacao \u00e9 diferente de municipio em br_bd_diretorios ) Veja aqui o guia do Google de como funciona a interface do BigQuery . Caso n\u00e3o apare\u00e7am as tabelas na 1\u00aa vez que voc\u00ea acessar, atualize a p\u00e1gina.","title":"Acessando o datalake da basedosdados"},{"location":"access_data_bq/#faca-sua-primeira-consulta","text":"Que tal fazer uma consulta simples? Vamos usar o Editor de Consultas do BigQuery para ver as informa\u00e7\u00f5es sobre munic\u00edpios direto na nossa base de diret\u00f3rios brasileiros. Para isso, copiar e colar o c\u00f3digo abaixo: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` S\u00f3 clicar em Executar e pronto! Dica Clicando no bot\u00e3o \ud83d\udd0d Consultar tabela/Query View , o BigQuery cria automaticamente a estrutura b\u00e1sica da sua query em Query Editor/Editor de consultas - basta voc\u00ea completar com os campos e filtros que achar necess\u00e1rios.","title":"Fa\u00e7a sua primeira consulta!"},{"location":"access_data_bq/#entenda-o-uso-gratuito-do-big-query-bq","text":"Est\u00e1 se\u00e7\u00e3o \u00e9 dedicada a apresentar dicas de como reduzir custos de processamento para aproveitar ao m\u00e1ximo os dados da BD! Para usu\u00e1rios que acessam os dados em projetos p\u00fablicos como o da Base dos Dados o \u00fanico tipo de custo associado se refere ao custo de processamento das consultas . A not\u00edcia boa, como mencionado acima, \u00e9 que todo usu\u00e1rio possui 1 TB gratuito por m\u00eas para consultar livremente os dados do maior data lake p\u00fablico do Brasil . Se voc\u00ea ainda n\u00e3o possui um projeto no BQ consulte a sess\u00e3o acima para cri\u00e1-lo. Conhecer o b\u00e1sico da interface do BQ \u00e9 importante para o entendimento do artigo. Caso voc\u00ea n\u00e3o tenha familiariadade ou queria revisitar a interface, sugerimos 3 trilhas: Nosso guia utilizando as tabelas da RAIS - Rela\u00e7\u00e3o Anual de Informa\u00e7\u00f5es Sociais Nosso acervo de v\u00eddeos no youtube A introdu\u00e7\u00e3o a interface feita pelo Google","title":"Entenda o uso gratuito do Big Query BQ"},{"location":"access_data_bq/#veja-como-usufruir-ao-maximo-das-consultas-gratuitas","text":"Nesta se\u00e7\u00e3o, apresentamos algumas dicas simples para reduzir os custos das consultas no Big Query e aproveitar ao m\u00e1ximo os dados da BD! Antes de partir para os exemplos, apresentaremos o mecanismo b\u00e1sico de previs\u00e3o de custos de processamento de consultas no Big Query (BQ). Estimativas de custos No canto superior direito da interface do BQ \u00e9 informado um aviso com estimativa do custo de processamento que ser\u00e1 cobrado do seu projeto apos a execu\u00e7\u00e3o da consulta. Este \u00e9 o mecanismo b\u00e1sico e prontamente acess\u00edvel de previsibilidade dos custos de processamento. Infelizmente, n\u00e3o funciona para todas as tabelas. Por motivos de limita\u00e7\u00e3o interna do pr\u00f3prio Big Query, consultas \u00e0 tabelas espec\u00edficas n\u00e3o exibem estimativas de custos. \u00c9 o caso das tabelas que possuem Row Access Policy . Isto \u00e9, tabelas onde o n\u00famero de linhas acess\u00edveis \u00e9 limitada a depender do usu\u00e1rio. Este \u00e9 o caso das tabelas que fazem parte do servi\u00e7o BDpro Exemplo da tabela agencia do conjunto br_bcb_estban . { width=100% }","title":"Veja como usufruir ao m\u00e1ximo das consultas gratuitas"},{"location":"access_data_bq/#dica-1-selecione-somente-as-colunas-de-interesse","text":"A arquitetura do Big Query utiliza o armazenamento orientado a colunas, isto \u00e9, cada coluna \u00e9 armazenada separadamente. Esta caracter\u00edstica tem uma implica\u00e7\u00e3o clara quanto aos custos de processamento: quanto mais colunas forem selecionadas, maior ser\u00e1 o custo. Evite : Selecionar colunas em excesso SELECT * Pr\u00e1tica recomendada : selecione somente as colunas de interesse para reduzir o custo final da consulta. SELECT coluna1 , coluna2 - Veja este a diferen\u00e7a obtida com a tabela microdados do conjunto br_ms_sim . Sem sele\u00e7\u00e3o de colunas: custo estimado 5.83 GB Selecionando 3 colunas: custo estimado 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` Para entender mais a fundo a arquitetura colunar, consulte a documenta\u00e7\u00e3o oficial do Big Query","title":"DICA 1: Selecione somente as colunas de interesse"},{"location":"access_data_bq/#dica-2-utilize-colunas-particionadas-e-clusterizadas-para-filtrar-os-dados","text":"As parti\u00e7\u00f5es s\u00e3o divis\u00f5es feitas em uma tabela para facilitar o gerenciamento e a consulta dos dados. No momento de execu\u00e7\u00e3o da consulta, o Big Query ignora linhas que possuem um valor da parti\u00e7\u00e3o diferente do utilizado no filtro. Isto normalmente reduz significativamente a quantidade de linhas lidas e, o que nos interessa, reduz o custo de processamento . Clusters s\u00e3o agrupamentos organizados em uma tabela com base nos valores de uma ou mais colunas especificadas. Durante a execu\u00e7\u00e3o de uma consulta, o BigQuery otimiza a leitura dos dados, acessando apenas os segmentos que cont\u00eam os valores relevantes das colunas de cluster. Isso significa que, ao inv\u00e9s de escanear toda a tabela, apenas as partes necess\u00e1rias s\u00e3o lidas, o que geralmente reduz a quantidade de dados processados e, consequentemente, reduz o custo de processamento. Como saber qual coluna foi utilizada para particionar e clusterizar uma tabela espec\u00edfica? Pelos metadados na p\u00e1gina de tabela no site da BD Note que o campo Parti\u00e7\u00f5es no Big Query elenca tanto as parti\u00e7\u00f5es quanto os clusters. Pelos metadados na p\u00e1gina de 'Detalhes' no Big Query Note que s\u00e3o elencadas ambas informa\u00e7\u00f5es: parti\u00e7\u00f5es e clusters . Neste caso, a coluna ano foi definida como parti\u00e7\u00e3o e a coluna sigla_uf como cluster. Pr\u00e1tica recomendada : sempre que poss\u00edvel, utilize colunas particionadas e clusterizadas para filtrar/agregar os dados. Exemplo Consulta utilizado a coluna particionada como filtro: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 custo estimado : 31.32 MB. A combina\u00e7\u00e3o de t\u00e9cnicas de sele\u00e7\u00e3o de colunas e filtro utilizando parti\u00e7\u00e3o reduziu o custo estimado da consulta inicial de 5.83 GB para somente 31.32 MB","title":"DICA 2: Utilize colunas particionadas e clusterizadas para filtrar os dados"},{"location":"access_data_bq/#dica-3-muita-atencao-ao-realizar-joins-entre-tabelas","text":"Avalie a real necessidade do JOIN Certifique-se de que o join \u00e9 realmente necess\u00e1rio para a an\u00e1lise que voc\u00ea est\u00e1 realizando. \u00c0s vezes, opera\u00e7\u00f5es alternativas como subconsultas ou agrega\u00e7\u00f5es podem ser mais eficientes. Entenda a L\u00f3gica do JOIN Diferentes tipos de joins (INNER, LEFT, RIGHT, FULL) t\u00eam diferentes implica\u00e7\u00f5es de desempenho e resultado. Gastar um tempinho entendo a melhor op\u00e7\u00e3o para seu objetivo de an\u00e1lise pode ajudar a ter um controle de custos mais eficiente. Um dos problemas mais comuns \u00e9 a multiplica\u00e7\u00e3o de linhas indesejadas no resultado final. Para entender a fundo boas pr\u00e1ticas e problemas recorrentes com joins sugerimos os guias SQL Joins na pr\u00e1tica e Maximizando a Efici\u00eancia com JOIN em Consultas SQL para Combinar Tabelas Utilize as dicas anteriores Selecione somente colunas de interesse Fa\u00e7a uso das colunas particionadas para filtrar os dados Atente-se a estimativa de custos antes de executar a consulta","title":"DICA 3: Muita aten\u00e7\u00e3o ao realizar joins entre tabelas"},{"location":"access_data_bq/#tutoriais","text":"","title":"Tutoriais"},{"location":"access_data_bq/#como-navegar-pelo-bigquery","text":"Para entender mais sobre a interface do BigQuery e como explorar os dados, preparamos um texto completo no blog com um exemplo de busca dos dados da RAIS - Minist\u00e9rio da Economia . Cansado(a) da leitura? Temos tamb\u00e9m um v\u00eddeo completo no nosso Youtube .","title":"Como navegar pelo BigQuery"},{"location":"access_data_bq/#entenda-os-dados","text":"O BigQuery possui um mecanismo de busca que permite buscar por nomes de datasets (conjuntos), tables (tabelas) ou labels (grupos). Constru\u00edmos regras de nomea\u00e7\u00e3o simples e pr\u00e1ticas para facilitar sua busca - veja mais .","title":"Entenda os dados"},{"location":"access_data_bq/#entenda-o-uso-gratuito-do-big-query-bq_1","text":"","title":"Entenda o uso gratuito do Big Query (BQ)"},{"location":"access_data_bq/#conectando-com-o-powerbi","text":"O Power BI \u00e9 uma das tecnologias mais populares para o desenvolvimento de dashboards com dados relacionais. Por isso, preparamos um tutorial para voc\u00ea descobrir como usar os dados do datalake no desenvolvimento dos seus dashboards .","title":"Conectando com o PowerBI"},{"location":"access_data_bq/#manuais-e-cursos-de-sql","text":"Est\u00e1 come\u00e7ando a aprender sobre SQL para fazer suas consultas? Abaixo colocamos algumas recomenda\u00e7\u00f5es usadas pela nossa equipe tanto no aprendizado quanto no dia-a-dia: Lista de fun\u00e7\u00f5es em SQL da W3 Curso SQL na Codeacademy Curso de SQL do Programa\u00e7\u00e3o Din\u00e2mica","title":"Manuais e Cursos de SQL"},{"location":"access_data_packages/","text":"Pacotes Os pacotes da Base dos Dados permitem o acesso ao datalake p\u00fablico direto do seu computador ou ambiente de desenvolvimento. Atualmente dispon\u00edveis em: Python R Stata CLI (terminal) Pronto(a) para come\u00e7ar? Nesta p\u00e1gina voc\u00ea encontra: Primeiros passos Tutoriais Manuais de refer\u00eancia Primeiros passos Antes de come\u00e7ar: Crie o seu projeto no Google Cloud Para criar um projeto no Google Cloud basta ter um email cadastrado no Google. \u00c9 necess\u00e1rio ter um projeto seu, mesmo que vazio, para voc\u00ea fazer queries em nosso datalake p\u00fablico. Acesse o Google Cloud . Caso for a sua primeira vez, aceite o Termo de Servi\u00e7os. Clique em Create Project/Criar Projeto . Escolha um nome bacana para o projeto. Clique em Create/Criar Por que eu preciso criar um projeto no Google Cloud? A Google fornece 1 TB gratuito por m\u00eas de uso do BigQuery para cada projeto que voc\u00ea possui. Um projeto \u00e9 necess\u00e1rio para ativar os servi\u00e7os do Google Cloud, incluindo a permiss\u00e3o de uso do BigQuery. Pense no projeto como a \"conta\" na qual a Google vai contabilizar o quanto de processamento voc\u00ea j\u00e1 utilizou. N\u00e3o \u00e9 necess\u00e1rio adicionar nenhum cart\u00e3o ou forma de pagamento - O BigQuery inicia automaticamente no modo Sandbox, que permite voc\u00ea utilizar seus recursos sem adicionar um modo de pagamento. Leia mais aqui . Instalando o pacote Para instala\u00e7\u00e3o do pacote em Python e linha de comando, voc\u00ea pode usar o pip direto do seu terminal. Em R, basta instalar diretamente no RStudio ou editor de sua prefer\u00eancia. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimentos: Garantir que seu Stata seja a vers\u00e3o 16+ Garantir que o Python esteja instalado no seu computador. Com os requerimentos satisfeitos, rodar os comandos abaixo: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" ) Configurando o pacote Uma vez com seu projeto, voc\u00ea precisa configurar o pacote para usar o ID desse projeto nas consultas ao datalake . Para isso, voc\u00ea deve usar o project_id que a Google fornece para voc\u00ea assim que o projeto \u00e9 criado. Python/CLI N\u00e3o \u00e9 necess\u00e1rio configurar o projeto de antem\u00e3o. Assim que voc\u00ea roda a 1\u00aa consulta, o pacote ir\u00e1 indicar os passos para configura\u00e7\u00e3o. R Uma vez com o project_id , voc\u00ea deve passar essa informa\u00e7\u00e3o para o pacote usando a fun\u00e7\u00e3o set_billing_id . set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata \u00c9 necess\u00e1rio especificar o project_id a cada vez que usar o pacote. Fa\u00e7a sua primeira consulta Um exemplo simples para come\u00e7ar a explorar o datalake \u00e9 puxar informa\u00e7\u00f5es cadastrais de munic\u00edpios direto na nossa base de Diret\u00f3rios Brasileiros (tabela municipio ) . Para isso, vamos usar a fun\u00e7\u00e3o download , baixando os dados direto para nossa m\u00e1quina. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia . Tutoriais Como usar os pacotes Preparamos tutoriais apresentando as principais fun\u00e7\u00f5es de cada pacote para voc\u00ea come\u00e7ar a us\u00e1-los. Python Blog: Introdu\u00e7\u00e3o ao pacote Python Introdu\u00e7\u00e3o ao pacote Python (cont.) V\u00eddeos: Workshop: Aplica\u00e7\u00f5es em Python R Blog: Introdu\u00e7\u00e3o ao pacote R Explorando o Censo Escolar An\u00e1lise: O Brasil nas Olimp\u00edadas V\u00eddeos: Workshop: Aprenda a acessar dados p\u00fablicos em R Stata Documenta\u00e7\u00e3o: GitHub Manuais de refer\u00eancia (API) Python R Stata CLI","title":"Pacotes"},{"location":"access_data_packages/#pacotes","text":"Os pacotes da Base dos Dados permitem o acesso ao datalake p\u00fablico direto do seu computador ou ambiente de desenvolvimento. Atualmente dispon\u00edveis em: Python R Stata CLI (terminal) Pronto(a) para come\u00e7ar? Nesta p\u00e1gina voc\u00ea encontra: Primeiros passos Tutoriais Manuais de refer\u00eancia","title":"Pacotes"},{"location":"access_data_packages/#primeiros-passos","text":"","title":"Primeiros passos"},{"location":"access_data_packages/#antes-de-comecar-crie-o-seu-projeto-no-google-cloud","text":"Para criar um projeto no Google Cloud basta ter um email cadastrado no Google. \u00c9 necess\u00e1rio ter um projeto seu, mesmo que vazio, para voc\u00ea fazer queries em nosso datalake p\u00fablico. Acesse o Google Cloud . Caso for a sua primeira vez, aceite o Termo de Servi\u00e7os. Clique em Create Project/Criar Projeto . Escolha um nome bacana para o projeto. Clique em Create/Criar Por que eu preciso criar um projeto no Google Cloud? A Google fornece 1 TB gratuito por m\u00eas de uso do BigQuery para cada projeto que voc\u00ea possui. Um projeto \u00e9 necess\u00e1rio para ativar os servi\u00e7os do Google Cloud, incluindo a permiss\u00e3o de uso do BigQuery. Pense no projeto como a \"conta\" na qual a Google vai contabilizar o quanto de processamento voc\u00ea j\u00e1 utilizou. N\u00e3o \u00e9 necess\u00e1rio adicionar nenhum cart\u00e3o ou forma de pagamento - O BigQuery inicia automaticamente no modo Sandbox, que permite voc\u00ea utilizar seus recursos sem adicionar um modo de pagamento. Leia mais aqui .","title":"Antes de come\u00e7ar: Crie o seu projeto no Google Cloud"},{"location":"access_data_packages/#instalando-o-pacote","text":"Para instala\u00e7\u00e3o do pacote em Python e linha de comando, voc\u00ea pode usar o pip direto do seu terminal. Em R, basta instalar diretamente no RStudio ou editor de sua prefer\u00eancia. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimentos: Garantir que seu Stata seja a vers\u00e3o 16+ Garantir que o Python esteja instalado no seu computador. Com os requerimentos satisfeitos, rodar os comandos abaixo: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" )","title":"Instalando o pacote"},{"location":"access_data_packages/#configurando-o-pacote","text":"Uma vez com seu projeto, voc\u00ea precisa configurar o pacote para usar o ID desse projeto nas consultas ao datalake . Para isso, voc\u00ea deve usar o project_id que a Google fornece para voc\u00ea assim que o projeto \u00e9 criado. Python/CLI N\u00e3o \u00e9 necess\u00e1rio configurar o projeto de antem\u00e3o. Assim que voc\u00ea roda a 1\u00aa consulta, o pacote ir\u00e1 indicar os passos para configura\u00e7\u00e3o. R Uma vez com o project_id , voc\u00ea deve passar essa informa\u00e7\u00e3o para o pacote usando a fun\u00e7\u00e3o set_billing_id . set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata \u00c9 necess\u00e1rio especificar o project_id a cada vez que usar o pacote.","title":"Configurando o pacote"},{"location":"access_data_packages/#faca-sua-primeira-consulta","text":"Um exemplo simples para come\u00e7ar a explorar o datalake \u00e9 puxar informa\u00e7\u00f5es cadastrais de munic\u00edpios direto na nossa base de Diret\u00f3rios Brasileiros (tabela municipio ) . Para isso, vamos usar a fun\u00e7\u00e3o download , baixando os dados direto para nossa m\u00e1quina. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' Para entender mais sobre a fun\u00e7\u00e3o download , leia o manual de refer\u00eancia .","title":"Fa\u00e7a sua primeira consulta"},{"location":"access_data_packages/#tutoriais","text":"","title":"Tutoriais"},{"location":"access_data_packages/#como-usar-os-pacotes","text":"Preparamos tutoriais apresentando as principais fun\u00e7\u00f5es de cada pacote para voc\u00ea come\u00e7ar a us\u00e1-los. Python Blog: Introdu\u00e7\u00e3o ao pacote Python Introdu\u00e7\u00e3o ao pacote Python (cont.) V\u00eddeos: Workshop: Aplica\u00e7\u00f5es em Python R Blog: Introdu\u00e7\u00e3o ao pacote R Explorando o Censo Escolar An\u00e1lise: O Brasil nas Olimp\u00edadas V\u00eddeos: Workshop: Aprenda a acessar dados p\u00fablicos em R Stata Documenta\u00e7\u00e3o: GitHub","title":"Como usar os pacotes"},{"location":"access_data_packages/#manuais-de-referencia-api","text":"Python R Stata CLI","title":"Manuais de refer\u00eancia (API)"},{"location":"api_reference_python/","text":"Python Esta API \u00e9 composta por fun\u00e7\u00f5es com 2 tipos de funcionalidade: M\u00f3dulos para requisi\u00e7\u00e3o de dados : para aquele(as) que desejam somente consultar os dados e metadados do nosso projeto. Classes para gerenciamento de dados no Google Cloud: para aqueles(as) que desejam subir dados no nosso projeto (ou qualquer outro projeto no Google Cloud, seguindo a nossa metodologia e infraestrutura). Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas M\u00f3dulos (Requisi\u00e7\u00e3o de dados) Functions to get metadata from BD's API check_input ( f ) Checks if the number of inputs is valid Source code in basedosdados/download/metadata.py def check_input ( f ): \"\"\"Checks if the number of inputs is valid\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if sum ([ a is not None for a in args ]) > 1 : raise ValueError ( \"At most one of the inputs must be non null\" ) return f ( * args , ** kwargs ) return wrapper get_columns ( table_id = None , column_id = None , columns_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available columns, either by table_id , column_id or column_name Parameters: Name Type Description Default table_id(str) table slug in google big query (gbq). required column_id(str) column slug in google big query (gbq). required column_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_columns ( table_id : str = None , column_id : str = None , columns_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available columns, either by `table_id`, `column_id` or `column_name` Args: table_id(str): table slug in google big query (gbq). column_id(str): column slug in google big query (gbq). column_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" result = backend . get_columns ( table_id , column_id , columns_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"bigquery_type\" ] = item . pop ( \"bigqueryType\" , {}) . get ( \"name\" ) return result get_datasets ( dataset_id = None , dataset_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available datasets, either by dataset_id or dataset_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required dataset_name(str) dataset name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_datasets ( dataset_id : str = None , dataset_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available datasets, either by `dataset_id` or `dataset_name` Args: dataset_id(str): dataset slug in google big query (gbq). dataset_name(str): dataset name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets. \"\"\" result = backend . get_datasets ( dataset_id , dataset_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"organization\" ] = item . get ( \"organization\" , {}) . get ( \"name\" ) item [ \"tags\" ] = [ i . get ( \"name\" ) for i in item . get ( \"tags\" , {}) . get ( \"items\" )] item [ \"themes\" ] = [ i . get ( \"name\" ) for i in item . get ( \"themes\" , {}) . get ( \"items\" )] return result get_tables ( dataset_id = None , table_id = None , table_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available tables, either by dataset_id , table_id or table_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required table_id(str) table slug in google big query (gbq). required table_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_tables ( dataset_id : str = None , table_id : str = None , table_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available tables, either by `dataset_id`, `table_id` or `table_name` Args: dataset_id(str): dataset slug in google big query (gbq). table_id(str): table slug in google big query (gbq). table_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" return backend . get_tables ( dataset_id , table_id , table_name , page , page_size ) inject_backend ( f ) Inject backend instance if doesn't exists Source code in basedosdados/download/metadata.py def inject_backend ( f ): \"\"\"Inject backend instance if doesn't exists\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if \"backend\" not in kwargs : kwargs [ \"backend\" ] = Backend () return f ( * args , ** kwargs ) return wrapper search ( q = None , page = 1 , page_size = 10 , backend = None ) Search for datasets, querying all available metadata for the term q Parameters: Name Type Description Default q(str) search term. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets and metadata. Source code in basedosdados/download/metadata.py @check_input @inject_backend def search ( q : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Search for datasets, querying all available metadata for the term `q` Args: q(str): search term. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets and metadata. \"\"\" items = [] for item in backend . search ( q , page , page_size ) . get ( \"results\" , []): items . append ( { \"slug\" : item . get ( \"slug\" ), \"name\" : item . get ( \"name\" ), \"description\" : item . get ( \"description\" ), \"n_tables\" : item . get ( \"n_tables\" ), \"n_raw_data_sources\" : item . get ( \"n_raw_data_sources\" ), \"n_information_requests\" : item . get ( \"n_information_requests\" ), \"organization\" : { \"slug\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"slug\" ), \"name\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"name\" ), }, } ) return items Functions for managing downloads download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , compression = 'GZIP' ) Download table or query result from basedosdados BigQuery (or other). Using a query : download('select * from basedosdados.br_suporte.diretorio_municipios limit 10') Using dataset_id & table_id : download(dataset_id='br_suporte', table_id='diretorio_municipios') You can also add arguments to modify save parameters: download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|') Parameters: Name Type Description Default savepath str, pathlib.PosixPath savepath must be a file path. Only supports .csv . required query str Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. None dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. None table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. None billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional Number of rows. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False compression str Optional. Compression type. Only GZIP is available for now. 'GZIP' Exceptions: Type Description Exception If either table_id, dataset_id or query are empty. Source code in basedosdados/download/download.py def download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , compression = \"GZIP\" , ): \"\"\"Download table or query result from basedosdados BigQuery (or other). * Using a **query**: `download('select * from `basedosdados.br_suporte.diretorio_municipios` limit 10')` * Using **dataset_id & table_id**: `download(dataset_id='br_suporte', table_id='diretorio_municipios')` You can also add arguments to modify save parameters: `download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|')` Args: savepath (str, pathlib.PosixPath): savepath must be a file path. Only supports `.csv`. query (str): Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional Number of rows. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. compression (str): Optional. Compression type. Only `GZIP` is available for now. Raises: Exception: If either table_id, dataset_id or query are empty. \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( query is None ) and (( table_id is None ) or ( dataset_id is None )): raise BaseDosDadosException ( \"Either table_id, dataset_id or query should be filled.\" ) client = _google_client ( billing_project_id , from_file , reauth ) # makes sure that savepath is a filepath and not a folder savepath = _sets_savepath ( savepath ) # if query is not defined (so it won't be overwritten) and if # table is a view or external or if limit is specified, # convert it to a query. if not query and ( not _is_table ( client , dataset_id , table_id , query_project_id ) or limit ): query = f \"\"\" SELECT * FROM { query_project_id } . { dataset_id } . { table_id } \"\"\" if limit is not None : query += f \" limit { limit } \" if query : # sql queries produces anonymous tables, whose names # can be found within `job._properties` job = client [ \"bigquery\" ] . query ( query ) # views may take longer: wait for job to finish. _wait_for ( job ) dest_table = job . _properties [ \"configuration\" ][ \"query\" ][ \"destinationTable\" ] project_id = dest_table [ \"projectId\" ] dataset_id = dest_table [ \"datasetId\" ] table_id = dest_table [ \"tableId\" ] _direct_download ( client , dataset_id , table_id , savepath , project_id , compression ) read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Parameters: Name Type Description Default query sql Valid SQL Standard Query to basedosdados required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Args: query (sql): Valid SQL Standard Query to basedosdados billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) try : # Set a two hours timeout bigquery_storage_v1 . client . BigQueryReadClient . read_rows = partialmethod ( bigquery_storage_v1 . client . BigQueryReadClient . read_rows , timeout = 3600 * 2 , ) return read_gbq ( query , project_id = config . billing_project_id , use_bqstorage_api = use_bqstorage_api , credentials = _credentials ( from_file = config . from_file , reauth = reauth ), ) except GenericGBQException as e : if \"Reason: 403\" in str ( e ): raise BaseDosDadosAccessDeniedException from e if re . match ( \"Reason: 400 POST .* [Pp]roject[ ]*I[Dd]\" , str ( e )): raise BaseDosDadosInvalidProjectIDException from e raise except PyDataCredentialsError as e : raise BaseDosDadosAuthorizationException from e except ( OSError , ValueError ) as e : no_billing_id = \"Could not determine project ID\" in str ( e ) no_billing_id |= \"reading from stdin while output is captured\" in str ( e ) if no_billing_id : raise BaseDosDadosNoBillingProjectIDException from e raise read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using dataset_id and table_id. Parameters: Name Type Description Default dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. required table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional. Number of rows to read from table. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using dataset_id and table_id. Args: dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional. Number of rows to read from table. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( dataset_id is not None ) and ( table_id is not None ): query = f \"\"\" SELECT * FROM ` { query_project_id } . { dataset_id } . { table_id } `\"\"\" if limit is not None : query += f \" LIMIT { limit } \" else : raise BaseDosDadosException ( \"Both table_id and dataset_id should be filled.\" ) return read_sql ( query , billing_project_id = billing_project_id , from_file = from_file , reauth = reauth , use_bqstorage_api = use_bqstorage_api , ) Classes (Gerenciamento de dados) Class for managing the files in cloud storage. Storage ( Base ) Manage files on Google Cloud Storage. Source code in basedosdados/upload/storage.py class Storage ( Base ): \"\"\" Manage files on Google Cloud Storage. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . bucket = self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_id = table_id . replace ( \"-\" , \"_\" ) @staticmethod def _resolve_partitions ( partitions ): if isinstance ( partitions , dict ): return \"/\" . join ( f \" { k } = { v } \" for k , v in partitions . items ()) + \"/\" if isinstance ( partitions , str ): if partitions . endswith ( \"/\" ): partitions = partitions [: - 1 ] # If there is no partition if len ( partitions ) == 0 : return \"\" # It should fail if there is folder which is not a partition try : # check if it fits rule { b . split ( \"=\" )[ 0 ]: b . split ( \"=\" )[ 1 ] for b in partitions . split ( \"/\" )} except IndexError as e : raise Exception ( f \"The path { partitions } is not a valid partition\" ) from e return partitions + \"/\" raise Exception ( f \"Partitions format or type not accepted: { partitions } \" ) def _build_blob_name ( self , filename , mode , partitions = None ): \"\"\" Builds the blob name. \"\"\" # table folder blob_name = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # add partition folder if partitions is not None : blob_name += self . _resolve_partitions ( partitions ) # add file name blob_name += filename return blob_name def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) copy_table ( self , source_bucket_name = 'basedosdados' , destination_bucket_name = None , mode = 'staging' , new_table_id = None ) Copies table from a source bucket to your bucket, sends request in batches. Parameters: Name Type Description Default source_bucket_name str The bucket name from which to copy data. You can change it to copy from other external bucket. 'basedosdados' destination_bucket_name str Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) None mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' new_table_id str Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. None Source code in basedosdados/upload/storage.py def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) delete_file ( self , filename , mode , partitions = None , not_found_ok = False ) Deletes file from path <bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename> . Parameters: Name Type Description Default filename str Name of the file to be deleted required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] required partitions str, pathlib.PosixPath, or dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None not_found_ok bool Optional. What to do if file not found False Source code in basedosdados/upload/storage.py def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) delete_table ( self , mode = 'staging' , bucket_name = None , not_found_ok = False ) Deletes a table from storage, sends request in batches. Parameters: Name Type Description Default mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' bucket_name str The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) None not_found_ok bool Optional. What to do if table not found False Source code in basedosdados/upload/storage.py def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) download ( self , filename = '*' , savepath = '.' , partitions = None , mode = 'staging' , if_not_exists = 'raise' ) Download files from Google Storage from path mode / dataset_id / table_id / partitions / filename and replicate folder hierarchy on save, There are 5 modes: * raw : should contain raw files from datasource * staging : should contain pre-treated files ready to upload to BiqQuery * header : should contain the header of the tables * auxiliary_files : should contain auxiliary files from eache table * architecture : should contain the architecture sheet of the tables You can also use the partitions argument to choose files from a partition Parameters: Name Type Description Default filename str Optional Specify which file to download. If \" \" , downloads all files within the bucket folder. Defaults to \" \". '*' savepath str Where you want to save the data on your computer. Must be a path to a directory. '.' partitions str, dict Optional If downloading a single file, use this to specify the partition path from which to download. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None mode str Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] 'staging' if_not_exists str Optional. What to do if data not found. 'raise' : Raises FileNotFoundError. 'pass' : Do nothing and exit the function 'raise' Exceptions: Type Description FileNotFoundError If the given path <mode>/<dataset_id>/<table_id>/<partitions>/<filename> could not be found or there are no files to download. Source code in basedosdados/upload/storage.py def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) init ( self , replace = False , very_sure = False ) Initializes bucket and folders. Folder should be: raw : that contains really raw data staging : preprocessed data ready to upload to BigQuery Parameters: Name Type Description Default replace bool Optional. Whether to replace if bucket already exists False very_sure bool Optional. Are you aware that everything is going to be erased if you replace the bucket? False Exceptions: Type Description Warning very_sure argument is still False. Source code in basedosdados/upload/storage.py def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) upload ( self , path , mode = 'all' , partitions = None , if_exists = 'raise' , chunk_size = None , ** upload_args ) Upload to storage at <bucket_name>/<mode>/<dataset_id>/<table_id> . You can: Add a single file setting path = <file_path> . Add a folder with multiple files setting path = <folder_path> . The folder should just contain the files and no folders. Add partitioned files setting path = <folder_path> . This folder must follow the hive partitioning scheme i.e. <table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv (ex: mytable/country=brasil/year=2020/mypart.csv ). Remember all files must follow a single schema. Otherwise, things might fail in the future. There are 6 modes: raw : should contain raw files from datasource staging : should contain pre-treated files ready to upload to BiqQuery header : should contain the header of the tables auxiliary_files : should contain auxiliary files from eache table architecture : should contain the architecture sheet of the tables all : if no treatment is needed, use all . Parameters: Name Type Description Default path str or pathlib.PosixPath Where to find the file or folder that you want to upload to storage required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] 'all' partitions str, pathlib.PosixPath, or dict Optional. If adding a single file , use this to add it to a specific partition. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str Optional. What to do if data exists 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None upload_args Extra arguments accepted by google.cloud.storage.blob.Blob.upload_from_file {} Source code in basedosdados/upload/storage.py def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) Module for manage dataset to the server. Dataset ( Base ) Manage datasets in BigQuery. Source code in basedosdados/upload/dataset.py class Dataset ( Base ): \"\"\" Manage datasets in BigQuery. \"\"\" def __init__ ( self , dataset_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) @property @lru_cache def dataset_config ( self ): \"\"\" Dataset config file. \"\"\" return self . backend . get_dataset_config ( self . dataset_id ) def _loop_modes ( self , mode = \"all\" ): \"\"\" Loop modes. \"\"\" def dataset_tag ( m ): return f \"_ { m } \" if m == \"staging\" else \"\" mode = [ \"prod\" , \"staging\" ] if mode == \"all\" else [ mode ] return ( { \"client\" : self . client [ f \"bigquery_ { m } \" ], \"id\" : f \" { self . client [ f 'bigquery_ { m } ' ] . project } . { self . dataset_id }{ dataset_tag ( m ) } \" , \"mode\" : m , } for m in mode ) def _setup_dataset_object ( self , dataset_id , location = None , mode = \"staging\" ): \"\"\" Setup dataset object. \"\"\" dataset = bigquery . Dataset ( dataset_id ) if mode == \"staging\" : dataset_path = dataset_id . replace ( \"_staging\" , \"\" ) description = f \"staging dataset for ` { dataset_path } `\" labels = { \"staging\" : True } else : try : description = self . dataset_config . get ( \"descriptionPt\" , \"\" ) labels = { tag . get ( \"namePt\" ): True for tag in self . dataset_config . get ( \"tags\" ) } except BaseException : logger . warning ( f \"dataset { dataset_id } does not have a description in the API.\" ) description = \"description not available in the API.\" labels = {} dataset . description = description dataset . labels = labels dataset . location = location return dataset def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) dataset_config property readonly Dataset config file. create ( self , mode = 'all' , if_exists = 'raise' , dataset_is_public = True , location = None ) Creates BigQuery datasets given dataset_id . It can create two datasets: <dataset_id> (mode = 'prod') <dataset_id>_staging (mode = 'staging') If mode is all, it creates both. Parameters: Name Type Description Default mode str Optional. Which dataset to create [prod|staging|all]. 'all' if_exists str Optional. What to do if dataset exists raise : Raises Conflict exception replace : Drop all tables and replace dataset update : Update dataset description pass : Do nothing 'raise' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Exceptions: Type Description Warning Dataset already exists and if_exists is set to raise Source code in basedosdados/upload/dataset.py def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e delete ( self , mode = 'all' ) Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Parameters: Name Type Description Default mode str Optional. Which dataset to delete [prod|staging|all] 'all' Source code in basedosdados/upload/dataset.py def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) exists ( self , mode = 'staging' ) Check if dataset exists. Source code in basedosdados/upload/dataset.py def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) publicize ( self , mode = 'all' , dataset_is_public = True ) Changes IAM configuration to turn BigQuery dataset public. Parameters: Name Type Description Default mode bool Which dataset to create [prod|staging|all]. 'all' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True Source code in basedosdados/upload/dataset.py def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) update ( self , mode = 'all' , location = None ) Update dataset description. Toogle mode to choose which dataset to update. Parameters: Name Type Description Default mode str Optional. Which dataset to update [prod|staging|all] 'all' location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Source code in basedosdados/upload/dataset.py def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) Class for manage tables in Storage and Big Query Table ( Base ) Manage tables in Google Cloud Storage and BigQuery. Source code in basedosdados/upload/table.py class Table ( Base ): \"\"\" Manage tables in Google Cloud Storage and BigQuery. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . table_id = table_id . replace ( \"-\" , \"_\" ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_full_name = dict ( prod = f \" { self . client [ 'bigquery_prod' ] . project } . { self . dataset_id } . { self . table_id } \" , staging = f \" { self . client [ 'bigquery_staging' ] . project } . { self . dataset_id } _staging. { self . table_id } \" , ) self . table_full_name . update ( dict ( all = deepcopy ( self . table_full_name ))) @property @lru_cache ( 256 ) def table_config ( self ): \"\"\" Load table config \"\"\" # return self._load_yaml(self.table_folder / \"table_config.yaml\") return self . backend . get_table_config ( self . dataset_id , self . table_id ) def _get_table_obj ( self , mode ): \"\"\" Get table object from BigQuery \"\"\" return self . client [ f \"bigquery_ { mode } \" ] . get_table ( self . table_full_name [ mode ]) def _is_partitioned ( self , data_sample_path = None , source_format = None , csv_delimiter = None ): if data_sample_path is not None : table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) else : table_columns = self . _get_columns_metadata_from_api () return bool ( table_columns . get ( \"partition_columns\" , [])) def _load_schema_from_json ( self , columns = None , ): schema = [] for col in columns : # ref: https://cloud.google.com/python/docs/reference/bigquery/latest/google.cloud.bigquery.schema.SchemaField if col . get ( \"name\" ) is None : msg = \"Columns must have a name! Check your data files for columns without name\" raise BaseDosDadosException ( msg ) schema . append ( SchemaField ( name = col . get ( \"name\" ), field_type = col . get ( \"type\" ), description = col . get ( \"description\" , None ), ) ) return schema def _load_staging_schema_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" ): \"\"\" Generate schema from columns metadata in data sample \"\"\" if self . table_exists ( mode = \"staging\" ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) return self . _load_schema_from_json ( columns = table_columns . get ( \"columns\" )) def _load_schema_from_bq ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" table_columns = self . _get_columns_from_bq () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _load_schema_from_api ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" if self . table_exists ( mode = mode ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_metadata_from_api () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _get_columns_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" , mode = \"staging\" , ): # sourcery skip: low-code-quality \"\"\" Get the partition columns from the structure of data_sample_path. Args: data_sample_path (str, pathlib.PosixPath): Optional. Data sample path to auto complete columns names It supports Comma Delimited CSV, Apache Avro and Apache Parquet. source_format (str): Optional Data source format. Only 'csv', 'avro' and 'parquet' are supported. Defaults to 'csv'. \"\"\" partition_columns = [] if isinstance ( data_sample_path , ( str , Path , ), ): # Check if partitioned and get data sample and partition columns data_sample_path = Path ( data_sample_path ) if data_sample_path . is_dir (): data_sample_path = [ f for f in data_sample_path . glob ( \"**/*\" ) if f . is_file () and f . suffix == f \". { source_format } \" ][ 0 ] partition_columns = [ k . split ( \"=\" )[ 0 ] for k in data_sample_path . as_posix () . split ( \"/\" ) if \"=\" in k ] columns = Datatype ( source_format = source_format ) . header ( data_sample_path = data_sample_path , csv_delimiter = csv_delimiter ) return { \"columns\" : [{ \"name\" : col , \"type\" : \"STRING\" } for col in columns ], \"partition_columns\" : [ { \"name\" : col , \"type\" : \"STRING\" } for col in partition_columns ], } def _get_columns_metadata_from_api ( self , ): \"\"\" Get columns and partition columns from API. \"\"\" table_columns = self . table_config . get ( \"columns\" , {}) columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is False ] partition_columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is True ] return { \"columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in columns ], \"partition_columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in partition_columns ], } def _parser_blobs_to_partition_dict ( self ) -> dict : \"\"\" Extracts the partition information from the blobs. \"\"\" if not self . table_exists ( mode = \"staging\" ): return blobs = ( self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) . list_blobs ( prefix = f \"staging/ { self . dataset_id } / { self . table_id } /\" ) ) partitions_dict = {} # only needs the first bloob for blob in blobs : for folder in blob . name . split ( \"/\" ): if \"=\" in folder : key = folder . split ( \"=\" )[ 0 ] value = folder . split ( \"=\" ) try : partitions_dict [ key ] . append ( value ) except KeyError : partitions_dict [ key ] = [ value ] return partitions_dict def _get_columns_from_bq ( self , mode = \"staging\" ): if not self . table_exists ( mode = mode ): msg = f \"Table { self . dataset_id } . { self . table_id } does not exist in { mode } , please create first!\" raise logger . error ( msg ) else : schema = self . _get_table_obj ( mode = mode ) . schema partition_dict = self . _parser_blobs_to_partition_dict () if partition_dict : partition_columns = list ( partition_dict . keys ()) else : partition_columns = [] return { \"columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name not in partition_columns ], \"partition_columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name in partition_columns ], } def _get_cross_columns_from_bq_api ( self ): bq = self . _get_columns_from_bq ( mode = \"staging\" ) bq_columns = bq . get ( \"partition_columns\" ) + bq . get ( \"columns\" ) api = self . _get_columns_metadata_from_api () api_columns = api . get ( \"partition_columns\" ) + api . get ( \"columns\" ) if api_columns != []: for bq_col in bq_columns : for api_col in api_columns : if bq_col . get ( \"name\" ) == api_col . get ( \"name\" ): bq_col [ \"type\" ] = api_col . get ( \"type\" ) bq_col [ \"description\" ] = api_col . get ( \"description\" ) return bq_columns def _make_publish_sql ( self ): \"\"\"Create publish.sql with columns and bigquery_type\"\"\" # publish.sql header and instructions publish_txt = \"\"\" /* Query para publicar a tabela. Esse \u00e9 o lugar para: - modificar nomes, ordem e tipos de colunas - dar join com outras tabelas - criar colunas extras (e.g. logs, propor\u00e7\u00f5es, etc.) Qualquer coluna definida aqui deve tamb\u00e9m existir em `table_config.yaml`. # Al\u00e9m disso, sinta-se \u00e0 vontade para alterar alguns nomes obscuros # para algo um pouco mais expl\u00edcito. TIPOS: - Para modificar tipos de colunas, basta substituir STRING por outro tipo v\u00e1lido. - Exemplo: `SAFE_CAST(column_name AS NUMERIC) column_name` - Mais detalhes: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types */ \"\"\" # table_columns = self._get_columns_from_api(mode=\"staging\") columns = self . _get_cross_columns_from_bq_api () # remove triple quotes extra space publish_txt = inspect . cleandoc ( publish_txt ) publish_txt = textwrap . dedent ( publish_txt ) # add create table statement project_id_prod = self . client [ \"bigquery_prod\" ] . project publish_txt += f \" \\n\\n CREATE OR REPLACE VIEW { project_id_prod } . { self . dataset_id } . { self . table_id } AS \\n SELECT \\n \" # sort columns by is_partition, partitions_columns come first # add columns in publish.sql for col in columns : name = col . get ( \"name\" ) bigquery_type = ( \"STRING\" if col . get ( \"type\" ) is None else col . get ( \"type\" ) . upper () ) publish_txt += f \"SAFE_CAST( { name } AS { bigquery_type } ) { name } , \\n \" # remove last comma publish_txt = publish_txt [: - 2 ] + \" \\n \" # add from statement project_id_staging = self . client [ \"bigquery_staging\" ] . project publish_txt += ( f \"FROM { project_id_staging } . { self . dataset_id } _staging. { self . table_id } AS t\" ) return publish_txt def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) def _get_biglake_connection ( self , set_biglake_connection_permissions = True , location = None , mode = \"staging\" ): connection = Connection ( name = \"biglake\" , location = location , mode = \"staging\" ) if not connection . exists : try : logger . info ( \"Creating BigLake connection...\" ) connection . create () logger . success ( \"BigLake connection created!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc if set_biglake_connection_permissions : try : logger . info ( \"Setting permissions for BigLake service account...\" ) connection . set_biglake_permissions () logger . success ( \"Permissions set successfully!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc return connection def _get_table_description ( self , mode = \"staging\" ): \"\"\"Adds table description to BigQuery table. Args: table_obj (google.cloud.bigquery.table.Table): Table object. mode (str): Which dataset to check [prod|staging]. \"\"\" table_path = self . table_full_name [ \"prod\" ] if mode == \"staging\" : description = f \"staging table for ` { table_path } `\" else : try : description = self . table_config . get ( \"descriptionPt\" , \"\" ) except BaseException : logger . warning ( f \"table { self . table_id } does not have a description in the API.\" ) description = \"description not available in the API.\" return description def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , ) def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) table_config property readonly Load table config append ( self , filepath , partitions = None , if_exists = 'replace' , chunk_size = None , ** upload_args ) Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Parameters: Name Type Description Default filepath str or pathlib.PosixPath Where to find the file that you want to upload to create a table with required partitions str, pathlib.PosixPath, dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str 0ptional. What to do if data with same name exists in storage 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'replace' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None Source code in basedosdados/upload/table.py def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) create ( self , path = None , source_format = 'csv' , csv_delimiter = ',' , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = 'raise' , if_storage_data_exists = 'raise' , if_dataset_exists = 'pass' , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True ) Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at <dataset_id>_staging.<table_id> in BigQuery. Data can be found in Storage at <bucket_name>/staging/<dataset_id>/<table_id>/* and is used to build the table. The following data types are supported: Comma-Delimited CSV Apache Avro Apache Parquet Data can also be partitioned following the Hive partitioning scheme <key1>=<value1>/<key2>=<value2> ; for example, year=2012/country=BR . The partition is automatically detected by searching for partitions in the table_config.yaml file. Parameters: Name Type Description Default path str or pathlib.PosixPath The path to the file to be uploaded to create the table. None source_format str Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. 'csv' csv_delimiter str Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. ',' csv_skip_leading_rows(int) Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. required csv_allow_jagged_rows bool Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. False if_table_exists str Optional. Determines what to do if the table already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_storage_data_exists str Optional. Determines what to do if the data already exists on your bucket: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_dataset_exists str Optional. Determines what to do if the dataset already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the dataset 'pass' : Does nothing 'pass' dataset_is_public bool Optional. Controls if the prod dataset is public or not. By default, staging datasets like dataset_id_staging are not public. True location str Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None chunk_size int Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None biglake_table bool Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. False set_biglake_connection_permissions bool Optional. If set to True , attempts to grant the BigLake connection service account access to the table's data in GCS. True Source code in basedosdados/upload/table.py def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None delete ( self , mode = 'all' ) Deletes table in BigQuery. Parameters: Name Type Description Default mode str Table of which table to delete [prod|staging] 'all' Source code in basedosdados/upload/table.py def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) publish ( self , if_exists = 'raise' , custon_publish_sql = None , custom_schema = None ) Creates BigQuery table at production dataset. Table should be located at <dataset_id>.<table_id> . It creates a view that uses the query from <metadata_path>/<dataset_id>/<table_id>/publish.sql . Make sure that all columns from the query also exists at <metadata_path>/<dataset_id>/<table_id>/table_config.sql , including the partitions. Parameters: Name Type Description Default if_exists str Optional. What to do if table exists. 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' Todo: * Check if all required fields are filled Source code in basedosdados/upload/table.py def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) table_exists ( self , mode ) Check if table exists in BigQuery. Parameters: Name Type Description Default mode str Which dataset to check [prod|staging]. required Source code in basedosdados/upload/table.py def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) update ( self , mode = 'prod' , custom_schema = None ) Updates BigQuery schema and description. Parameters: Name Type Description Default mode str Optional. Table of which table to update [prod] 'prod' not_found_ok bool Optional. What to do if table is not found required Source code in basedosdados/upload/table.py def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , )","title":"Python"},{"location":"api_reference_python/#python","text":"Esta API \u00e9 composta por fun\u00e7\u00f5es com 2 tipos de funcionalidade: M\u00f3dulos para requisi\u00e7\u00e3o de dados : para aquele(as) que desejam somente consultar os dados e metadados do nosso projeto. Classes para gerenciamento de dados no Google Cloud: para aqueles(as) que desejam subir dados no nosso projeto (ou qualquer outro projeto no Google Cloud, seguindo a nossa metodologia e infraestrutura). Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas","title":"Python"},{"location":"api_reference_python/#modulos-requisicao-de-dados","text":"Functions to get metadata from BD's API","title":"M\u00f3dulos (Requisi\u00e7\u00e3o de dados)"},{"location":"api_reference_python/#basedosdados.download.metadata.check_input","text":"Checks if the number of inputs is valid Source code in basedosdados/download/metadata.py def check_input ( f ): \"\"\"Checks if the number of inputs is valid\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if sum ([ a is not None for a in args ]) > 1 : raise ValueError ( \"At most one of the inputs must be non null\" ) return f ( * args , ** kwargs ) return wrapper","title":"check_input()"},{"location":"api_reference_python/#basedosdados.download.metadata.get_columns","text":"Get a list of available columns, either by table_id , column_id or column_name Parameters: Name Type Description Default table_id(str) table slug in google big query (gbq). required column_id(str) column slug in google big query (gbq). required column_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_columns ( table_id : str = None , column_id : str = None , columns_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available columns, either by `table_id`, `column_id` or `column_name` Args: table_id(str): table slug in google big query (gbq). column_id(str): column slug in google big query (gbq). column_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" result = backend . get_columns ( table_id , column_id , columns_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"bigquery_type\" ] = item . pop ( \"bigqueryType\" , {}) . get ( \"name\" ) return result","title":"get_columns()"},{"location":"api_reference_python/#basedosdados.download.metadata.get_datasets","text":"Get a list of available datasets, either by dataset_id or dataset_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required dataset_name(str) dataset name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_datasets ( dataset_id : str = None , dataset_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available datasets, either by `dataset_id` or `dataset_name` Args: dataset_id(str): dataset slug in google big query (gbq). dataset_name(str): dataset name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets. \"\"\" result = backend . get_datasets ( dataset_id , dataset_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"organization\" ] = item . get ( \"organization\" , {}) . get ( \"name\" ) item [ \"tags\" ] = [ i . get ( \"name\" ) for i in item . get ( \"tags\" , {}) . get ( \"items\" )] item [ \"themes\" ] = [ i . get ( \"name\" ) for i in item . get ( \"themes\" , {}) . get ( \"items\" )] return result","title":"get_datasets()"},{"location":"api_reference_python/#basedosdados.download.metadata.get_tables","text":"Get a list of available tables, either by dataset_id , table_id or table_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required table_id(str) table slug in google big query (gbq). required table_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_tables ( dataset_id : str = None , table_id : str = None , table_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available tables, either by `dataset_id`, `table_id` or `table_name` Args: dataset_id(str): dataset slug in google big query (gbq). table_id(str): table slug in google big query (gbq). table_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" return backend . get_tables ( dataset_id , table_id , table_name , page , page_size )","title":"get_tables()"},{"location":"api_reference_python/#basedosdados.download.metadata.inject_backend","text":"Inject backend instance if doesn't exists Source code in basedosdados/download/metadata.py def inject_backend ( f ): \"\"\"Inject backend instance if doesn't exists\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if \"backend\" not in kwargs : kwargs [ \"backend\" ] = Backend () return f ( * args , ** kwargs ) return wrapper","title":"inject_backend()"},{"location":"api_reference_python/#basedosdados.download.metadata.search","text":"Search for datasets, querying all available metadata for the term q Parameters: Name Type Description Default q(str) search term. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets and metadata. Source code in basedosdados/download/metadata.py @check_input @inject_backend def search ( q : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Search for datasets, querying all available metadata for the term `q` Args: q(str): search term. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets and metadata. \"\"\" items = [] for item in backend . search ( q , page , page_size ) . get ( \"results\" , []): items . append ( { \"slug\" : item . get ( \"slug\" ), \"name\" : item . get ( \"name\" ), \"description\" : item . get ( \"description\" ), \"n_tables\" : item . get ( \"n_tables\" ), \"n_raw_data_sources\" : item . get ( \"n_raw_data_sources\" ), \"n_information_requests\" : item . get ( \"n_information_requests\" ), \"organization\" : { \"slug\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"slug\" ), \"name\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"name\" ), }, } ) return items Functions for managing downloads","title":"search()"},{"location":"api_reference_python/#basedosdados.download.download.download","text":"Download table or query result from basedosdados BigQuery (or other). Using a query : download('select * from basedosdados.br_suporte.diretorio_municipios limit 10') Using dataset_id & table_id : download(dataset_id='br_suporte', table_id='diretorio_municipios') You can also add arguments to modify save parameters: download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|') Parameters: Name Type Description Default savepath str, pathlib.PosixPath savepath must be a file path. Only supports .csv . required query str Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. None dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. None table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. None billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional Number of rows. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False compression str Optional. Compression type. Only GZIP is available for now. 'GZIP' Exceptions: Type Description Exception If either table_id, dataset_id or query are empty. Source code in basedosdados/download/download.py def download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , compression = \"GZIP\" , ): \"\"\"Download table or query result from basedosdados BigQuery (or other). * Using a **query**: `download('select * from `basedosdados.br_suporte.diretorio_municipios` limit 10')` * Using **dataset_id & table_id**: `download(dataset_id='br_suporte', table_id='diretorio_municipios')` You can also add arguments to modify save parameters: `download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|')` Args: savepath (str, pathlib.PosixPath): savepath must be a file path. Only supports `.csv`. query (str): Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional Number of rows. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. compression (str): Optional. Compression type. Only `GZIP` is available for now. Raises: Exception: If either table_id, dataset_id or query are empty. \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( query is None ) and (( table_id is None ) or ( dataset_id is None )): raise BaseDosDadosException ( \"Either table_id, dataset_id or query should be filled.\" ) client = _google_client ( billing_project_id , from_file , reauth ) # makes sure that savepath is a filepath and not a folder savepath = _sets_savepath ( savepath ) # if query is not defined (so it won't be overwritten) and if # table is a view or external or if limit is specified, # convert it to a query. if not query and ( not _is_table ( client , dataset_id , table_id , query_project_id ) or limit ): query = f \"\"\" SELECT * FROM { query_project_id } . { dataset_id } . { table_id } \"\"\" if limit is not None : query += f \" limit { limit } \" if query : # sql queries produces anonymous tables, whose names # can be found within `job._properties` job = client [ \"bigquery\" ] . query ( query ) # views may take longer: wait for job to finish. _wait_for ( job ) dest_table = job . _properties [ \"configuration\" ][ \"query\" ][ \"destinationTable\" ] project_id = dest_table [ \"projectId\" ] dataset_id = dest_table [ \"datasetId\" ] table_id = dest_table [ \"tableId\" ] _direct_download ( client , dataset_id , table_id , savepath , project_id , compression )","title":"download()"},{"location":"api_reference_python/#basedosdados.download.download.read_sql","text":"Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Parameters: Name Type Description Default query sql Valid SQL Standard Query to basedosdados required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Args: query (sql): Valid SQL Standard Query to basedosdados billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) try : # Set a two hours timeout bigquery_storage_v1 . client . BigQueryReadClient . read_rows = partialmethod ( bigquery_storage_v1 . client . BigQueryReadClient . read_rows , timeout = 3600 * 2 , ) return read_gbq ( query , project_id = config . billing_project_id , use_bqstorage_api = use_bqstorage_api , credentials = _credentials ( from_file = config . from_file , reauth = reauth ), ) except GenericGBQException as e : if \"Reason: 403\" in str ( e ): raise BaseDosDadosAccessDeniedException from e if re . match ( \"Reason: 400 POST .* [Pp]roject[ ]*I[Dd]\" , str ( e )): raise BaseDosDadosInvalidProjectIDException from e raise except PyDataCredentialsError as e : raise BaseDosDadosAuthorizationException from e except ( OSError , ValueError ) as e : no_billing_id = \"Could not determine project ID\" in str ( e ) no_billing_id |= \"reading from stdin while output is captured\" in str ( e ) if no_billing_id : raise BaseDosDadosNoBillingProjectIDException from e raise","title":"read_sql()"},{"location":"api_reference_python/#basedosdados.download.download.read_table","text":"Load data from BigQuery using dataset_id and table_id. Parameters: Name Type Description Default dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. required table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional. Number of rows to read from table. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using dataset_id and table_id. Args: dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional. Number of rows to read from table. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( dataset_id is not None ) and ( table_id is not None ): query = f \"\"\" SELECT * FROM ` { query_project_id } . { dataset_id } . { table_id } `\"\"\" if limit is not None : query += f \" LIMIT { limit } \" else : raise BaseDosDadosException ( \"Both table_id and dataset_id should be filled.\" ) return read_sql ( query , billing_project_id = billing_project_id , from_file = from_file , reauth = reauth , use_bqstorage_api = use_bqstorage_api , )","title":"read_table()"},{"location":"api_reference_python/#classes-gerenciamento-de-dados","text":"Class for managing the files in cloud storage.","title":"Classes (Gerenciamento de dados)"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage","text":"Manage files on Google Cloud Storage. Source code in basedosdados/upload/storage.py class Storage ( Base ): \"\"\" Manage files on Google Cloud Storage. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . bucket = self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_id = table_id . replace ( \"-\" , \"_\" ) @staticmethod def _resolve_partitions ( partitions ): if isinstance ( partitions , dict ): return \"/\" . join ( f \" { k } = { v } \" for k , v in partitions . items ()) + \"/\" if isinstance ( partitions , str ): if partitions . endswith ( \"/\" ): partitions = partitions [: - 1 ] # If there is no partition if len ( partitions ) == 0 : return \"\" # It should fail if there is folder which is not a partition try : # check if it fits rule { b . split ( \"=\" )[ 0 ]: b . split ( \"=\" )[ 1 ] for b in partitions . split ( \"/\" )} except IndexError as e : raise Exception ( f \"The path { partitions } is not a valid partition\" ) from e return partitions + \"/\" raise Exception ( f \"Partitions format or type not accepted: { partitions } \" ) def _build_blob_name ( self , filename , mode , partitions = None ): \"\"\" Builds the blob name. \"\"\" # table folder blob_name = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # add partition folder if partitions is not None : blob_name += self . _resolve_partitions ( partitions ) # add file name blob_name += filename return blob_name def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , )","title":"Storage"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.copy_table","text":"Copies table from a source bucket to your bucket, sends request in batches. Parameters: Name Type Description Default source_bucket_name str The bucket name from which to copy data. You can change it to copy from other external bucket. 'basedosdados' destination_bucket_name str Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) None mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' new_table_id str Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. None Source code in basedosdados/upload/storage.py def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , )","title":"copy_table()"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.delete_file","text":"Deletes file from path <bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename> . Parameters: Name Type Description Default filename str Name of the file to be deleted required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] required partitions str, pathlib.PosixPath, or dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None not_found_ok bool Optional. What to do if file not found False Source code in basedosdados/upload/storage.py def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , )","title":"delete_file()"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.delete_table","text":"Deletes a table from storage, sends request in batches. Parameters: Name Type Description Default mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' bucket_name str The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) None not_found_ok bool Optional. What to do if table not found False Source code in basedosdados/upload/storage.py def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , )","title":"delete_table()"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.download","text":"Download files from Google Storage from path mode / dataset_id / table_id / partitions / filename and replicate folder hierarchy on save, There are 5 modes: * raw : should contain raw files from datasource * staging : should contain pre-treated files ready to upload to BiqQuery * header : should contain the header of the tables * auxiliary_files : should contain auxiliary files from eache table * architecture : should contain the architecture sheet of the tables You can also use the partitions argument to choose files from a partition Parameters: Name Type Description Default filename str Optional Specify which file to download. If \" \" , downloads all files within the bucket folder. Defaults to \" \". '*' savepath str Where you want to save the data on your computer. Must be a path to a directory. '.' partitions str, dict Optional If downloading a single file, use this to specify the partition path from which to download. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None mode str Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] 'staging' if_not_exists str Optional. What to do if data not found. 'raise' : Raises FileNotFoundError. 'pass' : Do nothing and exit the function 'raise' Exceptions: Type Description FileNotFoundError If the given path <mode>/<dataset_id>/<table_id>/<partitions>/<filename> could not be found or there are no files to download. Source code in basedosdados/upload/storage.py def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, )","title":"download()"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.init","text":"Initializes bucket and folders. Folder should be: raw : that contains really raw data staging : preprocessed data ready to upload to BigQuery Parameters: Name Type Description Default replace bool Optional. Whether to replace if bucket already exists False very_sure bool Optional. Are you aware that everything is going to be erased if you replace the bucket? False Exceptions: Type Description Warning very_sure argument is still False. Source code in basedosdados/upload/storage.py def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" )","title":"init()"},{"location":"api_reference_python/#basedosdados.upload.storage.Storage.upload","text":"Upload to storage at <bucket_name>/<mode>/<dataset_id>/<table_id> . You can: Add a single file setting path = <file_path> . Add a folder with multiple files setting path = <folder_path> . The folder should just contain the files and no folders. Add partitioned files setting path = <folder_path> . This folder must follow the hive partitioning scheme i.e. <table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv (ex: mytable/country=brasil/year=2020/mypart.csv ). Remember all files must follow a single schema. Otherwise, things might fail in the future. There are 6 modes: raw : should contain raw files from datasource staging : should contain pre-treated files ready to upload to BiqQuery header : should contain the header of the tables auxiliary_files : should contain auxiliary files from eache table architecture : should contain the architecture sheet of the tables all : if no treatment is needed, use all . Parameters: Name Type Description Default path str or pathlib.PosixPath Where to find the file or folder that you want to upload to storage required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] 'all' partitions str, pathlib.PosixPath, or dict Optional. If adding a single file , use this to add it to a specific partition. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str Optional. What to do if data exists 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None upload_args Extra arguments accepted by google.cloud.storage.blob.Blob.upload_from_file {} Source code in basedosdados/upload/storage.py def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) Module for manage dataset to the server.","title":"upload()"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset","text":"Manage datasets in BigQuery. Source code in basedosdados/upload/dataset.py class Dataset ( Base ): \"\"\" Manage datasets in BigQuery. \"\"\" def __init__ ( self , dataset_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) @property @lru_cache def dataset_config ( self ): \"\"\" Dataset config file. \"\"\" return self . backend . get_dataset_config ( self . dataset_id ) def _loop_modes ( self , mode = \"all\" ): \"\"\" Loop modes. \"\"\" def dataset_tag ( m ): return f \"_ { m } \" if m == \"staging\" else \"\" mode = [ \"prod\" , \"staging\" ] if mode == \"all\" else [ mode ] return ( { \"client\" : self . client [ f \"bigquery_ { m } \" ], \"id\" : f \" { self . client [ f 'bigquery_ { m } ' ] . project } . { self . dataset_id }{ dataset_tag ( m ) } \" , \"mode\" : m , } for m in mode ) def _setup_dataset_object ( self , dataset_id , location = None , mode = \"staging\" ): \"\"\" Setup dataset object. \"\"\" dataset = bigquery . Dataset ( dataset_id ) if mode == \"staging\" : dataset_path = dataset_id . replace ( \"_staging\" , \"\" ) description = f \"staging dataset for ` { dataset_path } `\" labels = { \"staging\" : True } else : try : description = self . dataset_config . get ( \"descriptionPt\" , \"\" ) labels = { tag . get ( \"namePt\" ): True for tag in self . dataset_config . get ( \"tags\" ) } except BaseException : logger . warning ( f \"dataset { dataset_id } does not have a description in the API.\" ) description = \"description not available in the API.\" labels = {} dataset . description = description dataset . labels = labels dataset . location = location return dataset def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , )","title":"Dataset"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.dataset_config","text":"Dataset config file.","title":"dataset_config"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.create","text":"Creates BigQuery datasets given dataset_id . It can create two datasets: <dataset_id> (mode = 'prod') <dataset_id>_staging (mode = 'staging') If mode is all, it creates both. Parameters: Name Type Description Default mode str Optional. Which dataset to create [prod|staging|all]. 'all' if_exists str Optional. What to do if dataset exists raise : Raises Conflict exception replace : Drop all tables and replace dataset update : Update dataset description pass : Do nothing 'raise' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Exceptions: Type Description Warning Dataset already exists and if_exists is set to raise Source code in basedosdados/upload/dataset.py def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e","title":"create()"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.delete","text":"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Parameters: Name Type Description Default mode str Optional. Which dataset to delete [prod|staging|all] 'all' Source code in basedosdados/upload/dataset.py def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , )","title":"delete()"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.exists","text":"Check if dataset exists. Source code in basedosdados/upload/dataset.py def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref )","title":"exists()"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.publicize","text":"Changes IAM configuration to turn BigQuery dataset public. Parameters: Name Type Description Default mode bool Which dataset to create [prod|staging|all]. 'all' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True Source code in basedosdados/upload/dataset.py def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , )","title":"publicize()"},{"location":"api_reference_python/#basedosdados.upload.dataset.Dataset.update","text":"Update dataset description. Toogle mode to choose which dataset to update. Parameters: Name Type Description Default mode str Optional. Which dataset to update [prod|staging|all] 'all' location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Source code in basedosdados/upload/dataset.py def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) Class for manage tables in Storage and Big Query","title":"update()"},{"location":"api_reference_python/#basedosdados.upload.table.Table","text":"Manage tables in Google Cloud Storage and BigQuery. Source code in basedosdados/upload/table.py class Table ( Base ): \"\"\" Manage tables in Google Cloud Storage and BigQuery. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . table_id = table_id . replace ( \"-\" , \"_\" ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_full_name = dict ( prod = f \" { self . client [ 'bigquery_prod' ] . project } . { self . dataset_id } . { self . table_id } \" , staging = f \" { self . client [ 'bigquery_staging' ] . project } . { self . dataset_id } _staging. { self . table_id } \" , ) self . table_full_name . update ( dict ( all = deepcopy ( self . table_full_name ))) @property @lru_cache ( 256 ) def table_config ( self ): \"\"\" Load table config \"\"\" # return self._load_yaml(self.table_folder / \"table_config.yaml\") return self . backend . get_table_config ( self . dataset_id , self . table_id ) def _get_table_obj ( self , mode ): \"\"\" Get table object from BigQuery \"\"\" return self . client [ f \"bigquery_ { mode } \" ] . get_table ( self . table_full_name [ mode ]) def _is_partitioned ( self , data_sample_path = None , source_format = None , csv_delimiter = None ): if data_sample_path is not None : table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) else : table_columns = self . _get_columns_metadata_from_api () return bool ( table_columns . get ( \"partition_columns\" , [])) def _load_schema_from_json ( self , columns = None , ): schema = [] for col in columns : # ref: https://cloud.google.com/python/docs/reference/bigquery/latest/google.cloud.bigquery.schema.SchemaField if col . get ( \"name\" ) is None : msg = \"Columns must have a name! Check your data files for columns without name\" raise BaseDosDadosException ( msg ) schema . append ( SchemaField ( name = col . get ( \"name\" ), field_type = col . get ( \"type\" ), description = col . get ( \"description\" , None ), ) ) return schema def _load_staging_schema_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" ): \"\"\" Generate schema from columns metadata in data sample \"\"\" if self . table_exists ( mode = \"staging\" ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) return self . _load_schema_from_json ( columns = table_columns . get ( \"columns\" )) def _load_schema_from_bq ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" table_columns = self . _get_columns_from_bq () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _load_schema_from_api ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" if self . table_exists ( mode = mode ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_metadata_from_api () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _get_columns_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" , mode = \"staging\" , ): # sourcery skip: low-code-quality \"\"\" Get the partition columns from the structure of data_sample_path. Args: data_sample_path (str, pathlib.PosixPath): Optional. Data sample path to auto complete columns names It supports Comma Delimited CSV, Apache Avro and Apache Parquet. source_format (str): Optional Data source format. Only 'csv', 'avro' and 'parquet' are supported. Defaults to 'csv'. \"\"\" partition_columns = [] if isinstance ( data_sample_path , ( str , Path , ), ): # Check if partitioned and get data sample and partition columns data_sample_path = Path ( data_sample_path ) if data_sample_path . is_dir (): data_sample_path = [ f for f in data_sample_path . glob ( \"**/*\" ) if f . is_file () and f . suffix == f \". { source_format } \" ][ 0 ] partition_columns = [ k . split ( \"=\" )[ 0 ] for k in data_sample_path . as_posix () . split ( \"/\" ) if \"=\" in k ] columns = Datatype ( source_format = source_format ) . header ( data_sample_path = data_sample_path , csv_delimiter = csv_delimiter ) return { \"columns\" : [{ \"name\" : col , \"type\" : \"STRING\" } for col in columns ], \"partition_columns\" : [ { \"name\" : col , \"type\" : \"STRING\" } for col in partition_columns ], } def _get_columns_metadata_from_api ( self , ): \"\"\" Get columns and partition columns from API. \"\"\" table_columns = self . table_config . get ( \"columns\" , {}) columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is False ] partition_columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is True ] return { \"columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in columns ], \"partition_columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in partition_columns ], } def _parser_blobs_to_partition_dict ( self ) -> dict : \"\"\" Extracts the partition information from the blobs. \"\"\" if not self . table_exists ( mode = \"staging\" ): return blobs = ( self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) . list_blobs ( prefix = f \"staging/ { self . dataset_id } / { self . table_id } /\" ) ) partitions_dict = {} # only needs the first bloob for blob in blobs : for folder in blob . name . split ( \"/\" ): if \"=\" in folder : key = folder . split ( \"=\" )[ 0 ] value = folder . split ( \"=\" ) try : partitions_dict [ key ] . append ( value ) except KeyError : partitions_dict [ key ] = [ value ] return partitions_dict def _get_columns_from_bq ( self , mode = \"staging\" ): if not self . table_exists ( mode = mode ): msg = f \"Table { self . dataset_id } . { self . table_id } does not exist in { mode } , please create first!\" raise logger . error ( msg ) else : schema = self . _get_table_obj ( mode = mode ) . schema partition_dict = self . _parser_blobs_to_partition_dict () if partition_dict : partition_columns = list ( partition_dict . keys ()) else : partition_columns = [] return { \"columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name not in partition_columns ], \"partition_columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name in partition_columns ], } def _get_cross_columns_from_bq_api ( self ): bq = self . _get_columns_from_bq ( mode = \"staging\" ) bq_columns = bq . get ( \"partition_columns\" ) + bq . get ( \"columns\" ) api = self . _get_columns_metadata_from_api () api_columns = api . get ( \"partition_columns\" ) + api . get ( \"columns\" ) if api_columns != []: for bq_col in bq_columns : for api_col in api_columns : if bq_col . get ( \"name\" ) == api_col . get ( \"name\" ): bq_col [ \"type\" ] = api_col . get ( \"type\" ) bq_col [ \"description\" ] = api_col . get ( \"description\" ) return bq_columns def _make_publish_sql ( self ): \"\"\"Create publish.sql with columns and bigquery_type\"\"\" # publish.sql header and instructions publish_txt = \"\"\" /* Query para publicar a tabela. Esse \u00e9 o lugar para: - modificar nomes, ordem e tipos de colunas - dar join com outras tabelas - criar colunas extras (e.g. logs, propor\u00e7\u00f5es, etc.) Qualquer coluna definida aqui deve tamb\u00e9m existir em `table_config.yaml`. # Al\u00e9m disso, sinta-se \u00e0 vontade para alterar alguns nomes obscuros # para algo um pouco mais expl\u00edcito. TIPOS: - Para modificar tipos de colunas, basta substituir STRING por outro tipo v\u00e1lido. - Exemplo: `SAFE_CAST(column_name AS NUMERIC) column_name` - Mais detalhes: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types */ \"\"\" # table_columns = self._get_columns_from_api(mode=\"staging\") columns = self . _get_cross_columns_from_bq_api () # remove triple quotes extra space publish_txt = inspect . cleandoc ( publish_txt ) publish_txt = textwrap . dedent ( publish_txt ) # add create table statement project_id_prod = self . client [ \"bigquery_prod\" ] . project publish_txt += f \" \\n\\n CREATE OR REPLACE VIEW { project_id_prod } . { self . dataset_id } . { self . table_id } AS \\n SELECT \\n \" # sort columns by is_partition, partitions_columns come first # add columns in publish.sql for col in columns : name = col . get ( \"name\" ) bigquery_type = ( \"STRING\" if col . get ( \"type\" ) is None else col . get ( \"type\" ) . upper () ) publish_txt += f \"SAFE_CAST( { name } AS { bigquery_type } ) { name } , \\n \" # remove last comma publish_txt = publish_txt [: - 2 ] + \" \\n \" # add from statement project_id_staging = self . client [ \"bigquery_staging\" ] . project publish_txt += ( f \"FROM { project_id_staging } . { self . dataset_id } _staging. { self . table_id } AS t\" ) return publish_txt def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) def _get_biglake_connection ( self , set_biglake_connection_permissions = True , location = None , mode = \"staging\" ): connection = Connection ( name = \"biglake\" , location = location , mode = \"staging\" ) if not connection . exists : try : logger . info ( \"Creating BigLake connection...\" ) connection . create () logger . success ( \"BigLake connection created!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc if set_biglake_connection_permissions : try : logger . info ( \"Setting permissions for BigLake service account...\" ) connection . set_biglake_permissions () logger . success ( \"Permissions set successfully!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc return connection def _get_table_description ( self , mode = \"staging\" ): \"\"\"Adds table description to BigQuery table. Args: table_obj (google.cloud.bigquery.table.Table): Table object. mode (str): Which dataset to check [prod|staging]. \"\"\" table_path = self . table_full_name [ \"prod\" ] if mode == \"staging\" : description = f \"staging table for ` { table_path } `\" else : try : description = self . table_config . get ( \"descriptionPt\" , \"\" ) except BaseException : logger . warning ( f \"table { self . table_id } does not have a description in the API.\" ) description = \"description not available in the API.\" return description def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , ) def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , )","title":"Table"},{"location":"api_reference_python/#basedosdados.upload.table.Table.table_config","text":"Load table config","title":"table_config"},{"location":"api_reference_python/#basedosdados.upload.table.Table.append","text":"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Parameters: Name Type Description Default filepath str or pathlib.PosixPath Where to find the file that you want to upload to create a table with required partitions str, pathlib.PosixPath, dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str 0ptional. What to do if data with same name exists in storage 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'replace' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None Source code in basedosdados/upload/table.py def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , )","title":"append()"},{"location":"api_reference_python/#basedosdados.upload.table.Table.create","text":"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at <dataset_id>_staging.<table_id> in BigQuery. Data can be found in Storage at <bucket_name>/staging/<dataset_id>/<table_id>/* and is used to build the table. The following data types are supported: Comma-Delimited CSV Apache Avro Apache Parquet Data can also be partitioned following the Hive partitioning scheme <key1>=<value1>/<key2>=<value2> ; for example, year=2012/country=BR . The partition is automatically detected by searching for partitions in the table_config.yaml file. Parameters: Name Type Description Default path str or pathlib.PosixPath The path to the file to be uploaded to create the table. None source_format str Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. 'csv' csv_delimiter str Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. ',' csv_skip_leading_rows(int) Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. required csv_allow_jagged_rows bool Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. False if_table_exists str Optional. Determines what to do if the table already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_storage_data_exists str Optional. Determines what to do if the data already exists on your bucket: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_dataset_exists str Optional. Determines what to do if the dataset already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the dataset 'pass' : Does nothing 'pass' dataset_is_public bool Optional. Controls if the prod dataset is public or not. By default, staging datasets like dataset_id_staging are not public. True location str Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None chunk_size int Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None biglake_table bool Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. False set_biglake_connection_permissions bool Optional. If set to True , attempts to grant the BigLake connection service account access to the table's data in GCS. True Source code in basedosdados/upload/table.py def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None","title":"create()"},{"location":"api_reference_python/#basedosdados.upload.table.Table.delete","text":"Deletes table in BigQuery. Parameters: Name Type Description Default mode str Table of which table to delete [prod|staging] 'all' Source code in basedosdados/upload/table.py def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , )","title":"delete()"},{"location":"api_reference_python/#basedosdados.upload.table.Table.publish","text":"Creates BigQuery table at production dataset. Table should be located at <dataset_id>.<table_id> . It creates a view that uses the query from <metadata_path>/<dataset_id>/<table_id>/publish.sql . Make sure that all columns from the query also exists at <metadata_path>/<dataset_id>/<table_id>/table_config.sql , including the partitions. Parameters: Name Type Description Default if_exists str Optional. What to do if table exists. 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' Todo: * Check if all required fields are filled Source code in basedosdados/upload/table.py def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , )","title":"publish()"},{"location":"api_reference_python/#basedosdados.upload.table.Table.table_exists","text":"Check if table exists in BigQuery. Parameters: Name Type Description Default mode str Which dataset to check [prod|staging]. required Source code in basedosdados/upload/table.py def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref )","title":"table_exists()"},{"location":"api_reference_python/#basedosdados.upload.table.Table.update","text":"Updates BigQuery schema and description. Parameters: Name Type Description Default mode str Optional. Table of which table to update [prod] 'prod' not_found_ok bool Optional. What to do if table is not found required Source code in basedosdados/upload/table.py def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , )","title":"update()"},{"location":"api_reference_r/","text":"R Esta API \u00e9 composta somente de m\u00f3dulos para requisi\u00e7\u00e3o de dados , ou seja, download e/ou carregamento de dados do projeto no seu ambiente de an\u00e1lise). Para fazer gerenciamento de dados no Google Cloud, busque as fun\u00e7\u00f5es na API de linha de comando ou em Python . A documenta\u00e7\u00e3o completa encontra-se na p\u00e1gina do CRAN do projeto, e segue baixo. Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas This browser does not support PDFs. Please download the PDF to view it: Download PDF . Ih rapaz, deu erro! E agora? Os principais erros encontrados do pacote da Base dos Dados no Rstudio s\u00e3o derivados de dois fatores: * Autentica\u00e7\u00e3o * Vers\u00e3o do pacote `dbplyr` Portanto, se algum erro aparecer para voc\u00ea, por favor, tente primeiro checar se ele est\u00e1 relacionado a esses dois fatores. Autentica\u00e7\u00e3o A maioria dos erros do nosso pacote est\u00e3o relacionados a problemas de autentica\u00e7\u00e3o. O pacote basedosdados requer que o usu\u00e1rio forne\u00e7a todas as autentica\u00e7\u00f5es solicitadas pela fun\u00e7\u00e3o basedosdados::set_billing_id , inclusive aquelas que aparecem como optativas. Por isso, \u00e9 necess\u00e1rio estar atento se voc\u00ea marcou todas as caixinhas de sele\u00e7\u00e3o quando o Rstudio disponibiliza essa tela no navegador: Note que \u00e9 preciso marcar inclusive as duas \u00faltimas \"caixinhas\", que aparecem como opcionais . Caso voc\u00ea tenha esquecido de marc\u00e1-las, todas as outras fun\u00e7\u00f5es do pacote n\u00e3o ir\u00e3o funcionar posteriormente. Caso voc\u00ea j\u00e1 tenha autenticado com autoriza\u00e7\u00e3o incompleta, \u00e9 preciso repetir o processo de autentica\u00e7\u00e3o. Voc\u00ea pode fazer isso rodando gargle::gargle_oauth_sitrep() . Voc\u00ea dever\u00e1 checar a pasta em que est\u00e3o salvas as autentica\u00e7\u00f5es do seu R, entrar nesta pasta e deletar aquela referente ao Google Cloud/Bigquery. Feito isso, ao rodar basedosdados::set_billing_id voc\u00ea poder\u00e1 autenticar novamente. Veja como \u00e9 simples: Realizados todos esses procedimentos, \u00e9 bem prov\u00e1vel que os erros anteriores n\u00e3o ocorram mais. Vers\u00e3o do pacote dbplyr Outro erro comum est\u00e1 relacionado ao uso da fun\u00e7\u00e3o basedosdados::bdplyr . Nosso pacote em R foi constru\u00eddo utilizando outros pacotes dispon\u00edveis na comunidade. Isso significa que atualiza\u00e7\u00f5es destes pacotes podem alterar o funcionamento destes e gerar efeitos em cascata a outros pacotes desenvolvidos em cima deles. Neste contexto, o nosso pacote funciona apenas com a vers\u00e3o 2.1.1 do pacote dbplyr , e n\u00e3o funciona com vers\u00f5es posteriores. Voc\u00ea pode checar a sua vers\u00e3o do dbplyr rodando utils::packageVersion(\"dbplyr\") no seu R. Caso ela seja superior \u00e0 vers\u00e3o 2.1.1, voc\u00ea precisa dar um downgrade para a vers\u00e3o correta. Para isso, voc\u00ea pode rodar devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") . Outros erros Caso os erros persistam, voc\u00ea pode abrir uma issue no nosso Github clicando aqui . Voc\u00ea tamb\u00e9m visitar as issues que j\u00e1 foram resolvidas e est\u00e3o atribu\u00eddas com o a etiqueta R em nosso Github aqui .","title":"R"},{"location":"api_reference_r/#r","text":"Esta API \u00e9 composta somente de m\u00f3dulos para requisi\u00e7\u00e3o de dados , ou seja, download e/ou carregamento de dados do projeto no seu ambiente de an\u00e1lise). Para fazer gerenciamento de dados no Google Cloud, busque as fun\u00e7\u00f5es na API de linha de comando ou em Python . A documenta\u00e7\u00e3o completa encontra-se na p\u00e1gina do CRAN do projeto, e segue baixo. Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"R"},{"location":"api_reference_r/#ih-rapaz-deu-erro-e-agora","text":"Os principais erros encontrados do pacote da Base dos Dados no Rstudio s\u00e3o derivados de dois fatores: * Autentica\u00e7\u00e3o * Vers\u00e3o do pacote `dbplyr` Portanto, se algum erro aparecer para voc\u00ea, por favor, tente primeiro checar se ele est\u00e1 relacionado a esses dois fatores.","title":"Ih rapaz, deu erro! E agora?"},{"location":"api_reference_r/#autenticacao","text":"A maioria dos erros do nosso pacote est\u00e3o relacionados a problemas de autentica\u00e7\u00e3o. O pacote basedosdados requer que o usu\u00e1rio forne\u00e7a todas as autentica\u00e7\u00f5es solicitadas pela fun\u00e7\u00e3o basedosdados::set_billing_id , inclusive aquelas que aparecem como optativas. Por isso, \u00e9 necess\u00e1rio estar atento se voc\u00ea marcou todas as caixinhas de sele\u00e7\u00e3o quando o Rstudio disponibiliza essa tela no navegador: Note que \u00e9 preciso marcar inclusive as duas \u00faltimas \"caixinhas\", que aparecem como opcionais . Caso voc\u00ea tenha esquecido de marc\u00e1-las, todas as outras fun\u00e7\u00f5es do pacote n\u00e3o ir\u00e3o funcionar posteriormente. Caso voc\u00ea j\u00e1 tenha autenticado com autoriza\u00e7\u00e3o incompleta, \u00e9 preciso repetir o processo de autentica\u00e7\u00e3o. Voc\u00ea pode fazer isso rodando gargle::gargle_oauth_sitrep() . Voc\u00ea dever\u00e1 checar a pasta em que est\u00e3o salvas as autentica\u00e7\u00f5es do seu R, entrar nesta pasta e deletar aquela referente ao Google Cloud/Bigquery. Feito isso, ao rodar basedosdados::set_billing_id voc\u00ea poder\u00e1 autenticar novamente. Veja como \u00e9 simples: Realizados todos esses procedimentos, \u00e9 bem prov\u00e1vel que os erros anteriores n\u00e3o ocorram mais.","title":"Autentica\u00e7\u00e3o"},{"location":"api_reference_r/#versao-do-pacote-dbplyr","text":"Outro erro comum est\u00e1 relacionado ao uso da fun\u00e7\u00e3o basedosdados::bdplyr . Nosso pacote em R foi constru\u00eddo utilizando outros pacotes dispon\u00edveis na comunidade. Isso significa que atualiza\u00e7\u00f5es destes pacotes podem alterar o funcionamento destes e gerar efeitos em cascata a outros pacotes desenvolvidos em cima deles. Neste contexto, o nosso pacote funciona apenas com a vers\u00e3o 2.1.1 do pacote dbplyr , e n\u00e3o funciona com vers\u00f5es posteriores. Voc\u00ea pode checar a sua vers\u00e3o do dbplyr rodando utils::packageVersion(\"dbplyr\") no seu R. Caso ela seja superior \u00e0 vers\u00e3o 2.1.1, voc\u00ea precisa dar um downgrade para a vers\u00e3o correta. Para isso, voc\u00ea pode rodar devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") .","title":"Vers\u00e3o do pacote dbplyr"},{"location":"api_reference_r/#outros-erros","text":"Caso os erros persistam, voc\u00ea pode abrir uma issue no nosso Github clicando aqui . Voc\u00ea tamb\u00e9m visitar as issues que j\u00e1 foram resolvidas e est\u00e3o atribu\u00eddas com o a etiqueta R em nosso Github aqui .","title":"Outros erros"},{"location":"api_reference_stata/","text":"Stata Esta API \u00e9 composta por m\u00f3dulos para requisi\u00e7\u00e3o de dados : para aquele(as) que desejam somente consultar os dados e metadados do nosso projeto (ou qualquer outro projeto no Google Cloud). Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas M\u00f3dulos (Requisi\u00e7\u00e3o de dados) Se \u00e9 a sua primeira vez utilizando o pacote, digite db basedosdados e confirme novamente se as etapas acima foram conclu\u00eddas com sucesso. O pacote cont\u00e9m 7 comandos, conforme suas funcionalidades descritas abaixo: Comando Descri\u00e7\u00e3o bd_download baixa dados da Base dos Dados (BD). bd_read_sql baixa tabelas da BD usando consultas espec\u00edficas. bd_read_table baixa tabelas da BD usando dataset_id e table_id . bd_list_datasets lista o dataset_id dos conjuntos de dados dispon\u00edveis em query_project_id . bd_list_dataset_tables lista table_id para tabelas dispon\u00edveis no dataset_id especificado. bd_get_table_description mostra a descri\u00e7\u00e3o completa da tabela BD. bd_get_table_columns mostra os nomes, tipos e descri\u00e7\u00f5es das colunas na tabela especificada. Cada comando tem um help file de apoio, bastando abrir o help e seguir as instru\u00e7\u00f5es: help [comando]","title":"Stata"},{"location":"api_reference_stata/#stata","text":"Esta API \u00e9 composta por m\u00f3dulos para requisi\u00e7\u00e3o de dados : para aquele(as) que desejam somente consultar os dados e metadados do nosso projeto (ou qualquer outro projeto no Google Cloud). Toda documenta\u00e7\u00e3o do c\u00f3digo abaixo est\u00e1 em ingl\u00eas","title":"Stata"},{"location":"api_reference_stata/#modulos-requisicao-de-dados","text":"Se \u00e9 a sua primeira vez utilizando o pacote, digite db basedosdados e confirme novamente se as etapas acima foram conclu\u00eddas com sucesso. O pacote cont\u00e9m 7 comandos, conforme suas funcionalidades descritas abaixo: Comando Descri\u00e7\u00e3o bd_download baixa dados da Base dos Dados (BD). bd_read_sql baixa tabelas da BD usando consultas espec\u00edficas. bd_read_table baixa tabelas da BD usando dataset_id e table_id . bd_list_datasets lista o dataset_id dos conjuntos de dados dispon\u00edveis em query_project_id . bd_list_dataset_tables lista table_id para tabelas dispon\u00edveis no dataset_id especificado. bd_get_table_description mostra a descri\u00e7\u00e3o completa da tabela BD. bd_get_table_columns mostra os nomes, tipos e descri\u00e7\u00f5es das colunas na tabela especificada. Cada comando tem um help file de apoio, bastando abrir o help e seguir as instru\u00e7\u00f5es: help [comando]","title":"M\u00f3dulos (Requisi\u00e7\u00e3o de dados)"},{"location":"colab_checks/","text":"Colaborando com testes na BD Para manter a qualidade dos bases de dados presentes na BD, n\u00f3s contamos com um conjunto de checagens autom\u00e1ticas que s\u00e3o realizadas durante a inser\u00e7\u00e3o e atualiza\u00e7\u00e3o de cada base. Essas checagens s\u00e3o necess\u00e1rias, mas n\u00e3o suficientes para garantir a qualidade dos dados. Elas realizam consultas basicas, como se a tabela existe ou se tem colunas totalmente nulas. Voc\u00ea pode colaborar com a BD aumentando a cobertura dos testes, diminuindo assim o trabalho de revis\u00e3o dos dados. Para isso basta criar consultas que testem a qualidade dos dados em SQL, como as seguintes: Verificar se colunas com propor\u00e7\u00e3o possuem valores entre 0 e 100 Verificar se colunas com datas seguem o padr\u00e3o YYYY-MM-DD HH:MM:SS Qual o procedimento? Incluir testes de dados deve seguir o fluxo de trabalho: Colaborando com testes na BD Qual o procedimento? 1. Informe seu interesse 2. Escreva sua consulta 3. Submeta sua consulta Sugerimos que entre em nosso canal no Discord para tirar d\u00favidas e interagir com outros(as) colaboradores(as)! :) 1. Informe seu interesse Converse conosco no bate-papo da infra no Discord. Caso n\u00e3o tenha uma sugest\u00e3o de melhoria podemos procurar alguma consulta que ainda n\u00e3o foi escrita. 2. Escreva sua consulta Fa\u00e7a um fork do reposit\u00f3rio da Base dos Dados . Em seguida adicione novas consultas e suas respectivas fun\u00e7\u00f5es de execu\u00e7\u00e3o nos arquivos checks.yaml e test_data.py . As consultas s\u00e3o escritas em um arquivo YAML com Jinja e SQL, da forma: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure E executadas como testes do pacote pytest : def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False N\u00e3o se assuste caso n\u00e3o conhe\u00e7a algo da sintaxe acima, podemos lhe ajudar durante o processo. Note que os valores entre chaves s\u00e3o vari\u00e1veis contidas em arquivos table_config.yaml , que cont\u00e9m metadados das tabelas. Logo a escrita de consulta \u00e9 limitada pelos metadados existentes. Recomendamos consultar estes arquivos no diret\u00f3rio das bases . 3. Submeta sua consulta Por fim realize um pull request para o reposit\u00f3rio principal para que seja realizada uma revis\u00e3o da consulta.","title":"Testes"},{"location":"colab_checks/#colaborando-com-testes-na-bd","text":"Para manter a qualidade dos bases de dados presentes na BD, n\u00f3s contamos com um conjunto de checagens autom\u00e1ticas que s\u00e3o realizadas durante a inser\u00e7\u00e3o e atualiza\u00e7\u00e3o de cada base. Essas checagens s\u00e3o necess\u00e1rias, mas n\u00e3o suficientes para garantir a qualidade dos dados. Elas realizam consultas basicas, como se a tabela existe ou se tem colunas totalmente nulas. Voc\u00ea pode colaborar com a BD aumentando a cobertura dos testes, diminuindo assim o trabalho de revis\u00e3o dos dados. Para isso basta criar consultas que testem a qualidade dos dados em SQL, como as seguintes: Verificar se colunas com propor\u00e7\u00e3o possuem valores entre 0 e 100 Verificar se colunas com datas seguem o padr\u00e3o YYYY-MM-DD HH:MM:SS","title":"Colaborando com testes na BD"},{"location":"colab_checks/#qual-o-procedimento","text":"Incluir testes de dados deve seguir o fluxo de trabalho: Colaborando com testes na BD Qual o procedimento? 1. Informe seu interesse 2. Escreva sua consulta 3. Submeta sua consulta Sugerimos que entre em nosso canal no Discord para tirar d\u00favidas e interagir com outros(as) colaboradores(as)! :)","title":"Qual o procedimento?"},{"location":"colab_checks/#1-informe-seu-interesse","text":"Converse conosco no bate-papo da infra no Discord. Caso n\u00e3o tenha uma sugest\u00e3o de melhoria podemos procurar alguma consulta que ainda n\u00e3o foi escrita.","title":"1. Informe seu interesse"},{"location":"colab_checks/#2-escreva-sua-consulta","text":"Fa\u00e7a um fork do reposit\u00f3rio da Base dos Dados . Em seguida adicione novas consultas e suas respectivas fun\u00e7\u00f5es de execu\u00e7\u00e3o nos arquivos checks.yaml e test_data.py . As consultas s\u00e3o escritas em um arquivo YAML com Jinja e SQL, da forma: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure E executadas como testes do pacote pytest : def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False N\u00e3o se assuste caso n\u00e3o conhe\u00e7a algo da sintaxe acima, podemos lhe ajudar durante o processo. Note que os valores entre chaves s\u00e3o vari\u00e1veis contidas em arquivos table_config.yaml , que cont\u00e9m metadados das tabelas. Logo a escrita de consulta \u00e9 limitada pelos metadados existentes. Recomendamos consultar estes arquivos no diret\u00f3rio das bases .","title":"2. Escreva sua consulta"},{"location":"colab_checks/#3-submeta-sua-consulta","text":"Por fim realize um pull request para o reposit\u00f3rio principal para que seja realizada uma revis\u00e3o da consulta.","title":"3. Submeta sua consulta"},{"location":"colab_data/","text":"Suba dados na BD Por que minha organiza\u00e7\u00e3o deve subir dados na BD? Capacidade de cruzar suas bases com dados de diferentes organiza\u00e7\u00f5es de forma simples e f\u00e1cil. J\u00e1 s\u00e3o centenas de conjuntos de dados p\u00fablicos das maiores organiza\u00e7\u00f5es do Brasil e do mundo presentes no nosso datalake . Compromisso com a transpar\u00eancia, qualidade dos dados e desenvolvimento de melhores pesquisas, an\u00e1lises e solu\u00e7\u00f5es para a sociedade. N\u00e3o s\u00f3 democratizamos o acesso a dados abertos, mas tamb\u00e9m dados de qualidade. Temos um time especializado que revisa e garante a qualidade dos dados adicionados ao datalake . Participa\u00e7\u00e3o de uma comunidade que cresce cada vez mais : milhares de jornalistas, pesquisadores(as), desenvolvedores(as), j\u00e1 utilizam e acompanham a Base dos Dados. Passo a passo para subir dados Quer subir dados na BD e nos ajudar a construir esse reposit\u00f3rio? Maravilha! Organizamos tudo o que voc\u00ea precisa no manual abaixo em 8 passos Para facilitar a explica\u00e7\u00e3o, vamos seguir um exemplo j\u00e1 pronto com dados da RAIS . Voc\u00ea pode navegar pelas etapas no menu \u00e0 esquerda. Sugerimos fortemente que entre em nosso canal no Discord para tirar d\u00favidas e interagir com a equipe e outros(as) colaboradores(as)! \ud83d\ude09 Antes de come\u00e7ar Alguns conhecimentos s\u00e3o necess\u00e1rias para realizar esse processo: Python, R, SQL e/ou Stata : para criar os c\u00f3digos de captura e limpeza dos dados. Linha de comando : para configurar seu ambiente local e conex\u00e3o com o Google Cloud. Github : para subir seu c\u00f3digo para revis\u00e3o da nossa equipe. N\u00e3o tem alguma dessas habilidades, mas quer colaborar? Temos um time de dados que pode te ajudar, basta entrar no nosso Discord e mandar uma mensagem em #quero-contribuir. Como funciona o processo? 1. Escolher a base e entender mais dos dados - primeiro precisamos conhecer o que estamos tratando. 2. Baixar nossa pasta template - \u00e9 hora estruturar o trabalho a ser feito 3. Preencher as tabelas de arquitetura - \u00e9 primordial definir a estrutura dos dados antes de iniciarmos o tratamento 4. Escrever codigo de captura e limpeza de dados - hora de botar a m\u00e3o na massa! 5. (Caso necess\u00e1rio) Organizar arquivos auxiliares - porque at\u00e9 dados precisam de guias 6. (Caso necess\u00e1rio) Criar tabela dicion\u00e1rio - momento de montar os dicion\u00e1rios 7. Subir tudo no Google Cloud - afinal, \u00e9 por l\u00e1 que ficam os dados da BD 8. Enviar tudo para revis\u00e3o - um olhar da nossa equipe para garantir que tudo est\u00e1 pronto para ir pra produ\u00e7\u00e3o! 1. Escolher a base e entender mais dos dados Mantemos a lista de conjuntos para volunt\u00e1rios no nosso Github . Para come\u00e7ar a subir uma base do seu interesse, basta abrir uma nova issue de dados. Caso sua base (conjunto) j\u00e1 esteja listada, basta marcar seu usu\u00e1rio do Github como assignee Seu primeiro trabalho \u00e9 preencher as informa\u00e7\u00f5es na issue. Essas informa\u00e7\u00f5es v\u00e3o te ajudar a entender melhor os dados e ser\u00e3o muito \u00fateis para o tratamento e o preenchimento de metadados. Quando finalizar essa etapa, chame algu\u00e9m da equipe dados para que as informa\u00e7\u00f5es que voc\u00ea mapeou sobre o conjunto j\u00e1 entrem pro nosso site! 2. Baixar nossa pasta template Baixe aqui a pasta template e renomeie para o <dataset_id> (definido na issue do passo 1 ). Essa pasta template facilita e organiza todos os passos daqui pra frente. Sua estrutura \u00e9 a seguinte: <dataset_id>/ code/ : C\u00f3digos necess\u00e1rios para captura e limpeza dos dados ( vamos ver mais no passo 4 ). input/ : Cont\u00e9m todos os arquivos com dados originais, exatamente como baixados da fonte prim\u00e1ria. ( vamos ver mais no passo 4 ). output/ : Arquivos finais, j\u00e1 no formato pronto para subir na BD ( vamos ver mais no passo 4 ). tmp/ : Quaisquer arquivos tempor\u00e1rios criados pelo c\u00f3digo em /code no processo de limpeza e tratamento ( vamos ver mais no passo 4 ). extra/ architecture/ : Tabelas de arquitetura ( vamos ver mais no passo 3 ). auxiliary_files/ : Arquivos auxiliares aos dados ( vamos ver mais no passo 5 ). dicionario.csv : Tabela dicion\u00e1rio de todo o conjunto de dados ( vamos ver mais no passo 6 ). Apenas a pasta code ser\u00e1 commitada para o seu projeto, os demais arquivos existir\u00e3o apenas localmente ou no Google Cloud. 3. Preencher as tabelas de arquitetura As tabelas de arquitetura determinam qual a estrutura de cada tabela do seu conjunto de dados . Elas definem, por exemplo, o nome, ordem e metadados das vari\u00e1veis, al\u00e9m de compatibiliza\u00e7\u00f5es quando h\u00e1 mudan\u00e7as em vers\u00f5es (por exemplo, se uma vari\u00e1vel muda de nome de um ano para o outro). Cada tabela do conjunto de dados deve ter sua pr\u00f3pria tabela de arquitetura (planilha), que deve ser preenchida no Google Drive para permitir a corre\u00e7\u00e3o pela nossa equipe de dados. Exemplo: RAIS - Tabelas de arquitetura As tabelas de arquitetura da RAIS podem ser consultadas aqui . Elas s\u00e3o uma \u00f3tima refer\u00eancia para voc\u00ea come\u00e7ar seu trabalho j\u00e1 que tem muitas vari\u00e1veis e exemplos de diversas situa\u00e7\u00f5es que voc\u00ea pode acabar encontrando. Para o preenchimento de cada tabela do seu conjunto siga esse passo a passo: A cada in\u00edcio e final de etapa consulte nosso manual de estilo para garantir que voc\u00ea est\u00e1 seguindo a padroniza\u00e7\u00e3o da BD Listar todas as vari\u00e1veis dos dados na coluna original_name Obs: Caso a base mude o nome das vari\u00e1veis ao longo dos anos (como a RAIS), \u00e9 necess\u00e1rio fazer a compatibiliza\u00e7\u00e3o entre anos para todas as vari\u00e1veis preenchendo a coluna de original_name_YYYY para cada ano ou m\u00eas dispon\u00edvel Renomear as vari\u00e1veis conforme nosso manual na coluna name Entender o tipo da vari\u00e1vel e preencher a coluna bigquery_type Preencher a descri\u00e7\u00e3o em description conforme o manual A partir da compatibiliza\u00e7\u00e3o entre anos e/ou consultas aos dados brutos, preencher a cobertura temporal em temporal_coverage de cada vari\u00e1vel Obs: Caso as vari\u00e1veis tenham a mesma cobertura temporal da tabela preencher apenas com '(1)' Indicar com 'yes' ou 'no' se h\u00e1 dicion\u00e1rio para as vari\u00e1veis em covered_by_dictionary Verificar se as vari\u00e1veis representam alguma entidade presente nos diret\u00f3rios para preencher o directory_column Para as vari\u00e1veis do tipo int64 ou float64 verificar se \u00e9 necess\u00e1rio incluir uma unidade de medida Reordernar as vari\u00e1veis conforme o manual Quando terminar de preencher as tabelas de arquitetura, entre em contato com a equipe da Base dos Dados para validar tudo. \u00c9 necess\u00e1rio que esteja claro o formato final que os dados devem ficar antes de come\u00e7ar a escrever o c\u00f3digo. Assim a gente evita o retrabalho. 4. Escrever codigo de captura e limpeza de dados Ap\u00f3s validadas as tabelas de arquitetura, podemos escrever os c\u00f3digos de captura e limpeza dos dados. Captura : C\u00f3digo que baixa automaticamente todos os dados originais e os salva em /input . Esses dados podem estar dispon\u00edveis em portais ou links FTP, podem ser raspados de sites, entre outros. Limpeza : C\u00f3digo que transforma os dados originais salvos em /input em dados limpos, salva na pasta /output , para, posteriormente, serem subidos na BD. Cada tabela limpa para produ\u00e7\u00e3o pode ser salva como um arquivo \u00fanico ou, caso seja muito grande (e.g. acima de 200 mb), ser particionada no formato Hive em v\u00e1rios sub-arquivos. Os formatos aceitos s\u00e3o .csv ou .parquet . Nossa recomenda\u00e7\u00e3o \u00e9 particionar tabelas por ano , mes e sigla_uf . O particionamento \u00e9 feito atrav\u00e9s da estrutura de pastas, veja o exemplo a baixo para visualizar como. Exemplo: RAIS - Particionamento A tabela microdados_vinculos da RAIS, por exemplo, \u00e9 uma tabela muito grande (+250GB) por isso n\u00f3s particionamos por ano e sigla_uf . O particionamento foi feito usando a estrutura de pastas /microdados_vinculos/ano=YYYY/sigla_uf=XX . Padr\u00f5es necess\u00e1rios no c\u00f3digo Devem ser escritos em Python , R ou Stata - para que a revis\u00e3o possa ser realizada pela equipe. Pode estar em script ( .py , .R , ...) ou notebooks (Google Colab, Jupyter, Rmarkdown, etc). Os caminhos de arquivos devem ser atalhos relativos \u00e0 pasta ra\u00edz ( <dataset_id> ), ou seja, n\u00e3o devem depender dos caminhos do seu computador. A limpeza deve seguir nosso manual de estilo e as melhores pr\u00e1ticas de programa\u00e7\u00e3o . Exemplo: PNAD Cont\u00ednua - C\u00f3digo de limpeza O c\u00f3digo de limpeza foi constru\u00eddo em R e pode ser consultado aqui . Exemplo: Atividade na C\u00e2mara Legislativa - C\u00f3digo de download e limpeza O c\u00f3digo de limpeza foi constru\u00eddo em Python pode ser consultado aqui 5. (Caso necess\u00e1rio) Organizar arquivos auxiliares \u00c9 comum bases de dados serem disponibilizadas com arquivos auxiliares. Esses podem incluir notas t\u00e9cnicas, descri\u00e7\u00f5es de coleta e amostragem, etc. Para ajudar usu\u00e1rios da Base dos Dados terem mais contexto e entenderem melhor os dados, organize todos esses arquivos auxiliares em /extra/auxiliary_files . Fique \u00e0 vontade para estruturar sub-pastas como quiser l\u00e1 dentro. O que importa \u00e9 que fique claro o que s\u00e3o esses arquivos. 6. (Caso necess\u00e1rio) Criar tabela dicion\u00e1rio Muitas vezes, especialmente com bases antigas, h\u00e1 m\u00faltiplos dicion\u00e1rios em formatos Excel ou outros. Na Base dos Dados n\u00f3s unificamos tudo em um \u00fanico arquivo em formato .csv - um \u00fanico dicion\u00e1rio para todas as colunas de todas as tabelas do seu conjunto. Detalhes importantes de como construir seu dicion\u00e1rio est\u00e3o no nosso manual de estilo . Exemplo: RAIS - Dicion\u00e1rio O dicion\u00e1rio completo pode ser consultado aqui . Ele j\u00e1 possui a estrutura padr\u00e3o que utilizamos para dicion\u00e1rios. 7. Subir tudo no Google Cloud Tudo pronto! Agora s\u00f3 falta subir para o Google Cloud e enviar para revis\u00e3o. Para isso, vamos usar o cliente basedosdados (dispon\u00edvel em Python) que facilita as configura\u00e7\u00f5es e etapas do processo. Como existe um custo para o armazenamento no storage, para finalizar essa etapa vamos precisar te disponibilizar uma api_key especifica para volunt\u00e1rios para subir os dados em nosso ambiente de desenvolvimento. Assim, entre em nosso canal no Discord e nos chame em 'quero-contribuir' Configure suas credenciais localmente 7.1 No seu terminal instale nosso cliente: pip install basedosdados . 7.2 Rode import basedosdados as bd no python e siga o passo a passo para configurar localmente com as credenciais de seu projeto no Google Cloud. Preencha as informa\u00e7\u00f5es conforme a seguir: * STEP 1: y * STEP 2: basedosdados-dev (colocar o .json passado pela equipe da bd na pasta credentials) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql Suba os arquivos na Cloud Os dados v\u00e3o passar por 3 lugares no Google Cloud: Storage : tamb\u00e9m chamado de GCS \u00e9 o local onde ser\u00e3o armazenados o arquivos \"frios\" (arquiteturas, dados, arquivos auxiliares). BigQuery-DEV-Staging : tabela que conecta os dados do storage ao projeto basedosdados-dev no bigquery BigQuery-DEV-Produ\u00e7\u00e3o : tabela utilizada paras teste e tratamento via SQL do conjunto de dados 7.3 Crie a tabela no bucket do GCS e BigQuey-DEV-staging , usando a API do Python, da seguinte forma: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<caminho_para_os_dados>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` Os seguintes par\u00e2metros podem ser usados: - `path` (obrigat\u00f3rio): o caminho completo do arquivo no seu computador, como: `/Users/<seu_usuario>/projetos/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"Caso seus dados sejam particionados, o caminho deve apontar para a pasta onde est\u00e3o as parti\u00e7\u00f5es. No contr\u00e1rio, deve apontar para um arquivo `.csv` (por exemplo, microdados.csv).\" - `force_dataset`: comando que cria os arquivos de configura\u00e7\u00e3o do dataset no BigQuery. - _True_: os arquivos de configura\u00e7\u00e3o do dataset ser\u00e3o criados no seu projeto e, caso ele n\u00e3o exista no BigQuery, ser\u00e1 criado automaticamente. **Se voc\u00ea j\u00e1 tiver criado e configurado o dataset, n\u00e3o use esta op\u00e7\u00e3o, pois ir\u00e1 sobrescrever arquivos**. - _False_: o dataset n\u00e3o ser\u00e1 recriado e, se n\u00e3o existir, ser\u00e1 criado automaticamente. - `if_table_exists` : comando utilizado caso a **tabela j\u00e1 exista no BQ**: - _raise_: retorna mensagem de erro. - _replace_: substitui a tabela. - _pass_: n\u00e3o faz nada. - `if_storage_data_exists`: comando utilizado caso os **dados j\u00e1 existam no Google Cloud Storage**: - _raise_: retorna mensagem de erro - _replace_: substitui os dados existentes. - _pass_: n\u00e3o faz nada. !!! Info \"Se o projeto n\u00e3o existir no BigQuery, ele ser\u00e1 automaticamente criado\" Consulte tamb\u00e9m nossa API para mais detalhes de cada m\u00e9todo. 7.4 Crie os arquivos .sql e schema.yml a partir da tabela de arquitetura seguindo essa documenta\u00e7\u00e3o Caso voc\u00ea precise, nesse momento voc\u00ea pode alterar a consulta em SQL para realizar tratamentos finais a partir da tabela staging , pode incluir coluna, remover coluna, fazer opera\u00e7\u00f5es alg\u00e9bricas, substituir strings, etc. O SQL \u00e9 o limite! 7.5 Rode e teste os modelos localmente seguindo essa documenta\u00e7\u00e3o 7.6 Suba os metadados da tabela no site: Por enquanto apenas a equipe dados tem permiss\u00f5es de subir os metadados da tabela no site, por isso ser\u00e1 necess\u00e1rio entrar em contato conosco. J\u00e1 estamos trabalhando para que, num futuro pr\u00f3ximo, os volunt\u00e1rios tamb\u00e9m possam atualizar dados no site. 7.7 Suba os arquivos auxiliares: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'caminho_para_os_arquivos_auxiliares' , mode = 'auxiliary_files' , if_exists = 'raise' ) 8. Enviar tudo para revis\u00e3o Ufa, \u00e9 isso! Agora s\u00f3 resta enviar tudo para revis\u00e3o no reposit\u00f3rio da Base dos Dados. Clone o nosso reposit\u00f3rio localmente. D\u00ea um cd para a pasta local do reposit\u00f3rio e abra uma nova branch com git checkout -b [dataset_id] . Todas as adi\u00e7\u00f5es e modifica\u00e7\u00f5es ser\u00e3o inclu\u00eddas nessa branch . Para cada tabela nova incluir o arquivo com nome table_id.sql na pasta queries-basedosdados/models/dataset_id/ copiando as queries que voc\u00ea desenvolveu no passo 7. Incluir o arquivo schema.yaml desenvolvido no passo 7 Caso seja um dataset novo, incluir o dataset conforme as instru\u00e7\u00f5es do arquivo queries-basedosdados/dbt_project.yaml (n\u00e3o se esque\u00e7a de seguir a ordem alfab\u00e9tica pra n\u00e3o bagun\u00e7ar a organiza\u00e7\u00e3o) Inclua o seu c\u00f3digo de captura e limpeza em na pasta queries-basedosdados/models/dataset_id/code Agora \u00e9 s\u00f3 publicar a branch, abrir o PR com as labels 'table-approve' e marcar a equipe dados para corre\u00e7\u00e3o E agora? Nossa equipe ir\u00e1 revisar os dados e metadados submetidos via Github. Podemos entrar em contato para tirar d\u00favidas ou solicitar mudan\u00e7as no c\u00f3digo. Quando tudo estiver OK, fazemos um merge do seu pull request e os dados s\u00e3o automaticamente publicados na nossa plataforma!","title":"Dados"},{"location":"colab_data/#suba-dados-na-bd","text":"","title":"Suba dados na BD"},{"location":"colab_data/#por-que-minha-organizacao-deve-subir-dados-na-bd","text":"Capacidade de cruzar suas bases com dados de diferentes organiza\u00e7\u00f5es de forma simples e f\u00e1cil. J\u00e1 s\u00e3o centenas de conjuntos de dados p\u00fablicos das maiores organiza\u00e7\u00f5es do Brasil e do mundo presentes no nosso datalake . Compromisso com a transpar\u00eancia, qualidade dos dados e desenvolvimento de melhores pesquisas, an\u00e1lises e solu\u00e7\u00f5es para a sociedade. N\u00e3o s\u00f3 democratizamos o acesso a dados abertos, mas tamb\u00e9m dados de qualidade. Temos um time especializado que revisa e garante a qualidade dos dados adicionados ao datalake . Participa\u00e7\u00e3o de uma comunidade que cresce cada vez mais : milhares de jornalistas, pesquisadores(as), desenvolvedores(as), j\u00e1 utilizam e acompanham a Base dos Dados.","title":"Por que minha organiza\u00e7\u00e3o deve subir dados na BD?"},{"location":"colab_data/#passo-a-passo-para-subir-dados","text":"Quer subir dados na BD e nos ajudar a construir esse reposit\u00f3rio? Maravilha! Organizamos tudo o que voc\u00ea precisa no manual abaixo em 8 passos Para facilitar a explica\u00e7\u00e3o, vamos seguir um exemplo j\u00e1 pronto com dados da RAIS . Voc\u00ea pode navegar pelas etapas no menu \u00e0 esquerda. Sugerimos fortemente que entre em nosso canal no Discord para tirar d\u00favidas e interagir com a equipe e outros(as) colaboradores(as)! \ud83d\ude09","title":"Passo a passo para subir dados"},{"location":"colab_data/#antes-de-comecar","text":"Alguns conhecimentos s\u00e3o necess\u00e1rias para realizar esse processo: Python, R, SQL e/ou Stata : para criar os c\u00f3digos de captura e limpeza dos dados. Linha de comando : para configurar seu ambiente local e conex\u00e3o com o Google Cloud. Github : para subir seu c\u00f3digo para revis\u00e3o da nossa equipe. N\u00e3o tem alguma dessas habilidades, mas quer colaborar? Temos um time de dados que pode te ajudar, basta entrar no nosso Discord e mandar uma mensagem em #quero-contribuir.","title":"Antes de come\u00e7ar"},{"location":"colab_data/#como-funciona-o-processo","text":"1. Escolher a base e entender mais dos dados - primeiro precisamos conhecer o que estamos tratando. 2. Baixar nossa pasta template - \u00e9 hora estruturar o trabalho a ser feito 3. Preencher as tabelas de arquitetura - \u00e9 primordial definir a estrutura dos dados antes de iniciarmos o tratamento 4. Escrever codigo de captura e limpeza de dados - hora de botar a m\u00e3o na massa! 5. (Caso necess\u00e1rio) Organizar arquivos auxiliares - porque at\u00e9 dados precisam de guias 6. (Caso necess\u00e1rio) Criar tabela dicion\u00e1rio - momento de montar os dicion\u00e1rios 7. Subir tudo no Google Cloud - afinal, \u00e9 por l\u00e1 que ficam os dados da BD 8. Enviar tudo para revis\u00e3o - um olhar da nossa equipe para garantir que tudo est\u00e1 pronto para ir pra produ\u00e7\u00e3o!","title":"Como funciona o processo?"},{"location":"colab_data/#1-escolher-a-base-e-entender-mais-dos-dados","text":"Mantemos a lista de conjuntos para volunt\u00e1rios no nosso Github . Para come\u00e7ar a subir uma base do seu interesse, basta abrir uma nova issue de dados. Caso sua base (conjunto) j\u00e1 esteja listada, basta marcar seu usu\u00e1rio do Github como assignee Seu primeiro trabalho \u00e9 preencher as informa\u00e7\u00f5es na issue. Essas informa\u00e7\u00f5es v\u00e3o te ajudar a entender melhor os dados e ser\u00e3o muito \u00fateis para o tratamento e o preenchimento de metadados. Quando finalizar essa etapa, chame algu\u00e9m da equipe dados para que as informa\u00e7\u00f5es que voc\u00ea mapeou sobre o conjunto j\u00e1 entrem pro nosso site!","title":"1. Escolher a base e entender mais dos dados"},{"location":"colab_data/#2-baixar-nossa-pasta-template","text":"Baixe aqui a pasta template e renomeie para o <dataset_id> (definido na issue do passo 1 ). Essa pasta template facilita e organiza todos os passos daqui pra frente. Sua estrutura \u00e9 a seguinte: <dataset_id>/ code/ : C\u00f3digos necess\u00e1rios para captura e limpeza dos dados ( vamos ver mais no passo 4 ). input/ : Cont\u00e9m todos os arquivos com dados originais, exatamente como baixados da fonte prim\u00e1ria. ( vamos ver mais no passo 4 ). output/ : Arquivos finais, j\u00e1 no formato pronto para subir na BD ( vamos ver mais no passo 4 ). tmp/ : Quaisquer arquivos tempor\u00e1rios criados pelo c\u00f3digo em /code no processo de limpeza e tratamento ( vamos ver mais no passo 4 ). extra/ architecture/ : Tabelas de arquitetura ( vamos ver mais no passo 3 ). auxiliary_files/ : Arquivos auxiliares aos dados ( vamos ver mais no passo 5 ). dicionario.csv : Tabela dicion\u00e1rio de todo o conjunto de dados ( vamos ver mais no passo 6 ). Apenas a pasta code ser\u00e1 commitada para o seu projeto, os demais arquivos existir\u00e3o apenas localmente ou no Google Cloud.","title":"2. Baixar nossa pasta template"},{"location":"colab_data/#3-preencher-as-tabelas-de-arquitetura","text":"As tabelas de arquitetura determinam qual a estrutura de cada tabela do seu conjunto de dados . Elas definem, por exemplo, o nome, ordem e metadados das vari\u00e1veis, al\u00e9m de compatibiliza\u00e7\u00f5es quando h\u00e1 mudan\u00e7as em vers\u00f5es (por exemplo, se uma vari\u00e1vel muda de nome de um ano para o outro). Cada tabela do conjunto de dados deve ter sua pr\u00f3pria tabela de arquitetura (planilha), que deve ser preenchida no Google Drive para permitir a corre\u00e7\u00e3o pela nossa equipe de dados.","title":"3. Preencher as tabelas de arquitetura"},{"location":"colab_data/#exemplo-rais-tabelas-de-arquitetura","text":"As tabelas de arquitetura da RAIS podem ser consultadas aqui . Elas s\u00e3o uma \u00f3tima refer\u00eancia para voc\u00ea come\u00e7ar seu trabalho j\u00e1 que tem muitas vari\u00e1veis e exemplos de diversas situa\u00e7\u00f5es que voc\u00ea pode acabar encontrando.","title":"Exemplo: RAIS - Tabelas de arquitetura"},{"location":"colab_data/#para-o-preenchimento-de-cada-tabela-do-seu-conjunto-siga-esse-passo-a-passo","text":"A cada in\u00edcio e final de etapa consulte nosso manual de estilo para garantir que voc\u00ea est\u00e1 seguindo a padroniza\u00e7\u00e3o da BD Listar todas as vari\u00e1veis dos dados na coluna original_name Obs: Caso a base mude o nome das vari\u00e1veis ao longo dos anos (como a RAIS), \u00e9 necess\u00e1rio fazer a compatibiliza\u00e7\u00e3o entre anos para todas as vari\u00e1veis preenchendo a coluna de original_name_YYYY para cada ano ou m\u00eas dispon\u00edvel Renomear as vari\u00e1veis conforme nosso manual na coluna name Entender o tipo da vari\u00e1vel e preencher a coluna bigquery_type Preencher a descri\u00e7\u00e3o em description conforme o manual A partir da compatibiliza\u00e7\u00e3o entre anos e/ou consultas aos dados brutos, preencher a cobertura temporal em temporal_coverage de cada vari\u00e1vel Obs: Caso as vari\u00e1veis tenham a mesma cobertura temporal da tabela preencher apenas com '(1)' Indicar com 'yes' ou 'no' se h\u00e1 dicion\u00e1rio para as vari\u00e1veis em covered_by_dictionary Verificar se as vari\u00e1veis representam alguma entidade presente nos diret\u00f3rios para preencher o directory_column Para as vari\u00e1veis do tipo int64 ou float64 verificar se \u00e9 necess\u00e1rio incluir uma unidade de medida Reordernar as vari\u00e1veis conforme o manual Quando terminar de preencher as tabelas de arquitetura, entre em contato com a equipe da Base dos Dados para validar tudo. \u00c9 necess\u00e1rio que esteja claro o formato final que os dados devem ficar antes de come\u00e7ar a escrever o c\u00f3digo. Assim a gente evita o retrabalho.","title":"Para o preenchimento de cada tabela do seu conjunto siga esse passo a passo:"},{"location":"colab_data/#4-escrever-codigo-de-captura-e-limpeza-de-dados","text":"Ap\u00f3s validadas as tabelas de arquitetura, podemos escrever os c\u00f3digos de captura e limpeza dos dados. Captura : C\u00f3digo que baixa automaticamente todos os dados originais e os salva em /input . Esses dados podem estar dispon\u00edveis em portais ou links FTP, podem ser raspados de sites, entre outros. Limpeza : C\u00f3digo que transforma os dados originais salvos em /input em dados limpos, salva na pasta /output , para, posteriormente, serem subidos na BD. Cada tabela limpa para produ\u00e7\u00e3o pode ser salva como um arquivo \u00fanico ou, caso seja muito grande (e.g. acima de 200 mb), ser particionada no formato Hive em v\u00e1rios sub-arquivos. Os formatos aceitos s\u00e3o .csv ou .parquet . Nossa recomenda\u00e7\u00e3o \u00e9 particionar tabelas por ano , mes e sigla_uf . O particionamento \u00e9 feito atrav\u00e9s da estrutura de pastas, veja o exemplo a baixo para visualizar como.","title":"4. Escrever codigo de captura e limpeza de dados"},{"location":"colab_data/#exemplo-rais-particionamento","text":"A tabela microdados_vinculos da RAIS, por exemplo, \u00e9 uma tabela muito grande (+250GB) por isso n\u00f3s particionamos por ano e sigla_uf . O particionamento foi feito usando a estrutura de pastas /microdados_vinculos/ano=YYYY/sigla_uf=XX .","title":"Exemplo: RAIS - Particionamento"},{"location":"colab_data/#padroes-necessarios-no-codigo","text":"Devem ser escritos em Python , R ou Stata - para que a revis\u00e3o possa ser realizada pela equipe. Pode estar em script ( .py , .R , ...) ou notebooks (Google Colab, Jupyter, Rmarkdown, etc). Os caminhos de arquivos devem ser atalhos relativos \u00e0 pasta ra\u00edz ( <dataset_id> ), ou seja, n\u00e3o devem depender dos caminhos do seu computador. A limpeza deve seguir nosso manual de estilo e as melhores pr\u00e1ticas de programa\u00e7\u00e3o .","title":"Padr\u00f5es necess\u00e1rios no c\u00f3digo"},{"location":"colab_data/#exemplo-pnad-continua-codigo-de-limpeza","text":"O c\u00f3digo de limpeza foi constru\u00eddo em R e pode ser consultado aqui .","title":"Exemplo: PNAD Cont\u00ednua - C\u00f3digo de limpeza"},{"location":"colab_data/#exemplo-atividade-na-camara-legislativa-codigo-de-download-e-limpeza","text":"O c\u00f3digo de limpeza foi constru\u00eddo em Python pode ser consultado aqui","title":"Exemplo: Atividade na C\u00e2mara Legislativa - C\u00f3digo de download e limpeza"},{"location":"colab_data/#5-caso-necessario-organizar-arquivos-auxiliares","text":"\u00c9 comum bases de dados serem disponibilizadas com arquivos auxiliares. Esses podem incluir notas t\u00e9cnicas, descri\u00e7\u00f5es de coleta e amostragem, etc. Para ajudar usu\u00e1rios da Base dos Dados terem mais contexto e entenderem melhor os dados, organize todos esses arquivos auxiliares em /extra/auxiliary_files . Fique \u00e0 vontade para estruturar sub-pastas como quiser l\u00e1 dentro. O que importa \u00e9 que fique claro o que s\u00e3o esses arquivos.","title":"5. (Caso necess\u00e1rio) Organizar arquivos auxiliares"},{"location":"colab_data/#6-caso-necessario-criar-tabela-dicionario","text":"Muitas vezes, especialmente com bases antigas, h\u00e1 m\u00faltiplos dicion\u00e1rios em formatos Excel ou outros. Na Base dos Dados n\u00f3s unificamos tudo em um \u00fanico arquivo em formato .csv - um \u00fanico dicion\u00e1rio para todas as colunas de todas as tabelas do seu conjunto. Detalhes importantes de como construir seu dicion\u00e1rio est\u00e3o no nosso manual de estilo .","title":"6. (Caso necess\u00e1rio) Criar tabela dicion\u00e1rio"},{"location":"colab_data/#exemplo-rais-dicionario","text":"O dicion\u00e1rio completo pode ser consultado aqui . Ele j\u00e1 possui a estrutura padr\u00e3o que utilizamos para dicion\u00e1rios.","title":"Exemplo: RAIS - Dicion\u00e1rio"},{"location":"colab_data/#7-subir-tudo-no-google-cloud","text":"Tudo pronto! Agora s\u00f3 falta subir para o Google Cloud e enviar para revis\u00e3o. Para isso, vamos usar o cliente basedosdados (dispon\u00edvel em Python) que facilita as configura\u00e7\u00f5es e etapas do processo. Como existe um custo para o armazenamento no storage, para finalizar essa etapa vamos precisar te disponibilizar uma api_key especifica para volunt\u00e1rios para subir os dados em nosso ambiente de desenvolvimento. Assim, entre em nosso canal no Discord e nos chame em 'quero-contribuir'","title":"7. Subir tudo no Google Cloud"},{"location":"colab_data/#configure-suas-credenciais-localmente","text":"7.1 No seu terminal instale nosso cliente: pip install basedosdados . 7.2 Rode import basedosdados as bd no python e siga o passo a passo para configurar localmente com as credenciais de seu projeto no Google Cloud. Preencha as informa\u00e7\u00f5es conforme a seguir: * STEP 1: y * STEP 2: basedosdados-dev (colocar o .json passado pela equipe da bd na pasta credentials) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql","title":"Configure suas credenciais localmente"},{"location":"colab_data/#suba-os-arquivos-na-cloud","text":"Os dados v\u00e3o passar por 3 lugares no Google Cloud: Storage : tamb\u00e9m chamado de GCS \u00e9 o local onde ser\u00e3o armazenados o arquivos \"frios\" (arquiteturas, dados, arquivos auxiliares). BigQuery-DEV-Staging : tabela que conecta os dados do storage ao projeto basedosdados-dev no bigquery BigQuery-DEV-Produ\u00e7\u00e3o : tabela utilizada paras teste e tratamento via SQL do conjunto de dados 7.3 Crie a tabela no bucket do GCS e BigQuey-DEV-staging , usando a API do Python, da seguinte forma: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<caminho_para_os_dados>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` Os seguintes par\u00e2metros podem ser usados: - `path` (obrigat\u00f3rio): o caminho completo do arquivo no seu computador, como: `/Users/<seu_usuario>/projetos/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"Caso seus dados sejam particionados, o caminho deve apontar para a pasta onde est\u00e3o as parti\u00e7\u00f5es. No contr\u00e1rio, deve apontar para um arquivo `.csv` (por exemplo, microdados.csv).\" - `force_dataset`: comando que cria os arquivos de configura\u00e7\u00e3o do dataset no BigQuery. - _True_: os arquivos de configura\u00e7\u00e3o do dataset ser\u00e3o criados no seu projeto e, caso ele n\u00e3o exista no BigQuery, ser\u00e1 criado automaticamente. **Se voc\u00ea j\u00e1 tiver criado e configurado o dataset, n\u00e3o use esta op\u00e7\u00e3o, pois ir\u00e1 sobrescrever arquivos**. - _False_: o dataset n\u00e3o ser\u00e1 recriado e, se n\u00e3o existir, ser\u00e1 criado automaticamente. - `if_table_exists` : comando utilizado caso a **tabela j\u00e1 exista no BQ**: - _raise_: retorna mensagem de erro. - _replace_: substitui a tabela. - _pass_: n\u00e3o faz nada. - `if_storage_data_exists`: comando utilizado caso os **dados j\u00e1 existam no Google Cloud Storage**: - _raise_: retorna mensagem de erro - _replace_: substitui os dados existentes. - _pass_: n\u00e3o faz nada. !!! Info \"Se o projeto n\u00e3o existir no BigQuery, ele ser\u00e1 automaticamente criado\" Consulte tamb\u00e9m nossa API para mais detalhes de cada m\u00e9todo. 7.4 Crie os arquivos .sql e schema.yml a partir da tabela de arquitetura seguindo essa documenta\u00e7\u00e3o Caso voc\u00ea precise, nesse momento voc\u00ea pode alterar a consulta em SQL para realizar tratamentos finais a partir da tabela staging , pode incluir coluna, remover coluna, fazer opera\u00e7\u00f5es alg\u00e9bricas, substituir strings, etc. O SQL \u00e9 o limite! 7.5 Rode e teste os modelos localmente seguindo essa documenta\u00e7\u00e3o 7.6 Suba os metadados da tabela no site: Por enquanto apenas a equipe dados tem permiss\u00f5es de subir os metadados da tabela no site, por isso ser\u00e1 necess\u00e1rio entrar em contato conosco. J\u00e1 estamos trabalhando para que, num futuro pr\u00f3ximo, os volunt\u00e1rios tamb\u00e9m possam atualizar dados no site. 7.7 Suba os arquivos auxiliares: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'caminho_para_os_arquivos_auxiliares' , mode = 'auxiliary_files' , if_exists = 'raise' )","title":"Suba os arquivos na Cloud"},{"location":"colab_data/#8-enviar-tudo-para-revisao","text":"Ufa, \u00e9 isso! Agora s\u00f3 resta enviar tudo para revis\u00e3o no reposit\u00f3rio da Base dos Dados. Clone o nosso reposit\u00f3rio localmente. D\u00ea um cd para a pasta local do reposit\u00f3rio e abra uma nova branch com git checkout -b [dataset_id] . Todas as adi\u00e7\u00f5es e modifica\u00e7\u00f5es ser\u00e3o inclu\u00eddas nessa branch . Para cada tabela nova incluir o arquivo com nome table_id.sql na pasta queries-basedosdados/models/dataset_id/ copiando as queries que voc\u00ea desenvolveu no passo 7. Incluir o arquivo schema.yaml desenvolvido no passo 7 Caso seja um dataset novo, incluir o dataset conforme as instru\u00e7\u00f5es do arquivo queries-basedosdados/dbt_project.yaml (n\u00e3o se esque\u00e7a de seguir a ordem alfab\u00e9tica pra n\u00e3o bagun\u00e7ar a organiza\u00e7\u00e3o) Inclua o seu c\u00f3digo de captura e limpeza em na pasta queries-basedosdados/models/dataset_id/code Agora \u00e9 s\u00f3 publicar a branch, abrir o PR com as labels 'table-approve' e marcar a equipe dados para corre\u00e7\u00e3o E agora? Nossa equipe ir\u00e1 revisar os dados e metadados submetidos via Github. Podemos entrar em contato para tirar d\u00favidas ou solicitar mudan\u00e7as no c\u00f3digo. Quando tudo estiver OK, fazemos um merge do seu pull request e os dados s\u00e3o automaticamente publicados na nossa plataforma!","title":"8. Enviar tudo para revis\u00e3o"},{"location":"colab_infrastructure/","text":"Infra da BD Nosso time de infraestrutura cuida para que todos os pacotes e pipelines estejam funcionando da melhor forma para o p\u00fablico. Utilizamos o Github para gerir todo o c\u00f3digo e mant\u00ea-lo organizado, onde voc\u00ea pode encontrar issues de novas features, bugs e melhorias que estamos trabalhando. Como funciona nossa infraestrutura Nossa infraestrutura \u00e9 composta de 3 frentes principais: Sistema de ingest\u00e3o de dados : desde o upload at\u00e9 a disponibiliza\u00e7\u00e3o em produ\u00e7\u00e3o; Pacotes de acesso Website : Front-end, Back-end e APIs. Atualmente \u00e9 poss\u00edvel colaborar em todas as frentes, com destaque ao desenvolvimento dos pesos e contrapesos e atualiza\u00e7\u00e3o do site. Sugerimos que entre em nosso canal no Discord para tirar d\u00favidas e interagir com outros(as) colaboradores(as)! :) Sistema de ingest\u00e3o de dados O sistema possui ambientes de desenvolvimento ( basedosdados-dev ), homologa\u00e7\u00e3o ( basedosdados-staging ) e produ\u00e7\u00e3o ( basedosdados ) no BigQuery. Os processos para subida de dados s\u00e3o detalhados na imagem abaixo, sendo alguns deles automatizados via Github Actions. Explicamos com mais detalhes do funcionamento desse sistema no blog . Como contribuir? Melhorando a documenta\u00e7\u00e3o do sistema aqui :) Criando checagens autom\u00e1ticas de qualidade de dados e metadados (em Python) Criando novos issues e sugest\u00f5es de melhorias Pacotes de acesso Os pacotes de acesso ao datalake est\u00e3o em constante melhoria e voc\u00ea pode colaborar com a gente com novas features, conserto de bugs e muito mais. Como contribuir? Explore os issues do pacote Python Explore os issues do pacote R Ajude a desenvolver o pacote em Stata Website Nosso website \u00e9 desenvolvido em Next.js e consome uma API de metadados do CKAN. O c\u00f3digo do site est\u00e1 tamb\u00e9m no nosso Github . Como contribuir? Melhore o UX do site (Next, CSS, HTML) Ajudando em issues abertas de BE, FE ou API Criando novos issues e sugest\u00f5es de melhorias","title":"Infraestrutura"},{"location":"colab_infrastructure/#infra-da-bd","text":"Nosso time de infraestrutura cuida para que todos os pacotes e pipelines estejam funcionando da melhor forma para o p\u00fablico. Utilizamos o Github para gerir todo o c\u00f3digo e mant\u00ea-lo organizado, onde voc\u00ea pode encontrar issues de novas features, bugs e melhorias que estamos trabalhando.","title":"Infra da BD"},{"location":"colab_infrastructure/#como-funciona-nossa-infraestrutura","text":"Nossa infraestrutura \u00e9 composta de 3 frentes principais: Sistema de ingest\u00e3o de dados : desde o upload at\u00e9 a disponibiliza\u00e7\u00e3o em produ\u00e7\u00e3o; Pacotes de acesso Website : Front-end, Back-end e APIs. Atualmente \u00e9 poss\u00edvel colaborar em todas as frentes, com destaque ao desenvolvimento dos pesos e contrapesos e atualiza\u00e7\u00e3o do site. Sugerimos que entre em nosso canal no Discord para tirar d\u00favidas e interagir com outros(as) colaboradores(as)! :)","title":"Como funciona nossa infraestrutura"},{"location":"colab_infrastructure/#sistema-de-ingestao-de-dados","text":"O sistema possui ambientes de desenvolvimento ( basedosdados-dev ), homologa\u00e7\u00e3o ( basedosdados-staging ) e produ\u00e7\u00e3o ( basedosdados ) no BigQuery. Os processos para subida de dados s\u00e3o detalhados na imagem abaixo, sendo alguns deles automatizados via Github Actions. Explicamos com mais detalhes do funcionamento desse sistema no blog .","title":"Sistema de ingest\u00e3o de dados"},{"location":"colab_infrastructure/#como-contribuir","text":"Melhorando a documenta\u00e7\u00e3o do sistema aqui :) Criando checagens autom\u00e1ticas de qualidade de dados e metadados (em Python) Criando novos issues e sugest\u00f5es de melhorias","title":"Como contribuir?"},{"location":"colab_infrastructure/#pacotes-de-acesso","text":"Os pacotes de acesso ao datalake est\u00e3o em constante melhoria e voc\u00ea pode colaborar com a gente com novas features, conserto de bugs e muito mais.","title":"Pacotes de acesso"},{"location":"colab_infrastructure/#como-contribuir_1","text":"Explore os issues do pacote Python Explore os issues do pacote R Ajude a desenvolver o pacote em Stata","title":"Como contribuir?"},{"location":"colab_infrastructure/#website","text":"Nosso website \u00e9 desenvolvido em Next.js e consome uma API de metadados do CKAN. O c\u00f3digo do site est\u00e1 tamb\u00e9m no nosso Github .","title":"Website"},{"location":"colab_infrastructure/#como-contribuir_2","text":"Melhore o UX do site (Next, CSS, HTML) Ajudando em issues abertas de BE, FE ou API Criando novos issues e sugest\u00f5es de melhorias","title":"Como contribuir?"},{"location":"style_data/","text":"Manual de estilo Nessa se\u00e7\u00e3o listamos todos os padr\u00f5es do nosso manual de estilo e diretrizes de dados que usamos na Base dos Dados. Eles nos ajudam a manter os dados e metadados que publicamos com qualidade alta. Voc\u00ea pode usar o menu esquerdo para navegar pelos diferentes t\u00f3picos dessa p\u00e1gina. Nomea\u00e7\u00e3o de bases e tabelas Conjuntos de dados ( dataset_id ) Nomeamos conjuntos no formato <organization_id\\>_<descri\u00e7\u00e3o\\> , onde organization_id segue por padr\u00e3o a abrang\u00eancia geogr\u00e1fica da organiza\u00e7\u00e3o que publica o conjunto: organization_id Mundial mundo_<organizacao> Federal <sigla_pais>_<organizacao> Estadual <sigla_pais>_<sigla_uf>_<organizacao> Municipal <sigla_pais>_<sigla_uf>_<cidade>_<organizacao> sigla_pais e sigla_uf s\u00e3o sempre 2 letras min\u00fasculas; organizacao \u00e9 o nome ou sigla (de prefer\u00eancia) da organiza\u00e7\u00e3o que publicou os dados orginais (ex: ibge , tse , inep ). descricao \u00e9 uma breve descri\u00e7\u00e3o do conjunto de dados, que pode ser Por exemplo, o conjunto de dados do PIB do IBGE tem como dataset_id : br_ibge_pib N\u00e3o sabe como nomear a organiza\u00e7\u00e3o? Sugerimos que v\u00e1 no site da mesma e veja como ela se autodenomina (ex: DETRAN-RJ seria br_rj_detran ) Tabelas Nomear tabelas \u00e9 algo menos estruturado e, por isso, requer bom senso. Mas temos algumas regras: Se houver tabelas para diferentes entidades, incluir a entidade no come\u00e7o do nome. Exemplo: municipio_valor , uf_valor . N\u00e3o incluir a unidade temporal no nome. Exemplo: nomear municipio , e n\u00e3o municipio_ano . Deixar nomes no singular. Exemplo: escola , e n\u00e3o escolas . Nomear de microdados as tabelas mais desagregadas. Em geral essas tem dados a n\u00edvel de pessoa ou transa\u00e7\u00e3o. Exemplos de dataset_id.table_id Mundial mundo_waze.alertas Dados de alertas do Waze de diferentes cidades. Federal br_tse_eleicoes.candidatos Dados de candidatos a cargos pol\u00edticos do TSE. Federal br_ibge_pnad.microdados Microdados da Pesquisa Nacional por Amostra de Domic\u00edlios produzidos pelo IBGE. Federal br_ibge_pnadc.microdados Microdados da Pesquisa Nacional por Amostra de Domic\u00edlios Cont\u00ednua (PNAD-C) produzidos pelo IBGE. Estadual br_sp_see_docentes.carga_horaria Carga hor\u00e1ria anonimizado de docentes ativos da rede estadual de ensino de SP. Municipal br_rj_riodejaneiro_cmrj_legislativo.votacoes Dados de vota\u00e7\u00e3o da C\u00e2mara Municipal do Rio de Janeiro (RJ). Formatos de tabelas Tabelas devem, na medida do poss\u00edvel, estar no formato long , ao inv\u00e9s de wide . Nomea\u00e7\u00e3o de vari\u00e1veis Nomes de vari\u00e1veis devem respeitar algumas regras: Usar ao m\u00e1ximo nomes j\u00e1 presentes no reposit\u00f3rio. Exemplos: ano , mes , id_municipio , sigla_uf , idade , cargo , resultado , votos , receita , despesa , preco , etc. Respeitar padr\u00f5es das tabelas de diret\u00f3rios. Ser o mais intuitivo, claro e extenso poss\u00edvel. Ter todas letras min\u00fasculas (inclusive siglas), sem acentos, conectados por _ . N\u00e3o incluir conectores como de , da , dos , e , a , em , etc. S\u00f3 ter o prefixo id_ quando a vari\u00e1vel representar chaves prim\u00e1rias de entidades (que eventualmente teriam uma tabela de diret\u00f3rio). Exemplos que tem: id_municipio , id_uf , id_escola , id_pessoa . Exemplos que n\u00e3o tem: rede , localizacao . Importante : quando a base est\u00e1 em ingl\u00eas id vira um sufixo S\u00f3 ter sufixos de entidade quando a entidade da coluna for diferente da entidade da tabela. Exemplos que tem: numa tabela com entidade pessoa , uma coluna sobre PIB municipal se chamaria pib_municipio . Exemplos que n\u00e3o tem: numa tabela com entidade pessoa , caracter\u00edsticas da pessoa se chamariam nome , idade , sexo , etc. Lista de prefixos permitidos nome_ , data_ , quantidade_ , proporcao_ (vari\u00e1veis de porcentagem 0-100%), taxa_ , razao_ , indice_ , indicador_ (vari\u00e1veis do tipo booleano), tipo_ , sigla_ , sequencial_ . Lista de sufixos comuns _pc (per capita) Ordenamento de vari\u00e1veis A ordem de vari\u00e1veis em tabelas \u00e9 padronizada para manter uma consist\u00eancia no reposit\u00f3rio. Nossas regras s\u00e3o: Chaves prim\u00e1rias \u00e0 esquerda, em ordem descendente de abrang\u00eancia; No meio devem estar vari\u00e1veis qualitativas da linha; As \u00faltimas vari\u00e1veis devem ser os valores quantitativos em ordem crescente de relev\u00e2ncia; Exemplo de ordem: ano , sigla_uf , id_municipio , id_escola , rede , nota_ideb ; Dependendo da tabela, pode ser recomendado agrupar e ordenar vari\u00e1veis por temas. Tipos de vari\u00e1veis N\u00f3s utilizamos algumas das op\u00e7\u00f5es de tipos do BigQuery : string , int64 , float64 , date , time , geography . Quando escolher: string : Vari\u00e1veis de texto Chaves de vari\u00e1veis categ\u00f3ricas com dicion\u00e1rio ou diret\u00f3rio int64 : Vari\u00e1veis de n\u00fameros inteiros com as quais \u00e9 poss\u00edvel fazer contas (adi\u00e7\u00e3o, subtra\u00e7\u00e3o) Vari\u00e1veis do tipo booleanas que preenchemos com 0 ou 1 float64 : Vari\u00e1veis de n\u00fameros com casas decimais com as quais \u00e9 poss\u00edvel fazer contas (adi\u00e7\u00e3o, subtra\u00e7\u00e3o) date : Vari\u00e1veis de data no formato YYYY-MM-DD time : Vari\u00e1veis de tempo no formato HH:MM:SS geography : Vari\u00e1veis de geografia Unidades de medida A regra \u00e9 manter vari\u00e1veis com suas unidades de medida originais listadas nesse c\u00f3digo , com a exce\u00e7\u00e3o de vari\u00e1veis financeiras onde convertermos moedas antigas para as atuais (e.g. Cruzeiro para Real). Catalogamos unidades de medida em formato padr\u00e3o na tabela de arquitetura. Lista completa aqui Exemplos: m , km/h , BRL . Para colunas financeiras deflacionadas, listamos a moeda com o ano base. Exemplo: uma coluna medida em reais de 2010 tem unidade BRL_2010 . Vari\u00e1veis devem ter sempre unidades de medida com base 1. Ou seja, ter BRL ao inv\u00e9s de 1000 BRL , ou pessoa ao inv\u00e9s de 1000 pessoas . Essa informa\u00e7\u00e3o, como outros metadados de colunas, s\u00e3o registradas na tabela de arquitetura da tabela. Quais vari\u00e1veis manter, quais adicionar e quais remover Mantemos nossas tabelas parcialmente normalizadas , e temos regras para quais vari\u00e1veis incluirmos em produ\u00e7\u00e3o. Elas s\u00e3o: Remover vari\u00e1veis de nomes de entidades que j\u00e1 est\u00e3o em diret\u00f3rios. Exemplo: retirar municipio da tabela que j\u00e1 inclui id_municipio . Remover vari\u00e1veis servindo de parti\u00e7\u00e3o. Exemplo: remover ano e sigla_uf se a tabela \u00e9 particionada nessas duas dimens\u00f5es. Adicionar chaves prim\u00e1rias principais para cada entidade j\u00e1 existente. Exemplo: adicionar id_municipio a tabelas que s\u00f3 incluem id_municipio_tse . Manter todas as chaves prim\u00e1rias que j\u00e1 vem com a tabela, mas (1) adicionar chaves relevantes (e.g. sigla_uf , id_municipio ) e (2) retirar chaves irrelevantes (e.g. regiao ). Cobertura temporal Preencher a coluna cobertura_temporal nos metadados de tabela, coluna e chave (em dicion\u00e1rios) segue o seguinte padr\u00e3o. Formato geral: data_inicial(unidade_temporal)data_final data_inicial e data_final est\u00e3o na correspondente unidade temporal. Exemplo: tabela com unidade ano tem cobertura 2005(1)2018 . Exemplo: tabela com unidade mes tem cobertura 2005-08(1)2018-12 . Exemplo: tabela com unidade semana tem cobertura 2005-08-01(7)2018-08-31 . Exemplo: tabela com unidade dia tem cobertura 2005-08-01(1)2018-12-31 . Regras para preenchimento Metadados de tabela Preencher no formato geral. Metadados de coluna Preencher no formato geral, exceto quando a data_inicial ou data_final sejam iguais aos da tabela. Nesse caso deixe vazio. Exemplo: suponha que a cobertura da tabela seja 2005(1)2018 . Se uma coluna aparece s\u00f3 em 2012 e existe at\u00e9 2018, preenchemos sua cobertura como 2012(1) . Se uma coluna desaparece em 2013, preenchemos sua cobertura como (1)2013 . Se uma coluna existe na mesma cobertura temporal da tabela, preenchemos sua cobertura como (1) . Metadados de chave Preencher no mesmo padr\u00e3o de colunas, mas a refer\u00eancia sendo a coluna correspondente, e n\u00e3o a tabela. Limpando STRINGs Vari\u00e1veis categ\u00f3ricas: inicial mai\u00fascula e resto min\u00fasculo, com acentos. STRINGs n\u00e3o-estruturadas: manter igual aos dados originais. Formatos de valores Decimal: formato americano, i.e. sempre . (ponto) ao inv\u00e9s de , (v\u00edrgula). Data: YYYY-MM-DD Hor\u00e1rio (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Valor nulo: \"\" (csv), NULL (Python), NA (R), . ou \"\" (Stata) Propor\u00e7\u00e3o/porcentagem: entre 0-100 Particionamento de tabelas O que \u00e9 particionamento e qual seu objetivo ? De forma resumida, particionar uma tabela \u00e9 dividi-la em v\u00e1rios blocos/partes. O objetivo central \u00e9 diminuir os custos financeiros e aumentar a perfomance, visto que, quanto maior o volume de dados, consequentemente ser\u00e1 maior o custo de armazenamento e consulta. A redu\u00e7\u00e3o de custos e o aumento de perfomance acontece, principalmente, porque a parti\u00e7\u00e3o permite a reorganiza\u00e7\u00e3o do conjunto de dados em pequenos blocos agrupados . Na pr\u00e1tica, realizando o particionamento, \u00e9 poss\u00edvel evitar que uma consulta percorra toda a tabela s\u00f3 para trazer um pequeno recorte de dados. Um exemplo pr\u00e1tico da nossa querida RAIS: Sem utilizar filtro de parti\u00e7\u00e3o: Para esse caso o Bigquery varreu todas (*) as colunas e linhas do conjunto. Vale salientar que esse custo ainda n\u00e3o \u00e9 t\u00e3o grande, visto que a base j\u00e1 foi particionada. Caso esse conjunto n\u00e3o tivesse passado pelo processo de particionamento, essa consulta custaria muito mais dinheiro e tempo, j\u00e1 que se trata de um volume consider\u00e1vel de dados. Com filtro de parti\u00e7\u00e3o: Aqui, filtramos pelas colunas particionadas ano e sigla_uf . Dessa forma, o Bigquery s\u00f3 consulta e retorna os valores da pasta ano e da subpasta sigla_uf . Quando particionar uma tabela? A primeira pergunta que surge quando se trata de particionamento \u00e9: a partir de qual quantidade de linhas uma tabela deve ser particionada? A documenta\u00e7\u00e3o do GCP n\u00e3o define uma quantidade x ou y de linhas que deve ser particionada. O ideal \u00e9 que as tabelas sejam particionadas, com poucas exce\u00e7\u00f5es. Por exemplo, tabelas com menos de 10.000 linhas, que n\u00e3o receber\u00e3o mais ingest\u00e3o de dados, n\u00e3o tem um custo de armazenamento e processamento altos e, portanto, n\u00e3o h\u00e1 necessidade de serem particionadas. Como particionar uma tabela? Se os dados est\u00e3o guardados localmente, \u00e9 necess\u00e1rio: Criar as pastas particionadas na sua pasta de /output , na linguagem que voc\u00ea estiver utilizando. Exemplo de uma tabela particionada por ano e mes , utilizando python : for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: particao = output + f 'table_id/ano= { ano } /mes= { mes } ' if not os . path . exists ( particao ): os . makedirs ( particao ) 2. Salvar os arquivos particionados. for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: df_particao = df [ df [ 'ano' ] == ano ] . copy () # O .copy n\u00e3o \u00e9 necess\u00e1rio \u00e9 apenas uma boa pr\u00e1tica df_particao = df_particao [ df_particao [ 'mes' ] == mes ] df_particao . drop ([ 'ano' , 'mes' ], axis = 1 , inplace = True ) # \u00c9 preciso excluir as colunas utilizadas para parti\u00e7\u00e3o particao = output + f 'table_id/ano= { ano } /mes= { mes } /tabela.csv' df_particao . to_csv ( particao , index = False , encoding = 'utf-8' , na_rep = '' ) Exemplos de tabelas particionadas em R : PNADC PAM Exemplo de como particionar uma tabela em SQL : CREATE TABLE ` dataset_id . table_id ` as ( ano INT64 , mes INT64 , col1 STRING , col1 STRING ) PARTITION BY ano , mes OPTIONS ( Description = 'Descri\u00e7\u00e3o da tabela' ) Regras importantes de particionamento. Os tipos de colunas que o BigQuery aceita como parti\u00e7\u00e3o s\u00e3o: Coluna de unidade de tempo : as tabelas s\u00e3o particionadas com base em uma coluna de TIMESTAMP , DATE ou DATETIME . Tempo de processamento : as tabelas s\u00e3o particionadas com base no carimbo de data/hora quando o BigQuery processa os dados. Intervalo de n\u00fameros inteiros : as tabelas s\u00e3o particionadas com base em uma coluna de n\u00fameros inteiros. Os tipos de colunas que o BigQuery n\u00e3o aceita como parti\u00e7\u00e3o s\u00e3o: BOOL , FLOAT64 , BYTES , etc. O BigQuery aceita no m\u00e1ximo 4.000 parti\u00e7\u00f5es por tabela. Aqui na BD as tabelas geralmente s\u00e3o particionadas por: ano , mes , trimestre e sigla_uf . Note que ao particionar uma tabela \u00e9 preciso excluir a coluna correspondente. Exemplo: \u00e9 preciso excluir a coluna ano ao particionar por ano . N\u00famero de bases por pull request Pull requests no Github devem incluir no m\u00e1ximo um conjunto, mas pode incluir mais de uma base. Ou seja, podem envolver uma ou mais tabela dentro do mesmo conjunto. Dicion\u00e1rios Cada base inclui somente um dicion\u00e1rio (que cobre uma ou mais tabelas). Para cada tabela, coluna, e cobertura temporal, cada chave mapeia unicamente um valor. Chaves n\u00e3o podem ter valores nulos. Dicion\u00e1rios devem cobrir todas as chaves dispon\u00edveis nas tabelas originais. Chaves s\u00f3 podem possuir zeros \u00e0 esquerda quando o n\u00famero de d\u00edgitos da vari\u00e1vel tiver significado. Quando a vari\u00e1vel for enum padr\u00e3o, n\u00f3s excluimos os zeros \u00e0 esquerda. Exemplo: mantemos o zero \u00e0 esquerda da vari\u00e1vel br_bd_diretorios_brasil.cbo_2002:cbo_2002 , que tem seis d\u00edgitos, pois o primeiro d\u00edgito 0 significa a categoria ser do grande grupo = \"Membros das for\u00e7as armadas, policiais e bombeiros militares\" . Para outros casos, como por exemplo br_inep_censo_escolar.turma:etapa_ensino , n\u00f3s excluimos os zeros \u00e0 esquerda. Ou seja, mudamos 01 para 1 . Valores s\u00e3o padronizados: sem espa\u00e7os extras, inicial mai\u00fascula e resto min\u00fasculo, etc. Como preencher os metadados da tabela dicion\u00e1rio? N\u00e3o preencher o spatial_coverage ( cobertura_espacial ), ou seja, deixar o campo vazio. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ), ou seja, deixar o campo vazio. N\u00e3o preencher o observation_level ( nivel_observacao ), ou seja, deixar o campo vazio. Diret\u00f3rios Diret\u00f3rios s\u00e3o as pedras fundamentais da estrutura do nosso datalake . Nossas regras para gerenciar diret\u00f3rios s\u00e3o: Diret\u00f3rios representam entidades do reposit\u00f3rio que tenham chaves prim\u00e1rias (e.g. uf , munic\u00edpio , escola ) e unidades de data-tempo (e.g. data , tempo , dia , mes , ano ). Cada tabela de diret\u00f3rio tem ao menos uma chave prim\u00e1ria com valores \u00fanicos e sem nulos. Exemplos: municipio:id_municipio , uf:sigla_uf . Nomes de vari\u00e1veis com prefixo id_ s\u00e3o reservadas para chaves prim\u00e1rias de entidades. Veja todas as tabelas j\u00e1 dispon\u00edveis aqui. Como preencher os metadados das tabelas de diret\u00f3rio? Preencher o spatial_coverage ( cobertura_espacial ), que \u00e9 a m\u00e1xima unidade espacial que a tabela cobre. Exemplo: sa.br, que significa que o n\u00edvel de agrega\u00e7\u00e3o espacial da tabela \u00e9 o Brasil. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ), ou seja, deixar o campo vazio. Preencher o observation_level ( nivel_observacao ), que consiste no n\u00edvel de observa\u00e7\u00e3o da tabela, ou seja, o que representa cada linha. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ) das colunas da tabela, ou seja, deixar o campo vazio. Fontes Originais O campo se refere aos dados na fonte original, que ainda n\u00e3o passaram pela metodologia de tratamento da Base dos Dados, ou seja, nosso _input_ . Ao clicar nele, a ideia \u00e9 redirecionar o usu\u00e1rio para a p\u00e1gina da fonte original dos dados. As regras para gerenciar as Fontes Originais s\u00e3o: Incluir o nome do link externo que leva \u00e0 fonte original. Como padr\u00e3o, esse nome deve ser da organiza\u00e7\u00e3o ou do portal que armazenena os dados. Exemplos: Sinopses Estat\u00edsticas da Educa\u00e7\u00e3o B\u00e1sica: Dados Abertos do Inep , Penn World Tables: Groningen Growth and Development Centre . Preencher os metadados de Fontes Originais: Descri\u00e7\u00e3o, URL, L\u00edngua, Tem Dados Estruturados, Tem uma API, \u00c9 de Gra\u00e7a, Requer Registro, Disponibilidade, Requer IP de Algum Pa\u00eds, Tipo de Licen\u00e7a, Cobertura Temporal, Cobertura Espacial e N\u00edvel da Observa\u00e7\u00e3o. Pensou em melhorias para os padr\u00f5es definidos? Abra um issue no nosso Github ou mande uma mensagem no Discord para conversarmos :)","title":"Manual de estilo"},{"location":"style_data/#manual-de-estilo","text":"Nessa se\u00e7\u00e3o listamos todos os padr\u00f5es do nosso manual de estilo e diretrizes de dados que usamos na Base dos Dados. Eles nos ajudam a manter os dados e metadados que publicamos com qualidade alta. Voc\u00ea pode usar o menu esquerdo para navegar pelos diferentes t\u00f3picos dessa p\u00e1gina.","title":"Manual de estilo"},{"location":"style_data/#nomeacao-de-bases-e-tabelas","text":"","title":"Nomea\u00e7\u00e3o de bases e tabelas"},{"location":"style_data/#conjuntos-de-dados-dataset_id","text":"Nomeamos conjuntos no formato <organization_id\\>_<descri\u00e7\u00e3o\\> , onde organization_id segue por padr\u00e3o a abrang\u00eancia geogr\u00e1fica da organiza\u00e7\u00e3o que publica o conjunto: organization_id Mundial mundo_<organizacao> Federal <sigla_pais>_<organizacao> Estadual <sigla_pais>_<sigla_uf>_<organizacao> Municipal <sigla_pais>_<sigla_uf>_<cidade>_<organizacao> sigla_pais e sigla_uf s\u00e3o sempre 2 letras min\u00fasculas; organizacao \u00e9 o nome ou sigla (de prefer\u00eancia) da organiza\u00e7\u00e3o que publicou os dados orginais (ex: ibge , tse , inep ). descricao \u00e9 uma breve descri\u00e7\u00e3o do conjunto de dados, que pode ser Por exemplo, o conjunto de dados do PIB do IBGE tem como dataset_id : br_ibge_pib N\u00e3o sabe como nomear a organiza\u00e7\u00e3o? Sugerimos que v\u00e1 no site da mesma e veja como ela se autodenomina (ex: DETRAN-RJ seria br_rj_detran )","title":"Conjuntos de dados (dataset_id)"},{"location":"style_data/#tabelas","text":"Nomear tabelas \u00e9 algo menos estruturado e, por isso, requer bom senso. Mas temos algumas regras: Se houver tabelas para diferentes entidades, incluir a entidade no come\u00e7o do nome. Exemplo: municipio_valor , uf_valor . N\u00e3o incluir a unidade temporal no nome. Exemplo: nomear municipio , e n\u00e3o municipio_ano . Deixar nomes no singular. Exemplo: escola , e n\u00e3o escolas . Nomear de microdados as tabelas mais desagregadas. Em geral essas tem dados a n\u00edvel de pessoa ou transa\u00e7\u00e3o.","title":"Tabelas"},{"location":"style_data/#exemplos-de-dataset_idtable_id","text":"Mundial mundo_waze.alertas Dados de alertas do Waze de diferentes cidades. Federal br_tse_eleicoes.candidatos Dados de candidatos a cargos pol\u00edticos do TSE. Federal br_ibge_pnad.microdados Microdados da Pesquisa Nacional por Amostra de Domic\u00edlios produzidos pelo IBGE. Federal br_ibge_pnadc.microdados Microdados da Pesquisa Nacional por Amostra de Domic\u00edlios Cont\u00ednua (PNAD-C) produzidos pelo IBGE. Estadual br_sp_see_docentes.carga_horaria Carga hor\u00e1ria anonimizado de docentes ativos da rede estadual de ensino de SP. Municipal br_rj_riodejaneiro_cmrj_legislativo.votacoes Dados de vota\u00e7\u00e3o da C\u00e2mara Municipal do Rio de Janeiro (RJ).","title":"Exemplos de dataset_id.table_id"},{"location":"style_data/#formatos-de-tabelas","text":"Tabelas devem, na medida do poss\u00edvel, estar no formato long , ao inv\u00e9s de wide .","title":"Formatos de tabelas"},{"location":"style_data/#nomeacao-de-variaveis","text":"Nomes de vari\u00e1veis devem respeitar algumas regras: Usar ao m\u00e1ximo nomes j\u00e1 presentes no reposit\u00f3rio. Exemplos: ano , mes , id_municipio , sigla_uf , idade , cargo , resultado , votos , receita , despesa , preco , etc. Respeitar padr\u00f5es das tabelas de diret\u00f3rios. Ser o mais intuitivo, claro e extenso poss\u00edvel. Ter todas letras min\u00fasculas (inclusive siglas), sem acentos, conectados por _ . N\u00e3o incluir conectores como de , da , dos , e , a , em , etc. S\u00f3 ter o prefixo id_ quando a vari\u00e1vel representar chaves prim\u00e1rias de entidades (que eventualmente teriam uma tabela de diret\u00f3rio). Exemplos que tem: id_municipio , id_uf , id_escola , id_pessoa . Exemplos que n\u00e3o tem: rede , localizacao . Importante : quando a base est\u00e1 em ingl\u00eas id vira um sufixo S\u00f3 ter sufixos de entidade quando a entidade da coluna for diferente da entidade da tabela. Exemplos que tem: numa tabela com entidade pessoa , uma coluna sobre PIB municipal se chamaria pib_municipio . Exemplos que n\u00e3o tem: numa tabela com entidade pessoa , caracter\u00edsticas da pessoa se chamariam nome , idade , sexo , etc. Lista de prefixos permitidos nome_ , data_ , quantidade_ , proporcao_ (vari\u00e1veis de porcentagem 0-100%), taxa_ , razao_ , indice_ , indicador_ (vari\u00e1veis do tipo booleano), tipo_ , sigla_ , sequencial_ . Lista de sufixos comuns _pc (per capita)","title":"Nomea\u00e7\u00e3o de vari\u00e1veis"},{"location":"style_data/#ordenamento-de-variaveis","text":"A ordem de vari\u00e1veis em tabelas \u00e9 padronizada para manter uma consist\u00eancia no reposit\u00f3rio. Nossas regras s\u00e3o: Chaves prim\u00e1rias \u00e0 esquerda, em ordem descendente de abrang\u00eancia; No meio devem estar vari\u00e1veis qualitativas da linha; As \u00faltimas vari\u00e1veis devem ser os valores quantitativos em ordem crescente de relev\u00e2ncia; Exemplo de ordem: ano , sigla_uf , id_municipio , id_escola , rede , nota_ideb ; Dependendo da tabela, pode ser recomendado agrupar e ordenar vari\u00e1veis por temas.","title":"Ordenamento de vari\u00e1veis"},{"location":"style_data/#tipos-de-variaveis","text":"N\u00f3s utilizamos algumas das op\u00e7\u00f5es de tipos do BigQuery : string , int64 , float64 , date , time , geography . Quando escolher: string : Vari\u00e1veis de texto Chaves de vari\u00e1veis categ\u00f3ricas com dicion\u00e1rio ou diret\u00f3rio int64 : Vari\u00e1veis de n\u00fameros inteiros com as quais \u00e9 poss\u00edvel fazer contas (adi\u00e7\u00e3o, subtra\u00e7\u00e3o) Vari\u00e1veis do tipo booleanas que preenchemos com 0 ou 1 float64 : Vari\u00e1veis de n\u00fameros com casas decimais com as quais \u00e9 poss\u00edvel fazer contas (adi\u00e7\u00e3o, subtra\u00e7\u00e3o) date : Vari\u00e1veis de data no formato YYYY-MM-DD time : Vari\u00e1veis de tempo no formato HH:MM:SS geography : Vari\u00e1veis de geografia","title":"Tipos de vari\u00e1veis"},{"location":"style_data/#unidades-de-medida","text":"A regra \u00e9 manter vari\u00e1veis com suas unidades de medida originais listadas nesse c\u00f3digo , com a exce\u00e7\u00e3o de vari\u00e1veis financeiras onde convertermos moedas antigas para as atuais (e.g. Cruzeiro para Real). Catalogamos unidades de medida em formato padr\u00e3o na tabela de arquitetura. Lista completa aqui Exemplos: m , km/h , BRL . Para colunas financeiras deflacionadas, listamos a moeda com o ano base. Exemplo: uma coluna medida em reais de 2010 tem unidade BRL_2010 . Vari\u00e1veis devem ter sempre unidades de medida com base 1. Ou seja, ter BRL ao inv\u00e9s de 1000 BRL , ou pessoa ao inv\u00e9s de 1000 pessoas . Essa informa\u00e7\u00e3o, como outros metadados de colunas, s\u00e3o registradas na tabela de arquitetura da tabela.","title":"Unidades de medida"},{"location":"style_data/#quais-variaveis-manter-quais-adicionar-e-quais-remover","text":"Mantemos nossas tabelas parcialmente normalizadas , e temos regras para quais vari\u00e1veis incluirmos em produ\u00e7\u00e3o. Elas s\u00e3o: Remover vari\u00e1veis de nomes de entidades que j\u00e1 est\u00e3o em diret\u00f3rios. Exemplo: retirar municipio da tabela que j\u00e1 inclui id_municipio . Remover vari\u00e1veis servindo de parti\u00e7\u00e3o. Exemplo: remover ano e sigla_uf se a tabela \u00e9 particionada nessas duas dimens\u00f5es. Adicionar chaves prim\u00e1rias principais para cada entidade j\u00e1 existente. Exemplo: adicionar id_municipio a tabelas que s\u00f3 incluem id_municipio_tse . Manter todas as chaves prim\u00e1rias que j\u00e1 vem com a tabela, mas (1) adicionar chaves relevantes (e.g. sigla_uf , id_municipio ) e (2) retirar chaves irrelevantes (e.g. regiao ).","title":"Quais vari\u00e1veis manter, quais adicionar e quais remover"},{"location":"style_data/#cobertura-temporal","text":"Preencher a coluna cobertura_temporal nos metadados de tabela, coluna e chave (em dicion\u00e1rios) segue o seguinte padr\u00e3o. Formato geral: data_inicial(unidade_temporal)data_final data_inicial e data_final est\u00e3o na correspondente unidade temporal. Exemplo: tabela com unidade ano tem cobertura 2005(1)2018 . Exemplo: tabela com unidade mes tem cobertura 2005-08(1)2018-12 . Exemplo: tabela com unidade semana tem cobertura 2005-08-01(7)2018-08-31 . Exemplo: tabela com unidade dia tem cobertura 2005-08-01(1)2018-12-31 . Regras para preenchimento Metadados de tabela Preencher no formato geral. Metadados de coluna Preencher no formato geral, exceto quando a data_inicial ou data_final sejam iguais aos da tabela. Nesse caso deixe vazio. Exemplo: suponha que a cobertura da tabela seja 2005(1)2018 . Se uma coluna aparece s\u00f3 em 2012 e existe at\u00e9 2018, preenchemos sua cobertura como 2012(1) . Se uma coluna desaparece em 2013, preenchemos sua cobertura como (1)2013 . Se uma coluna existe na mesma cobertura temporal da tabela, preenchemos sua cobertura como (1) . Metadados de chave Preencher no mesmo padr\u00e3o de colunas, mas a refer\u00eancia sendo a coluna correspondente, e n\u00e3o a tabela.","title":"Cobertura temporal"},{"location":"style_data/#limpando-strings","text":"Vari\u00e1veis categ\u00f3ricas: inicial mai\u00fascula e resto min\u00fasculo, com acentos. STRINGs n\u00e3o-estruturadas: manter igual aos dados originais.","title":"Limpando STRINGs"},{"location":"style_data/#formatos-de-valores","text":"Decimal: formato americano, i.e. sempre . (ponto) ao inv\u00e9s de , (v\u00edrgula). Data: YYYY-MM-DD Hor\u00e1rio (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Valor nulo: \"\" (csv), NULL (Python), NA (R), . ou \"\" (Stata) Propor\u00e7\u00e3o/porcentagem: entre 0-100","title":"Formatos de valores"},{"location":"style_data/#particionamento-de-tabelas","text":"","title":"Particionamento de tabelas"},{"location":"style_data/#o-que-e-particionamento-e-qual-seu-objetivo","text":"De forma resumida, particionar uma tabela \u00e9 dividi-la em v\u00e1rios blocos/partes. O objetivo central \u00e9 diminuir os custos financeiros e aumentar a perfomance, visto que, quanto maior o volume de dados, consequentemente ser\u00e1 maior o custo de armazenamento e consulta. A redu\u00e7\u00e3o de custos e o aumento de perfomance acontece, principalmente, porque a parti\u00e7\u00e3o permite a reorganiza\u00e7\u00e3o do conjunto de dados em pequenos blocos agrupados . Na pr\u00e1tica, realizando o particionamento, \u00e9 poss\u00edvel evitar que uma consulta percorra toda a tabela s\u00f3 para trazer um pequeno recorte de dados. Um exemplo pr\u00e1tico da nossa querida RAIS: Sem utilizar filtro de parti\u00e7\u00e3o: Para esse caso o Bigquery varreu todas (*) as colunas e linhas do conjunto. Vale salientar que esse custo ainda n\u00e3o \u00e9 t\u00e3o grande, visto que a base j\u00e1 foi particionada. Caso esse conjunto n\u00e3o tivesse passado pelo processo de particionamento, essa consulta custaria muito mais dinheiro e tempo, j\u00e1 que se trata de um volume consider\u00e1vel de dados. Com filtro de parti\u00e7\u00e3o: Aqui, filtramos pelas colunas particionadas ano e sigla_uf . Dessa forma, o Bigquery s\u00f3 consulta e retorna os valores da pasta ano e da subpasta sigla_uf .","title":"O que \u00e9 particionamento e qual seu objetivo ?"},{"location":"style_data/#quando-particionar-uma-tabela","text":"A primeira pergunta que surge quando se trata de particionamento \u00e9: a partir de qual quantidade de linhas uma tabela deve ser particionada? A documenta\u00e7\u00e3o do GCP n\u00e3o define uma quantidade x ou y de linhas que deve ser particionada. O ideal \u00e9 que as tabelas sejam particionadas, com poucas exce\u00e7\u00f5es. Por exemplo, tabelas com menos de 10.000 linhas, que n\u00e3o receber\u00e3o mais ingest\u00e3o de dados, n\u00e3o tem um custo de armazenamento e processamento altos e, portanto, n\u00e3o h\u00e1 necessidade de serem particionadas.","title":"Quando particionar uma tabela?"},{"location":"style_data/#como-particionar-uma-tabela","text":"Se os dados est\u00e3o guardados localmente, \u00e9 necess\u00e1rio: Criar as pastas particionadas na sua pasta de /output , na linguagem que voc\u00ea estiver utilizando. Exemplo de uma tabela particionada por ano e mes , utilizando python : for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: particao = output + f 'table_id/ano= { ano } /mes= { mes } ' if not os . path . exists ( particao ): os . makedirs ( particao ) 2. Salvar os arquivos particionados. for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: df_particao = df [ df [ 'ano' ] == ano ] . copy () # O .copy n\u00e3o \u00e9 necess\u00e1rio \u00e9 apenas uma boa pr\u00e1tica df_particao = df_particao [ df_particao [ 'mes' ] == mes ] df_particao . drop ([ 'ano' , 'mes' ], axis = 1 , inplace = True ) # \u00c9 preciso excluir as colunas utilizadas para parti\u00e7\u00e3o particao = output + f 'table_id/ano= { ano } /mes= { mes } /tabela.csv' df_particao . to_csv ( particao , index = False , encoding = 'utf-8' , na_rep = '' ) Exemplos de tabelas particionadas em R : PNADC PAM Exemplo de como particionar uma tabela em SQL : CREATE TABLE ` dataset_id . table_id ` as ( ano INT64 , mes INT64 , col1 STRING , col1 STRING ) PARTITION BY ano , mes OPTIONS ( Description = 'Descri\u00e7\u00e3o da tabela' )","title":"Como particionar uma tabela?"},{"location":"style_data/#regras-importantes-de-particionamento","text":"Os tipos de colunas que o BigQuery aceita como parti\u00e7\u00e3o s\u00e3o: Coluna de unidade de tempo : as tabelas s\u00e3o particionadas com base em uma coluna de TIMESTAMP , DATE ou DATETIME . Tempo de processamento : as tabelas s\u00e3o particionadas com base no carimbo de data/hora quando o BigQuery processa os dados. Intervalo de n\u00fameros inteiros : as tabelas s\u00e3o particionadas com base em uma coluna de n\u00fameros inteiros. Os tipos de colunas que o BigQuery n\u00e3o aceita como parti\u00e7\u00e3o s\u00e3o: BOOL , FLOAT64 , BYTES , etc. O BigQuery aceita no m\u00e1ximo 4.000 parti\u00e7\u00f5es por tabela. Aqui na BD as tabelas geralmente s\u00e3o particionadas por: ano , mes , trimestre e sigla_uf . Note que ao particionar uma tabela \u00e9 preciso excluir a coluna correspondente. Exemplo: \u00e9 preciso excluir a coluna ano ao particionar por ano .","title":"Regras importantes de particionamento."},{"location":"style_data/#numero-de-bases-por-pull-request","text":"Pull requests no Github devem incluir no m\u00e1ximo um conjunto, mas pode incluir mais de uma base. Ou seja, podem envolver uma ou mais tabela dentro do mesmo conjunto.","title":"N\u00famero de bases por pull request"},{"location":"style_data/#dicionarios","text":"Cada base inclui somente um dicion\u00e1rio (que cobre uma ou mais tabelas). Para cada tabela, coluna, e cobertura temporal, cada chave mapeia unicamente um valor. Chaves n\u00e3o podem ter valores nulos. Dicion\u00e1rios devem cobrir todas as chaves dispon\u00edveis nas tabelas originais. Chaves s\u00f3 podem possuir zeros \u00e0 esquerda quando o n\u00famero de d\u00edgitos da vari\u00e1vel tiver significado. Quando a vari\u00e1vel for enum padr\u00e3o, n\u00f3s excluimos os zeros \u00e0 esquerda. Exemplo: mantemos o zero \u00e0 esquerda da vari\u00e1vel br_bd_diretorios_brasil.cbo_2002:cbo_2002 , que tem seis d\u00edgitos, pois o primeiro d\u00edgito 0 significa a categoria ser do grande grupo = \"Membros das for\u00e7as armadas, policiais e bombeiros militares\" . Para outros casos, como por exemplo br_inep_censo_escolar.turma:etapa_ensino , n\u00f3s excluimos os zeros \u00e0 esquerda. Ou seja, mudamos 01 para 1 . Valores s\u00e3o padronizados: sem espa\u00e7os extras, inicial mai\u00fascula e resto min\u00fasculo, etc.","title":"Dicion\u00e1rios"},{"location":"style_data/#como-preencher-os-metadados-da-tabela-dicionario","text":"N\u00e3o preencher o spatial_coverage ( cobertura_espacial ), ou seja, deixar o campo vazio. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ), ou seja, deixar o campo vazio. N\u00e3o preencher o observation_level ( nivel_observacao ), ou seja, deixar o campo vazio.","title":"Como preencher os metadados da tabela dicion\u00e1rio?"},{"location":"style_data/#diretorios","text":"Diret\u00f3rios s\u00e3o as pedras fundamentais da estrutura do nosso datalake . Nossas regras para gerenciar diret\u00f3rios s\u00e3o: Diret\u00f3rios representam entidades do reposit\u00f3rio que tenham chaves prim\u00e1rias (e.g. uf , munic\u00edpio , escola ) e unidades de data-tempo (e.g. data , tempo , dia , mes , ano ). Cada tabela de diret\u00f3rio tem ao menos uma chave prim\u00e1ria com valores \u00fanicos e sem nulos. Exemplos: municipio:id_municipio , uf:sigla_uf . Nomes de vari\u00e1veis com prefixo id_ s\u00e3o reservadas para chaves prim\u00e1rias de entidades. Veja todas as tabelas j\u00e1 dispon\u00edveis aqui.","title":"Diret\u00f3rios"},{"location":"style_data/#como-preencher-os-metadados-das-tabelas-de-diretorio","text":"Preencher o spatial_coverage ( cobertura_espacial ), que \u00e9 a m\u00e1xima unidade espacial que a tabela cobre. Exemplo: sa.br, que significa que o n\u00edvel de agrega\u00e7\u00e3o espacial da tabela \u00e9 o Brasil. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ), ou seja, deixar o campo vazio. Preencher o observation_level ( nivel_observacao ), que consiste no n\u00edvel de observa\u00e7\u00e3o da tabela, ou seja, o que representa cada linha. N\u00e3o preencher o temporal_coverage ( cobertura_temporal ) das colunas da tabela, ou seja, deixar o campo vazio.","title":"Como preencher os metadados das tabelas de diret\u00f3rio?"},{"location":"style_data/#fontes-originais","text":"O campo se refere aos dados na fonte original, que ainda n\u00e3o passaram pela metodologia de tratamento da Base dos Dados, ou seja, nosso _input_ . Ao clicar nele, a ideia \u00e9 redirecionar o usu\u00e1rio para a p\u00e1gina da fonte original dos dados. As regras para gerenciar as Fontes Originais s\u00e3o: Incluir o nome do link externo que leva \u00e0 fonte original. Como padr\u00e3o, esse nome deve ser da organiza\u00e7\u00e3o ou do portal que armazenena os dados. Exemplos: Sinopses Estat\u00edsticas da Educa\u00e7\u00e3o B\u00e1sica: Dados Abertos do Inep , Penn World Tables: Groningen Growth and Development Centre . Preencher os metadados de Fontes Originais: Descri\u00e7\u00e3o, URL, L\u00edngua, Tem Dados Estruturados, Tem uma API, \u00c9 de Gra\u00e7a, Requer Registro, Disponibilidade, Requer IP de Algum Pa\u00eds, Tipo de Licen\u00e7a, Cobertura Temporal, Cobertura Espacial e N\u00edvel da Observa\u00e7\u00e3o.","title":"Fontes Originais"},{"location":"style_data/#pensou-em-melhorias-para-os-padroes-definidos","text":"Abra um issue no nosso Github ou mande uma mensagem no Discord para conversarmos :)","title":"Pensou em melhorias para os padr\u00f5es definidos?"},{"location":"tutorial_join_tables/","text":"Como cruzar tabelas no datalake Organizamos os dados de forma que o cruzamento de tabelas de diferentes intitui\u00e7\u00f5es e temas seja t\u00e3o simples quanto qualquer outra consulta. Para isso, definimos uma metodologia padr\u00e3o para tratamento dos dados, nomea\u00e7\u00e3o de colunas, tabelas e conjuntos. Como funciona a metolodiga BD? Alguma frase sobre .... Para saber mais, leia a documenta\u00e7\u00e3o sobre tratamento e arquitetura de dados. Informa\u00e7\u00f5es de diferentes tabelas podem ser agregadas por meiode chaves identificadora . Uma chave identificadora \u00e9 uma coluna cujo nome \u00e9 \u00fanico em todas as tabelas do data lake e \u00e9 utilizada para identificar uma entidade. Exemplo de chave identificadora A coluna ano tem esse mesmo nome em todas as tabelas do data lake - ela sempre se refere a vari\u00e1vel que tem como valor quaisquer anos do nosso calend\u00e1rio. Quando vamos trabalhar com dados de popula\u00e7\u00e3o do IBGE, a coluna ano , junto com a coluna municipio , identificam unicamente cada linha da tabela: N\u00e3o existe mais de uma linha com o mesmo ano e munic\u00edpio; N\u00e3o existe linha com valor nulo de ano ou municipio na tabela; Teste voc\u00ea mesmo(a): as queries abaixo devem retornar vazio! R library ( \"basedosdados\" ) # Busca alguma linha que possui ano e munic\u00edpio repetido query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Busca linhas com ano ou municipio nulos query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Busca alguma linha que possui ano e munic\u00edpio repetido query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Busca linhas com ano ou municipio nulos query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ... Cruzando tabelas com chaves identificadoras A indica\u00e7\u00e3o de um conjunto de colunas como chave identificadora \u00e9 feita direto nos metadados da tabela. Assim, voc\u00ea pode saber quais tabelas podem ser cruzadas comparando o conjunto de chaves identificadoras de cada uma. Abaixo vamos fazer um exemplo de como cruzar as tabelas de popula\u00e7\u00e3o e PIB do IBGE para obter o PIB per capita de todos os munic\u00edpios brasileiros. Nas tabelas de popula\u00e7\u00e3o e PIB, a coluna ano e municipio s\u00e3o chaves identificadoras. Logo usaremos essas colunas na nossa fun\u00e7\u00e3o JOIN para determinar como cruzar as tabelas. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # Voc\u00ea pode fazer o download no seu computador dir <- tempdir () data <- download ( query , file.path ( dir , \"pib_per_capita.csv\" )) # Ou carregar o resultado da query no seu ambiente de an\u00e1lise data <- read_sql ( query ) Python import basedosdados as bd pib_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # Voc\u00ea pode fazer o download no seu computador bd . download ( query = pib_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # Ou carregar o resultado da query no pandas df = bd . read_sql ( pib_per_capita , billing_project_id =< YOUR_PROJECT_ID > ) Lista de chaves identificadoras Chaves geogr\u00e1ficas Setor censit\u00e1rio: id_setor_censitario Munic\u00edpio: id_municipio (padr\u00e3o), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb \u00c1rea M\u00ednima Compar\u00e1vel: id_AMC Regi\u00e3o imediata: id_regiao_imediata Regi\u00e3o intermedi\u00e1ria: id_regiao_intermediaria Microrregi\u00e3o: id_microrregiao Mesorregi\u00e3o: id_mesorregiao Unidade da federa\u00e7\u00e3o (UF): sigla_uf (padr\u00e3o), id_uf , uf Regi\u00e3o: regiao Chaves temporais ano , semestre , mes , semana , dia , hora Chaves de pessoas f\u00edsicas cpf , pis , nis Chaves de pessoas jur\u00eddicas Empresa: cnpj Escola: id_escola Chaves em pol\u00edtica Candidato(a): id_candidato_bd Partido: sigla_partido , partido","title":"Como cruzar tabelas no datalake"},{"location":"tutorial_join_tables/#como-cruzar-tabelas-no-datalake","text":"Organizamos os dados de forma que o cruzamento de tabelas de diferentes intitui\u00e7\u00f5es e temas seja t\u00e3o simples quanto qualquer outra consulta. Para isso, definimos uma metodologia padr\u00e3o para tratamento dos dados, nomea\u00e7\u00e3o de colunas, tabelas e conjuntos. Como funciona a metolodiga BD? Alguma frase sobre .... Para saber mais, leia a documenta\u00e7\u00e3o sobre tratamento e arquitetura de dados. Informa\u00e7\u00f5es de diferentes tabelas podem ser agregadas por meiode chaves identificadora . Uma chave identificadora \u00e9 uma coluna cujo nome \u00e9 \u00fanico em todas as tabelas do data lake e \u00e9 utilizada para identificar uma entidade.","title":"Como cruzar tabelas no datalake"},{"location":"tutorial_join_tables/#exemplo-de-chave-identificadora","text":"A coluna ano tem esse mesmo nome em todas as tabelas do data lake - ela sempre se refere a vari\u00e1vel que tem como valor quaisquer anos do nosso calend\u00e1rio. Quando vamos trabalhar com dados de popula\u00e7\u00e3o do IBGE, a coluna ano , junto com a coluna municipio , identificam unicamente cada linha da tabela: N\u00e3o existe mais de uma linha com o mesmo ano e munic\u00edpio; N\u00e3o existe linha com valor nulo de ano ou municipio na tabela; Teste voc\u00ea mesmo(a): as queries abaixo devem retornar vazio! R library ( \"basedosdados\" ) # Busca alguma linha que possui ano e munic\u00edpio repetido query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Busca linhas com ano ou municipio nulos query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Busca alguma linha que possui ano e munic\u00edpio repetido query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Busca linhas com ano ou municipio nulos query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ...","title":"Exemplo de chave identificadora"},{"location":"tutorial_join_tables/#cruzando-tabelas-com-chaves-identificadoras","text":"A indica\u00e7\u00e3o de um conjunto de colunas como chave identificadora \u00e9 feita direto nos metadados da tabela. Assim, voc\u00ea pode saber quais tabelas podem ser cruzadas comparando o conjunto de chaves identificadoras de cada uma. Abaixo vamos fazer um exemplo de como cruzar as tabelas de popula\u00e7\u00e3o e PIB do IBGE para obter o PIB per capita de todos os munic\u00edpios brasileiros. Nas tabelas de popula\u00e7\u00e3o e PIB, a coluna ano e municipio s\u00e3o chaves identificadoras. Logo usaremos essas colunas na nossa fun\u00e7\u00e3o JOIN para determinar como cruzar as tabelas. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # Voc\u00ea pode fazer o download no seu computador dir <- tempdir () data <- download ( query , file.path ( dir , \"pib_per_capita.csv\" )) # Ou carregar o resultado da query no seu ambiente de an\u00e1lise data <- read_sql ( query ) Python import basedosdados as bd pib_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # Voc\u00ea pode fazer o download no seu computador bd . download ( query = pib_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # Ou carregar o resultado da query no pandas df = bd . read_sql ( pib_per_capita , billing_project_id =< YOUR_PROJECT_ID > )","title":"Cruzando tabelas com chaves identificadoras"},{"location":"tutorial_join_tables/#lista-de-chaves-identificadoras","text":"","title":"Lista de chaves identificadoras"},{"location":"tutorial_join_tables/#chaves-geograficas","text":"Setor censit\u00e1rio: id_setor_censitario Munic\u00edpio: id_municipio (padr\u00e3o), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb \u00c1rea M\u00ednima Compar\u00e1vel: id_AMC Regi\u00e3o imediata: id_regiao_imediata Regi\u00e3o intermedi\u00e1ria: id_regiao_intermediaria Microrregi\u00e3o: id_microrregiao Mesorregi\u00e3o: id_mesorregiao Unidade da federa\u00e7\u00e3o (UF): sigla_uf (padr\u00e3o), id_uf , uf Regi\u00e3o: regiao","title":"Chaves geogr\u00e1ficas"},{"location":"tutorial_join_tables/#chaves-temporais","text":"ano , semestre , mes , semana , dia , hora","title":"Chaves temporais"},{"location":"tutorial_join_tables/#chaves-de-pessoas-fisicas","text":"cpf , pis , nis","title":"Chaves de pessoas f\u00edsicas"},{"location":"tutorial_join_tables/#chaves-de-pessoas-juridicas","text":"Empresa: cnpj Escola: id_escola","title":"Chaves de pessoas jur\u00eddicas"},{"location":"tutorial_join_tables/#chaves-em-politica","text":"Candidato(a): id_candidato_bd Partido: sigla_partido , partido","title":"Chaves em pol\u00edtica"},{"location":"en/","text":"Hello, world! Data Basis' mission is to universalize the use of quality data worldwide. For this, we created a tool that allows you to access important resources from various public datasets , such as: Processed Tables : Complete tables, already processed and ready for analysis, available in our public datalake. Original Data : Links with useful information to explore more about the dataset, such as the original source and others. We have a Data team and volunteers from all over Brazil and abroad who help clean and maintain processed tables. Learn how to be part of it . Accessing DB processed tables On our website you'll find the list of all processed tables for each dataset. We also present important information about all tables, such as the list of columns, temporal coverage, periodicity, among other information. You can query the table data via: Download You can download the complete CSV file of the table directly from the website. This type of query is not available for files exceeding 200 thousand rows. BigQuery (SQL) BigQuery is Google's cloud database service. Directly from your browser, you can query the processed tables with: Speed: Even very long queries take only minutes to process. Scale: BigQuery magically scales to hexabytes if needed. Economy: Every user has 1 TB free per month for querying the data . Learn More Packages Base dos Dados packages allow access to the public data lake directly from your computer or development environment. The currently available packages are: Python R Stata Learn More Tips for better data usage Our data team constantly works on developing better standards and methodologies to facilitate the data analysis process. We've separated some useful materials for you to better understand what we do and how to make the best use of the data: Join tables from different organizations quickly Understand patterns of tables, datasets and variables","title":"Home"},{"location":"en/#hello-world","text":"Data Basis' mission is to universalize the use of quality data worldwide. For this, we created a tool that allows you to access important resources from various public datasets , such as: Processed Tables : Complete tables, already processed and ready for analysis, available in our public datalake. Original Data : Links with useful information to explore more about the dataset, such as the original source and others. We have a Data team and volunteers from all over Brazil and abroad who help clean and maintain processed tables. Learn how to be part of it .","title":"Hello, world!"},{"location":"en/#accessing-db-processed-tables","text":"On our website you'll find the list of all processed tables for each dataset. We also present important information about all tables, such as the list of columns, temporal coverage, periodicity, among other information. You can query the table data via:","title":"Accessing DB processed tables"},{"location":"en/#download","text":"You can download the complete CSV file of the table directly from the website. This type of query is not available for files exceeding 200 thousand rows.","title":"Download"},{"location":"en/#bigquery-sql","text":"BigQuery is Google's cloud database service. Directly from your browser, you can query the processed tables with: Speed: Even very long queries take only minutes to process. Scale: BigQuery magically scales to hexabytes if needed. Economy: Every user has 1 TB free per month for querying the data . Learn More","title":"BigQuery (SQL)"},{"location":"en/#packages","text":"Base dos Dados packages allow access to the public data lake directly from your computer or development environment. The currently available packages are: Python R Stata Learn More","title":"Packages"},{"location":"en/#tips-for-better-data-usage","text":"Our data team constantly works on developing better standards and methodologies to facilitate the data analysis process. We've separated some useful materials for you to better understand what we do and how to make the best use of the data: Join tables from different organizations quickly Understand patterns of tables, datasets and variables","title":"Tips for better data usage"},{"location":"en/access_data_bq/","text":"BigQuery BigQuery is Google's cloud database service. You can query the database using SQL directly in your browser with: Speed : Even very long queries take only minutes to process. Scale : BigQuery magically scales to hexabytes if needed. Economy : Every user gets 1 TB free per month for querying data . Ready to start? On this page you'll find: Getting Started Understanding BigQuery's Free Usage Tutorials SQL Manuals and Courses Getting Started Before starting: Create your Google Cloud project To create a Google Cloud project, you just need an email registered with Google. You need to have your own project, even if empty, to make queries in our public datalake . Access Google Cloud . If it's your first time, accept the Terms of Service. Click on Create Project . Choose a nice name for the project. Click on Create Why do I need to create a Google Cloud project? Google provides 1 TB free per month of BigQuery usage for each project you own. A project is necessary to activate Google Cloud services, including BigQuery usage permission. Think of the project as the \"account\" where Google will track how much processing you've already used. You don't need to add any card or payment method - BigQuery automatically starts in Sandbox mode, which allows you to use its resources without adding a payment method. Read more here . Accessing the basedosdados datalake The button below will direct you to our project in Google BigQuery: Go to BigQuery Now you need to pin the DB project in your BigQuery, it's quite simple, see: !!! Warning The Pin a project option may also appear as Star project by name Within the project there are two levels of data organization, datasets and tables , where: All tables are organized within datasets , which represent their organization/theme (e.g., the dataset br_ibge_populacao contains a municipio table with the historical population series at municipal level) Each table belongs to a single dataset (e.g., the municipio table in br_ibge_populacao is different from municipio in br_bd_diretorios ) See Google's guide on how the BigQuery interface works here . If tables don't appear the first time you access, refresh the page. Make your first query! How about making a simple query? Let's use the BigQuery Query Editor to see information about municipalities directly in our Brazilian directories database. To do this, copy and paste the code below: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` Just click Run and you're done! Tip By clicking the \ud83d\udd0d Query Table button, BigQuery automatically creates the basic structure of your query in the Query Editor - you just need to complete it with the fields and filters you find necessary. Understanding BigQuery's Free Usage This section is dedicated to presenting tips on how to reduce processing costs to maximize the data from BD! For users who access data in public projects like the BD, the only type of cost associated is the cost of processing queries . The good news, as mentioned above, is that every user gets 1 TB free per month for querying data . If you still don't have a project in BQ, consult the section above to create one. Knowing the basics of the BQ interface is important for understanding the article. If you don't have familiariadade or want to revisit the interface, we recommend 3 tracks: Our guide using the RAIS - Annual Relation of Information Society tables Our collection of videos on YouTube The introduction to the interface done by Google See how to maximize the benefits of free queries In this section, we present some simple tips to reduce the costs of queries in Big Query and maximize the data from BD! Before moving on to the examples, we'll introduce the basic mechanism for predicting query processing costs in Big Query (BQ). Cost estimates In the upper right corner of the BQ interface, there's a notice with an estimate of the processing cost that will be charged to your project after the query execution. This is the basic and readily accessible mechanism for predictability of processing costs. Unfortunately, it doesn't work for all tables. Due to limitations within Big Query itself, queries to specific tables don't display cost estimates. This is the case of tables with Row Access Policy . This means that the number of accessible rows is limited depending on the user. This is the case of tables that are part of the BD Pro service Example of the agencia table from the br_bcb_estban dataset. { width=100% } TIP 1: Select only the columns of interest The Big Query architecture uses column-oriented storage, meaning that each column is stored separately. This characteristic has a clear implication regarding processing costs: the more columns are selected, the higher the cost. Avoid : Selecting too many columns SELECT * Recommended practice : select only the columns of interest to reduce the final cost of the query. SELECT coluna1 , coluna2 - See the difference obtained with the table microdados from the br_ms_sim set. Without column selection: estimated cost 5.83 GB Selecting 3 columns: estimated cost 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` To understand the columnar architecture in depth, consult the official Big Query documentation TIP 2: Use partitioned and clustered columns to filter data Partitions are divisions made in a table to facilitate data management and query. During query execution, Big Query ignores rows that have a partition value different from the one used in the filter. This usually significantly reduces the number of rows read and, what we're interested in, reduces the processing cost. Clusters are organized groups in a table based on the values of one or more specified columns. During query execution, Big Query optimizes data reading, accessing only the segments that contain the relevant values of the cluster columns. This means that instead of scanning the entire table, only the necessary parts are read, which generally reduces the amount of processed data and, consequently, reduces the processing cost. How to know which column was used to partition and cluster a specific table? By the metadata on the table page on the BD website Note that the Partitions in Big Query lists both partitions and clusters. By the metadata on the 'Details' page in Big Query Note that both partitions and clusters are listed. In this case, the column ano was defined as a partition and the column sigla_uf as a cluster. Recommended practice : always try to use partitioned and clustered columns to filter/aggregate data. Example Query used with a partitioned column as a filter: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 estimated cost : 31.32 MB. The combination of column selection techniques and filtering using partition reduced the estimated cost from the initial query of 5.83 GB to only 31.32 MB TIP 3: Pay close attention when performing joins between tables Evaluate the real need for JOIN Make sure the join is really necessary for the analysis you're performing. Sometimes, alternative operations like subqueries or aggregations can be more efficient. Understand the JOIN logic Different types of joins (INNER, LEFT, RIGHT, FULL) have different implications for performance and result. Taking a moment to understand the best option for your analysis goal can help you have more efficient cost control. One of the most common problems is the multiplication of unwanted rows in the final result. To understand the full picture of good practices and common issues with joins, we recommend the guides SQL Joins in Practice and Maximizing Efficiency with JOIN in SQL Queries to Combine Tables Use the tips above Select only the columns of interest Use the partitioned columns to filter the data Pay attention to cost estimates before executing the query Tutorials How to navigate BigQuery To understand more about the BigQuery interface and how to explore the data, we prepared a complete text in the blog with an example of searching for data from the RAIS - Ministry of Economy . Tired of reading? We also have a complete video on our YouTube . Understand the data BigQuery has a search mechanism that allows you to search by datasets (sets), tables (tables), or labels (groups). We created simple naming rules and practices to facilitate your search - see more . Understand the use of BigQuery (BQ) for free Connecting with PowerBI Power BI is one of the most popular technologies for developing dashboards with relational data. That's why we prepared a tutorial for you to discover how to use the datalake data in the development of your dashboards . SQL Manuals and Courses We're starting to learn about SQL to make our queries? Below we provide some recommendations used by our team both in learning and in everyday life: List of SQL functions in W3 SQL Course on Codeacademy SQL Course from Dynamic Programming","title":"BigQuery"},{"location":"en/access_data_bq/#bigquery","text":"BigQuery is Google's cloud database service. You can query the database using SQL directly in your browser with: Speed : Even very long queries take only minutes to process. Scale : BigQuery magically scales to hexabytes if needed. Economy : Every user gets 1 TB free per month for querying data . Ready to start? On this page you'll find: Getting Started Understanding BigQuery's Free Usage Tutorials SQL Manuals and Courses","title":"BigQuery"},{"location":"en/access_data_bq/#getting-started","text":"","title":"Getting Started"},{"location":"en/access_data_bq/#before-starting-create-your-google-cloud-project","text":"To create a Google Cloud project, you just need an email registered with Google. You need to have your own project, even if empty, to make queries in our public datalake . Access Google Cloud . If it's your first time, accept the Terms of Service. Click on Create Project . Choose a nice name for the project. Click on Create Why do I need to create a Google Cloud project? Google provides 1 TB free per month of BigQuery usage for each project you own. A project is necessary to activate Google Cloud services, including BigQuery usage permission. Think of the project as the \"account\" where Google will track how much processing you've already used. You don't need to add any card or payment method - BigQuery automatically starts in Sandbox mode, which allows you to use its resources without adding a payment method. Read more here .","title":"Before starting: Create your Google Cloud project"},{"location":"en/access_data_bq/#accessing-the-basedosdados-datalake","text":"The button below will direct you to our project in Google BigQuery: Go to BigQuery Now you need to pin the DB project in your BigQuery, it's quite simple, see: !!! Warning The Pin a project option may also appear as Star project by name Within the project there are two levels of data organization, datasets and tables , where: All tables are organized within datasets , which represent their organization/theme (e.g., the dataset br_ibge_populacao contains a municipio table with the historical population series at municipal level) Each table belongs to a single dataset (e.g., the municipio table in br_ibge_populacao is different from municipio in br_bd_diretorios ) See Google's guide on how the BigQuery interface works here . If tables don't appear the first time you access, refresh the page.","title":"Accessing the basedosdados datalake"},{"location":"en/access_data_bq/#make-your-first-query","text":"How about making a simple query? Let's use the BigQuery Query Editor to see information about municipalities directly in our Brazilian directories database. To do this, copy and paste the code below: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` Just click Run and you're done! Tip By clicking the \ud83d\udd0d Query Table button, BigQuery automatically creates the basic structure of your query in the Query Editor - you just need to complete it with the fields and filters you find necessary.","title":"Make your first query!"},{"location":"en/access_data_bq/#understanding-bigquerys-free-usage","text":"This section is dedicated to presenting tips on how to reduce processing costs to maximize the data from BD! For users who access data in public projects like the BD, the only type of cost associated is the cost of processing queries . The good news, as mentioned above, is that every user gets 1 TB free per month for querying data . If you still don't have a project in BQ, consult the section above to create one. Knowing the basics of the BQ interface is important for understanding the article. If you don't have familiariadade or want to revisit the interface, we recommend 3 tracks: Our guide using the RAIS - Annual Relation of Information Society tables Our collection of videos on YouTube The introduction to the interface done by Google","title":"Understanding BigQuery's Free Usage"},{"location":"en/access_data_bq/#see-how-to-maximize-the-benefits-of-free-queries","text":"In this section, we present some simple tips to reduce the costs of queries in Big Query and maximize the data from BD! Before moving on to the examples, we'll introduce the basic mechanism for predicting query processing costs in Big Query (BQ). Cost estimates In the upper right corner of the BQ interface, there's a notice with an estimate of the processing cost that will be charged to your project after the query execution. This is the basic and readily accessible mechanism for predictability of processing costs. Unfortunately, it doesn't work for all tables. Due to limitations within Big Query itself, queries to specific tables don't display cost estimates. This is the case of tables with Row Access Policy . This means that the number of accessible rows is limited depending on the user. This is the case of tables that are part of the BD Pro service Example of the agencia table from the br_bcb_estban dataset. { width=100% }","title":"See how to maximize the benefits of free queries"},{"location":"en/access_data_bq/#tip-1-select-only-the-columns-of-interest","text":"The Big Query architecture uses column-oriented storage, meaning that each column is stored separately. This characteristic has a clear implication regarding processing costs: the more columns are selected, the higher the cost. Avoid : Selecting too many columns SELECT * Recommended practice : select only the columns of interest to reduce the final cost of the query. SELECT coluna1 , coluna2 - See the difference obtained with the table microdados from the br_ms_sim set. Without column selection: estimated cost 5.83 GB Selecting 3 columns: estimated cost 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` To understand the columnar architecture in depth, consult the official Big Query documentation","title":"TIP 1: Select only the columns of interest"},{"location":"en/access_data_bq/#tip-2-use-partitioned-and-clustered-columns-to-filter-data","text":"Partitions are divisions made in a table to facilitate data management and query. During query execution, Big Query ignores rows that have a partition value different from the one used in the filter. This usually significantly reduces the number of rows read and, what we're interested in, reduces the processing cost. Clusters are organized groups in a table based on the values of one or more specified columns. During query execution, Big Query optimizes data reading, accessing only the segments that contain the relevant values of the cluster columns. This means that instead of scanning the entire table, only the necessary parts are read, which generally reduces the amount of processed data and, consequently, reduces the processing cost. How to know which column was used to partition and cluster a specific table? By the metadata on the table page on the BD website Note that the Partitions in Big Query lists both partitions and clusters. By the metadata on the 'Details' page in Big Query Note that both partitions and clusters are listed. In this case, the column ano was defined as a partition and the column sigla_uf as a cluster. Recommended practice : always try to use partitioned and clustered columns to filter/aggregate data. Example Query used with a partitioned column as a filter: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 estimated cost : 31.32 MB. The combination of column selection techniques and filtering using partition reduced the estimated cost from the initial query of 5.83 GB to only 31.32 MB","title":"TIP 2: Use partitioned and clustered columns to filter data"},{"location":"en/access_data_bq/#tip-3-pay-close-attention-when-performing-joins-between-tables","text":"Evaluate the real need for JOIN Make sure the join is really necessary for the analysis you're performing. Sometimes, alternative operations like subqueries or aggregations can be more efficient. Understand the JOIN logic Different types of joins (INNER, LEFT, RIGHT, FULL) have different implications for performance and result. Taking a moment to understand the best option for your analysis goal can help you have more efficient cost control. One of the most common problems is the multiplication of unwanted rows in the final result. To understand the full picture of good practices and common issues with joins, we recommend the guides SQL Joins in Practice and Maximizing Efficiency with JOIN in SQL Queries to Combine Tables Use the tips above Select only the columns of interest Use the partitioned columns to filter the data Pay attention to cost estimates before executing the query","title":"TIP 3: Pay close attention when performing joins between tables"},{"location":"en/access_data_bq/#tutorials","text":"","title":"Tutorials"},{"location":"en/access_data_bq/#how-to-navigate-bigquery","text":"To understand more about the BigQuery interface and how to explore the data, we prepared a complete text in the blog with an example of searching for data from the RAIS - Ministry of Economy . Tired of reading? We also have a complete video on our YouTube .","title":"How to navigate BigQuery"},{"location":"en/access_data_bq/#understand-the-data","text":"BigQuery has a search mechanism that allows you to search by datasets (sets), tables (tables), or labels (groups). We created simple naming rules and practices to facilitate your search - see more .","title":"Understand the data"},{"location":"en/access_data_bq/#understand-the-use-of-bigquery-bq-for-free","text":"","title":"Understand the use of BigQuery (BQ) for free"},{"location":"en/access_data_bq/#connecting-with-powerbi","text":"Power BI is one of the most popular technologies for developing dashboards with relational data. That's why we prepared a tutorial for you to discover how to use the datalake data in the development of your dashboards .","title":"Connecting with PowerBI"},{"location":"en/access_data_bq/#sql-manuals-and-courses","text":"We're starting to learn about SQL to make our queries? Below we provide some recommendations used by our team both in learning and in everyday life: List of SQL functions in W3 SQL Course on Codeacademy SQL Course from Dynamic Programming","title":"SQL Manuals and Courses"},{"location":"en/access_data_packages/","text":"Packages Data Basis' packages allow access to the public datalake directly from your computer or development environment. Currently available in: Python R Stata CLI (terminal) Ready to start? On this page you'll find: Getting started Tutorials Reference manuals Getting started Before starting: Create your Google Cloud project To create a Google Cloud project, you just need an email registered with Google. You need to have your own project, even if empty, to make queries in our public datalake . Access Google Cloud . If it's your first time, accept the Terms of Service. Click on Create Project . Choose a nice name for the project. Click on Create Why do I need to create a Google Cloud project? Google provides 1 TB free per month of BigQuery usage for each project you own. A project is necessary to activate Google Cloud services, including BigQuery usage permission. Think of the project as the \"account\" in which Google will track how much processing you have already used. You don't need to add any card or payment method - BigQuery automatically starts in Sandbox mode, which allows you to use its resources without adding a payment method. Read more here . Installing the package To install the package in Python and command line, you can use pip directly from your terminal. In R, you can install directly in RStudio or editor of your preference. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimentos: Ensure your Stata is version 16+ Ensure Python is installed on your computer. Once the requirements are met, run the following commands: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" ) Configuring the package Once you have your project, you need to configure the package to use the ID of that project in queries to the datalake . To do this, you must use the project_id that Google provides for you when the project is created. Python/CLI You don't need to configure the project beforehand. As soon as you run your first query, the package will indicate the steps to configure. R Once you have the project_id , you must pass this information to the package using the set_billing_id function. set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata You need to specify the project_id every time you use the package. Make your first query A simple example to start exploring the datalake is to pull information cadastral of municipalities directly from our base of Brazilian Directories (table municipio ) . To do this, we will use the function download , downloading the data directly to our machine. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) To understand more about the download function, read the reference manual . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) To understand more about the download function, read the reference manual . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' To understand more about the download function, read the reference manual . Tutorials How to use the packages We prepared tutorials presenting the main functions of each package for you to start using them. Python Blog: Introduction to the Python package Introduction to the Python package (cont.) V\u00eddeos: Workshop: Python applications R Blog: Introduction to the R package Exploring the Brazilian School Census Brazil in the Olympics V\u00eddeos: Workshop: Learn how to access public data in R Stata Documentation: GitHub Reference manuals (API) Python R Stata CLI","title":"Packages"},{"location":"en/access_data_packages/#packages","text":"Data Basis' packages allow access to the public datalake directly from your computer or development environment. Currently available in: Python R Stata CLI (terminal) Ready to start? On this page you'll find: Getting started Tutorials Reference manuals","title":"Packages"},{"location":"en/access_data_packages/#getting-started","text":"","title":"Getting started"},{"location":"en/access_data_packages/#before-starting-create-your-google-cloud-project","text":"To create a Google Cloud project, you just need an email registered with Google. You need to have your own project, even if empty, to make queries in our public datalake . Access Google Cloud . If it's your first time, accept the Terms of Service. Click on Create Project . Choose a nice name for the project. Click on Create Why do I need to create a Google Cloud project? Google provides 1 TB free per month of BigQuery usage for each project you own. A project is necessary to activate Google Cloud services, including BigQuery usage permission. Think of the project as the \"account\" in which Google will track how much processing you have already used. You don't need to add any card or payment method - BigQuery automatically starts in Sandbox mode, which allows you to use its resources without adding a payment method. Read more here .","title":"Before starting: Create your Google Cloud project"},{"location":"en/access_data_packages/#installing-the-package","text":"To install the package in Python and command line, you can use pip directly from your terminal. In R, you can install directly in RStudio or editor of your preference. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimentos: Ensure your Stata is version 16+ Ensure Python is installed on your computer. Once the requirements are met, run the following commands: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" )","title":"Installing the package"},{"location":"en/access_data_packages/#configuring-the-package","text":"Once you have your project, you need to configure the package to use the ID of that project in queries to the datalake . To do this, you must use the project_id that Google provides for you when the project is created. Python/CLI You don't need to configure the project beforehand. As soon as you run your first query, the package will indicate the steps to configure. R Once you have the project_id , you must pass this information to the package using the set_billing_id function. set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata You need to specify the project_id every time you use the package.","title":"Configuring the package"},{"location":"en/access_data_packages/#make-your-first-query","text":"A simple example to start exploring the datalake is to pull information cadastral of municipalities directly from our base of Brazilian Directories (table municipio ) . To do this, we will use the function download , downloading the data directly to our machine. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) To understand more about the download function, read the reference manual . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) To understand more about the download function, read the reference manual . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' To understand more about the download function, read the reference manual .","title":"Make your first query"},{"location":"en/access_data_packages/#tutorials","text":"","title":"Tutorials"},{"location":"en/access_data_packages/#how-to-use-the-packages","text":"We prepared tutorials presenting the main functions of each package for you to start using them. Python Blog: Introduction to the Python package Introduction to the Python package (cont.) V\u00eddeos: Workshop: Python applications R Blog: Introduction to the R package Exploring the Brazilian School Census Brazil in the Olympics V\u00eddeos: Workshop: Learn how to access public data in R Stata Documentation: GitHub","title":"How to use the packages"},{"location":"en/access_data_packages/#reference-manuals-api","text":"Python R Stata CLI","title":"Reference manuals (API)"},{"location":"en/api_reference_python/","text":"Python This API is composed of functions with two types of functionality: Modules for data request : for those who only want to consult the data and metadata of our project. Classes for data management in Google Cloud: for those who want to upload data to our project (or any other project in Google Cloud, following our methodology and infrastructure). Modules (Data requests) Functions to get metadata from BD's API check_input ( f ) Checks if the number of inputs is valid Source code in basedosdados/download/metadata.py def check_input ( f ): \"\"\"Checks if the number of inputs is valid\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if sum ([ a is not None for a in args ]) > 1 : raise ValueError ( \"At most one of the inputs must be non null\" ) return f ( * args , ** kwargs ) return wrapper get_columns ( table_id = None , column_id = None , columns_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available columns, either by table_id , column_id or column_name Parameters: Name Type Description Default table_id(str) table slug in google big query (gbq). required column_id(str) column slug in google big query (gbq). required column_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_columns ( table_id : str = None , column_id : str = None , columns_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available columns, either by `table_id`, `column_id` or `column_name` Args: table_id(str): table slug in google big query (gbq). column_id(str): column slug in google big query (gbq). column_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" result = backend . get_columns ( table_id , column_id , columns_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"bigquery_type\" ] = item . pop ( \"bigqueryType\" , {}) . get ( \"name\" ) return result get_datasets ( dataset_id = None , dataset_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available datasets, either by dataset_id or dataset_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required dataset_name(str) dataset name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_datasets ( dataset_id : str = None , dataset_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available datasets, either by `dataset_id` or `dataset_name` Args: dataset_id(str): dataset slug in google big query (gbq). dataset_name(str): dataset name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets. \"\"\" result = backend . get_datasets ( dataset_id , dataset_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"organization\" ] = item . get ( \"organization\" , {}) . get ( \"name\" ) item [ \"tags\" ] = [ i . get ( \"name\" ) for i in item . get ( \"tags\" , {}) . get ( \"items\" )] item [ \"themes\" ] = [ i . get ( \"name\" ) for i in item . get ( \"themes\" , {}) . get ( \"items\" )] return result get_tables ( dataset_id = None , table_id = None , table_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available tables, either by dataset_id , table_id or table_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required table_id(str) table slug in google big query (gbq). required table_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_tables ( dataset_id : str = None , table_id : str = None , table_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available tables, either by `dataset_id`, `table_id` or `table_name` Args: dataset_id(str): dataset slug in google big query (gbq). table_id(str): table slug in google big query (gbq). table_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" return backend . get_tables ( dataset_id , table_id , table_name , page , page_size ) inject_backend ( f ) Inject backend instance if doesn't exists Source code in basedosdados/download/metadata.py def inject_backend ( f ): \"\"\"Inject backend instance if doesn't exists\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if \"backend\" not in kwargs : kwargs [ \"backend\" ] = Backend () return f ( * args , ** kwargs ) return wrapper search ( q = None , page = 1 , page_size = 10 , backend = None ) Search for datasets, querying all available metadata for the term q Parameters: Name Type Description Default q(str) search term. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets and metadata. Source code in basedosdados/download/metadata.py @check_input @inject_backend def search ( q : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Search for datasets, querying all available metadata for the term `q` Args: q(str): search term. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets and metadata. \"\"\" items = [] for item in backend . search ( q , page , page_size ) . get ( \"results\" , []): items . append ( { \"slug\" : item . get ( \"slug\" ), \"name\" : item . get ( \"name\" ), \"description\" : item . get ( \"description\" ), \"n_tables\" : item . get ( \"n_tables\" ), \"n_raw_data_sources\" : item . get ( \"n_raw_data_sources\" ), \"n_information_requests\" : item . get ( \"n_information_requests\" ), \"organization\" : { \"slug\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"slug\" ), \"name\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"name\" ), }, } ) return items Functions for managing downloads download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , compression = 'GZIP' ) Download table or query result from basedosdados BigQuery (or other). Using a query : download('select * from basedosdados.br_suporte.diretorio_municipios limit 10') Using dataset_id & table_id : download(dataset_id='br_suporte', table_id='diretorio_municipios') You can also add arguments to modify save parameters: download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|') Parameters: Name Type Description Default savepath str, pathlib.PosixPath savepath must be a file path. Only supports .csv . required query str Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. None dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. None table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. None billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional Number of rows. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False compression str Optional. Compression type. Only GZIP is available for now. 'GZIP' Exceptions: Type Description Exception If either table_id, dataset_id or query are empty. Source code in basedosdados/download/download.py def download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , compression = \"GZIP\" , ): \"\"\"Download table or query result from basedosdados BigQuery (or other). * Using a **query**: `download('select * from `basedosdados.br_suporte.diretorio_municipios` limit 10')` * Using **dataset_id & table_id**: `download(dataset_id='br_suporte', table_id='diretorio_municipios')` You can also add arguments to modify save parameters: `download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|')` Args: savepath (str, pathlib.PosixPath): savepath must be a file path. Only supports `.csv`. query (str): Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional Number of rows. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. compression (str): Optional. Compression type. Only `GZIP` is available for now. Raises: Exception: If either table_id, dataset_id or query are empty. \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( query is None ) and (( table_id is None ) or ( dataset_id is None )): raise BaseDosDadosException ( \"Either table_id, dataset_id or query should be filled.\" ) client = _google_client ( billing_project_id , from_file , reauth ) # makes sure that savepath is a filepath and not a folder savepath = _sets_savepath ( savepath ) # if query is not defined (so it won't be overwritten) and if # table is a view or external or if limit is specified, # convert it to a query. if not query and ( not _is_table ( client , dataset_id , table_id , query_project_id ) or limit ): query = f \"\"\" SELECT * FROM { query_project_id } . { dataset_id } . { table_id } \"\"\" if limit is not None : query += f \" limit { limit } \" if query : # sql queries produces anonymous tables, whose names # can be found within `job._properties` job = client [ \"bigquery\" ] . query ( query ) # views may take longer: wait for job to finish. _wait_for ( job ) dest_table = job . _properties [ \"configuration\" ][ \"query\" ][ \"destinationTable\" ] project_id = dest_table [ \"projectId\" ] dataset_id = dest_table [ \"datasetId\" ] table_id = dest_table [ \"tableId\" ] _direct_download ( client , dataset_id , table_id , savepath , project_id , compression ) read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Parameters: Name Type Description Default query sql Valid SQL Standard Query to basedosdados required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Args: query (sql): Valid SQL Standard Query to basedosdados billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) try : # Set a two hours timeout bigquery_storage_v1 . client . BigQueryReadClient . read_rows = partialmethod ( bigquery_storage_v1 . client . BigQueryReadClient . read_rows , timeout = 3600 * 2 , ) return read_gbq ( query , project_id = config . billing_project_id , use_bqstorage_api = use_bqstorage_api , credentials = _credentials ( from_file = config . from_file , reauth = reauth ), ) except GenericGBQException as e : if \"Reason: 403\" in str ( e ): raise BaseDosDadosAccessDeniedException from e if re . match ( \"Reason: 400 POST .* [Pp]roject[ ]*I[Dd]\" , str ( e )): raise BaseDosDadosInvalidProjectIDException from e raise except PyDataCredentialsError as e : raise BaseDosDadosAuthorizationException from e except ( OSError , ValueError ) as e : no_billing_id = \"Could not determine project ID\" in str ( e ) no_billing_id |= \"reading from stdin while output is captured\" in str ( e ) if no_billing_id : raise BaseDosDadosNoBillingProjectIDException from e raise read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using dataset_id and table_id. Parameters: Name Type Description Default dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. required table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional. Number of rows to read from table. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using dataset_id and table_id. Args: dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional. Number of rows to read from table. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( dataset_id is not None ) and ( table_id is not None ): query = f \"\"\" SELECT * FROM ` { query_project_id } . { dataset_id } . { table_id } `\"\"\" if limit is not None : query += f \" LIMIT { limit } \" else : raise BaseDosDadosException ( \"Both table_id and dataset_id should be filled.\" ) return read_sql ( query , billing_project_id = billing_project_id , from_file = from_file , reauth = reauth , use_bqstorage_api = use_bqstorage_api , ) Classes (Data management) Class for managing the files in cloud storage. Storage ( Base ) Manage files on Google Cloud Storage. Source code in basedosdados/upload/storage.py class Storage ( Base ): \"\"\" Manage files on Google Cloud Storage. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . bucket = self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_id = table_id . replace ( \"-\" , \"_\" ) @staticmethod def _resolve_partitions ( partitions ): if isinstance ( partitions , dict ): return \"/\" . join ( f \" { k } = { v } \" for k , v in partitions . items ()) + \"/\" if isinstance ( partitions , str ): if partitions . endswith ( \"/\" ): partitions = partitions [: - 1 ] # If there is no partition if len ( partitions ) == 0 : return \"\" # It should fail if there is folder which is not a partition try : # check if it fits rule { b . split ( \"=\" )[ 0 ]: b . split ( \"=\" )[ 1 ] for b in partitions . split ( \"/\" )} except IndexError as e : raise Exception ( f \"The path { partitions } is not a valid partition\" ) from e return partitions + \"/\" raise Exception ( f \"Partitions format or type not accepted: { partitions } \" ) def _build_blob_name ( self , filename , mode , partitions = None ): \"\"\" Builds the blob name. \"\"\" # table folder blob_name = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # add partition folder if partitions is not None : blob_name += self . _resolve_partitions ( partitions ) # add file name blob_name += filename return blob_name def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) copy_table ( self , source_bucket_name = 'basedosdados' , destination_bucket_name = None , mode = 'staging' , new_table_id = None ) Copies table from a source bucket to your bucket, sends request in batches. Parameters: Name Type Description Default source_bucket_name str The bucket name from which to copy data. You can change it to copy from other external bucket. 'basedosdados' destination_bucket_name str Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) None mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' new_table_id str Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. None Source code in basedosdados/upload/storage.py def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) delete_file ( self , filename , mode , partitions = None , not_found_ok = False ) Deletes file from path <bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename> . Parameters: Name Type Description Default filename str Name of the file to be deleted required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] required partitions str, pathlib.PosixPath, or dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None not_found_ok bool Optional. What to do if file not found False Source code in basedosdados/upload/storage.py def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) delete_table ( self , mode = 'staging' , bucket_name = None , not_found_ok = False ) Deletes a table from storage, sends request in batches. Parameters: Name Type Description Default mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' bucket_name str The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) None not_found_ok bool Optional. What to do if table not found False Source code in basedosdados/upload/storage.py def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) download ( self , filename = '*' , savepath = '.' , partitions = None , mode = 'staging' , if_not_exists = 'raise' ) Download files from Google Storage from path mode / dataset_id / table_id / partitions / filename and replicate folder hierarchy on save, There are 5 modes: * raw : should contain raw files from datasource * staging : should contain pre-treated files ready to upload to BiqQuery * header : should contain the header of the tables * auxiliary_files : should contain auxiliary files from eache table * architecture : should contain the architecture sheet of the tables You can also use the partitions argument to choose files from a partition Parameters: Name Type Description Default filename str Optional Specify which file to download. If \" \" , downloads all files within the bucket folder. Defaults to \" \". '*' savepath str Where you want to save the data on your computer. Must be a path to a directory. '.' partitions str, dict Optional If downloading a single file, use this to specify the partition path from which to download. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None mode str Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] 'staging' if_not_exists str Optional. What to do if data not found. 'raise' : Raises FileNotFoundError. 'pass' : Do nothing and exit the function 'raise' Exceptions: Type Description FileNotFoundError If the given path <mode>/<dataset_id>/<table_id>/<partitions>/<filename> could not be found or there are no files to download. Source code in basedosdados/upload/storage.py def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) init ( self , replace = False , very_sure = False ) Initializes bucket and folders. Folder should be: raw : that contains really raw data staging : preprocessed data ready to upload to BigQuery Parameters: Name Type Description Default replace bool Optional. Whether to replace if bucket already exists False very_sure bool Optional. Are you aware that everything is going to be erased if you replace the bucket? False Exceptions: Type Description Warning very_sure argument is still False. Source code in basedosdados/upload/storage.py def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) upload ( self , path , mode = 'all' , partitions = None , if_exists = 'raise' , chunk_size = None , ** upload_args ) Upload to storage at <bucket_name>/<mode>/<dataset_id>/<table_id> . You can: Add a single file setting path = <file_path> . Add a folder with multiple files setting path = <folder_path> . The folder should just contain the files and no folders. Add partitioned files setting path = <folder_path> . This folder must follow the hive partitioning scheme i.e. <table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv (ex: mytable/country=brasil/year=2020/mypart.csv ). Remember all files must follow a single schema. Otherwise, things might fail in the future. There are 6 modes: raw : should contain raw files from datasource staging : should contain pre-treated files ready to upload to BiqQuery header : should contain the header of the tables auxiliary_files : should contain auxiliary files from eache table architecture : should contain the architecture sheet of the tables all : if no treatment is needed, use all . Parameters: Name Type Description Default path str or pathlib.PosixPath Where to find the file or folder that you want to upload to storage required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] 'all' partitions str, pathlib.PosixPath, or dict Optional. If adding a single file , use this to add it to a specific partition. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str Optional. What to do if data exists 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None upload_args Extra arguments accepted by google.cloud.storage.blob.Blob.upload_from_file {} Source code in basedosdados/upload/storage.py def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) Module for manage dataset to the server. Dataset ( Base ) Manage datasets in BigQuery. Source code in basedosdados/upload/dataset.py class Dataset ( Base ): \"\"\" Manage datasets in BigQuery. \"\"\" def __init__ ( self , dataset_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) @property @lru_cache def dataset_config ( self ): \"\"\" Dataset config file. \"\"\" return self . backend . get_dataset_config ( self . dataset_id ) def _loop_modes ( self , mode = \"all\" ): \"\"\" Loop modes. \"\"\" def dataset_tag ( m ): return f \"_ { m } \" if m == \"staging\" else \"\" mode = [ \"prod\" , \"staging\" ] if mode == \"all\" else [ mode ] return ( { \"client\" : self . client [ f \"bigquery_ { m } \" ], \"id\" : f \" { self . client [ f 'bigquery_ { m } ' ] . project } . { self . dataset_id }{ dataset_tag ( m ) } \" , \"mode\" : m , } for m in mode ) def _setup_dataset_object ( self , dataset_id , location = None , mode = \"staging\" ): \"\"\" Setup dataset object. \"\"\" dataset = bigquery . Dataset ( dataset_id ) if mode == \"staging\" : dataset_path = dataset_id . replace ( \"_staging\" , \"\" ) description = f \"staging dataset for ` { dataset_path } `\" labels = { \"staging\" : True } else : try : description = self . dataset_config . get ( \"descriptionPt\" , \"\" ) labels = { tag . get ( \"namePt\" ): True for tag in self . dataset_config . get ( \"tags\" ) } except BaseException : logger . warning ( f \"dataset { dataset_id } does not have a description in the API.\" ) description = \"description not available in the API.\" labels = {} dataset . description = description dataset . labels = labels dataset . location = location return dataset def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) dataset_config property readonly Dataset config file. create ( self , mode = 'all' , if_exists = 'raise' , dataset_is_public = True , location = None ) Creates BigQuery datasets given dataset_id . It can create two datasets: <dataset_id> (mode = 'prod') <dataset_id>_staging (mode = 'staging') If mode is all, it creates both. Parameters: Name Type Description Default mode str Optional. Which dataset to create [prod|staging|all]. 'all' if_exists str Optional. What to do if dataset exists raise : Raises Conflict exception replace : Drop all tables and replace dataset update : Update dataset description pass : Do nothing 'raise' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Exceptions: Type Description Warning Dataset already exists and if_exists is set to raise Source code in basedosdados/upload/dataset.py def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e delete ( self , mode = 'all' ) Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Parameters: Name Type Description Default mode str Optional. Which dataset to delete [prod|staging|all] 'all' Source code in basedosdados/upload/dataset.py def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) exists ( self , mode = 'staging' ) Check if dataset exists. Source code in basedosdados/upload/dataset.py def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) publicize ( self , mode = 'all' , dataset_is_public = True ) Changes IAM configuration to turn BigQuery dataset public. Parameters: Name Type Description Default mode bool Which dataset to create [prod|staging|all]. 'all' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True Source code in basedosdados/upload/dataset.py def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) update ( self , mode = 'all' , location = None ) Update dataset description. Toogle mode to choose which dataset to update. Parameters: Name Type Description Default mode str Optional. Which dataset to update [prod|staging|all] 'all' location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Source code in basedosdados/upload/dataset.py def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) Class for manage tables in Storage and Big Query Table ( Base ) Manage tables in Google Cloud Storage and BigQuery. Source code in basedosdados/upload/table.py class Table ( Base ): \"\"\" Manage tables in Google Cloud Storage and BigQuery. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . table_id = table_id . replace ( \"-\" , \"_\" ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_full_name = dict ( prod = f \" { self . client [ 'bigquery_prod' ] . project } . { self . dataset_id } . { self . table_id } \" , staging = f \" { self . client [ 'bigquery_staging' ] . project } . { self . dataset_id } _staging. { self . table_id } \" , ) self . table_full_name . update ( dict ( all = deepcopy ( self . table_full_name ))) @property @lru_cache ( 256 ) def table_config ( self ): \"\"\" Load table config \"\"\" # return self._load_yaml(self.table_folder / \"table_config.yaml\") return self . backend . get_table_config ( self . dataset_id , self . table_id ) def _get_table_obj ( self , mode ): \"\"\" Get table object from BigQuery \"\"\" return self . client [ f \"bigquery_ { mode } \" ] . get_table ( self . table_full_name [ mode ]) def _is_partitioned ( self , data_sample_path = None , source_format = None , csv_delimiter = None ): if data_sample_path is not None : table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) else : table_columns = self . _get_columns_metadata_from_api () return bool ( table_columns . get ( \"partition_columns\" , [])) def _load_schema_from_json ( self , columns = None , ): schema = [] for col in columns : # ref: https://cloud.google.com/python/docs/reference/bigquery/latest/google.cloud.bigquery.schema.SchemaField if col . get ( \"name\" ) is None : msg = \"Columns must have a name! Check your data files for columns without name\" raise BaseDosDadosException ( msg ) schema . append ( SchemaField ( name = col . get ( \"name\" ), field_type = col . get ( \"type\" ), description = col . get ( \"description\" , None ), ) ) return schema def _load_staging_schema_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" ): \"\"\" Generate schema from columns metadata in data sample \"\"\" if self . table_exists ( mode = \"staging\" ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) return self . _load_schema_from_json ( columns = table_columns . get ( \"columns\" )) def _load_schema_from_bq ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" table_columns = self . _get_columns_from_bq () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _load_schema_from_api ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" if self . table_exists ( mode = mode ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_metadata_from_api () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _get_columns_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" , mode = \"staging\" , ): # sourcery skip: low-code-quality \"\"\" Get the partition columns from the structure of data_sample_path. Args: data_sample_path (str, pathlib.PosixPath): Optional. Data sample path to auto complete columns names It supports Comma Delimited CSV, Apache Avro and Apache Parquet. source_format (str): Optional Data source format. Only 'csv', 'avro' and 'parquet' are supported. Defaults to 'csv'. \"\"\" partition_columns = [] if isinstance ( data_sample_path , ( str , Path , ), ): # Check if partitioned and get data sample and partition columns data_sample_path = Path ( data_sample_path ) if data_sample_path . is_dir (): data_sample_path = [ f for f in data_sample_path . glob ( \"**/*\" ) if f . is_file () and f . suffix == f \". { source_format } \" ][ 0 ] partition_columns = [ k . split ( \"=\" )[ 0 ] for k in data_sample_path . as_posix () . split ( \"/\" ) if \"=\" in k ] columns = Datatype ( source_format = source_format ) . header ( data_sample_path = data_sample_path , csv_delimiter = csv_delimiter ) return { \"columns\" : [{ \"name\" : col , \"type\" : \"STRING\" } for col in columns ], \"partition_columns\" : [ { \"name\" : col , \"type\" : \"STRING\" } for col in partition_columns ], } def _get_columns_metadata_from_api ( self , ): \"\"\" Get columns and partition columns from API. \"\"\" table_columns = self . table_config . get ( \"columns\" , {}) columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is False ] partition_columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is True ] return { \"columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in columns ], \"partition_columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in partition_columns ], } def _parser_blobs_to_partition_dict ( self ) -> dict : \"\"\" Extracts the partition information from the blobs. \"\"\" if not self . table_exists ( mode = \"staging\" ): return blobs = ( self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) . list_blobs ( prefix = f \"staging/ { self . dataset_id } / { self . table_id } /\" ) ) partitions_dict = {} # only needs the first bloob for blob in blobs : for folder in blob . name . split ( \"/\" ): if \"=\" in folder : key = folder . split ( \"=\" )[ 0 ] value = folder . split ( \"=\" ) try : partitions_dict [ key ] . append ( value ) except KeyError : partitions_dict [ key ] = [ value ] return partitions_dict def _get_columns_from_bq ( self , mode = \"staging\" ): if not self . table_exists ( mode = mode ): msg = f \"Table { self . dataset_id } . { self . table_id } does not exist in { mode } , please create first!\" raise logger . error ( msg ) else : schema = self . _get_table_obj ( mode = mode ) . schema partition_dict = self . _parser_blobs_to_partition_dict () if partition_dict : partition_columns = list ( partition_dict . keys ()) else : partition_columns = [] return { \"columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name not in partition_columns ], \"partition_columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name in partition_columns ], } def _get_cross_columns_from_bq_api ( self ): bq = self . _get_columns_from_bq ( mode = \"staging\" ) bq_columns = bq . get ( \"partition_columns\" ) + bq . get ( \"columns\" ) api = self . _get_columns_metadata_from_api () api_columns = api . get ( \"partition_columns\" ) + api . get ( \"columns\" ) if api_columns != []: for bq_col in bq_columns : for api_col in api_columns : if bq_col . get ( \"name\" ) == api_col . get ( \"name\" ): bq_col [ \"type\" ] = api_col . get ( \"type\" ) bq_col [ \"description\" ] = api_col . get ( \"description\" ) return bq_columns def _make_publish_sql ( self ): \"\"\"Create publish.sql with columns and bigquery_type\"\"\" # publish.sql header and instructions publish_txt = \"\"\" /* Query para publicar a tabela. Esse \u00e9 o lugar para: - modificar nomes, ordem e tipos de colunas - dar join com outras tabelas - criar colunas extras (e.g. logs, propor\u00e7\u00f5es, etc.) Qualquer coluna definida aqui deve tamb\u00e9m existir em `table_config.yaml`. # Al\u00e9m disso, sinta-se \u00e0 vontade para alterar alguns nomes obscuros # para algo um pouco mais expl\u00edcito. TIPOS: - Para modificar tipos de colunas, basta substituir STRING por outro tipo v\u00e1lido. - Exemplo: `SAFE_CAST(column_name AS NUMERIC) column_name` - Mais detalhes: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types */ \"\"\" # table_columns = self._get_columns_from_api(mode=\"staging\") columns = self . _get_cross_columns_from_bq_api () # remove triple quotes extra space publish_txt = inspect . cleandoc ( publish_txt ) publish_txt = textwrap . dedent ( publish_txt ) # add create table statement project_id_prod = self . client [ \"bigquery_prod\" ] . project publish_txt += f \" \\n\\n CREATE OR REPLACE VIEW { project_id_prod } . { self . dataset_id } . { self . table_id } AS \\n SELECT \\n \" # sort columns by is_partition, partitions_columns come first # add columns in publish.sql for col in columns : name = col . get ( \"name\" ) bigquery_type = ( \"STRING\" if col . get ( \"type\" ) is None else col . get ( \"type\" ) . upper () ) publish_txt += f \"SAFE_CAST( { name } AS { bigquery_type } ) { name } , \\n \" # remove last comma publish_txt = publish_txt [: - 2 ] + \" \\n \" # add from statement project_id_staging = self . client [ \"bigquery_staging\" ] . project publish_txt += ( f \"FROM { project_id_staging } . { self . dataset_id } _staging. { self . table_id } AS t\" ) return publish_txt def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) def _get_biglake_connection ( self , set_biglake_connection_permissions = True , location = None , mode = \"staging\" ): connection = Connection ( name = \"biglake\" , location = location , mode = \"staging\" ) if not connection . exists : try : logger . info ( \"Creating BigLake connection...\" ) connection . create () logger . success ( \"BigLake connection created!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc if set_biglake_connection_permissions : try : logger . info ( \"Setting permissions for BigLake service account...\" ) connection . set_biglake_permissions () logger . success ( \"Permissions set successfully!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc return connection def _get_table_description ( self , mode = \"staging\" ): \"\"\"Adds table description to BigQuery table. Args: table_obj (google.cloud.bigquery.table.Table): Table object. mode (str): Which dataset to check [prod|staging]. \"\"\" table_path = self . table_full_name [ \"prod\" ] if mode == \"staging\" : description = f \"staging table for ` { table_path } `\" else : try : description = self . table_config . get ( \"descriptionPt\" , \"\" ) except BaseException : logger . warning ( f \"table { self . table_id } does not have a description in the API.\" ) description = \"description not available in the API.\" return description def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , ) def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) table_config property readonly Load table config append ( self , filepath , partitions = None , if_exists = 'replace' , chunk_size = None , ** upload_args ) Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Parameters: Name Type Description Default filepath str or pathlib.PosixPath Where to find the file that you want to upload to create a table with required partitions str, pathlib.PosixPath, dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str 0ptional. What to do if data with same name exists in storage 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'replace' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None Source code in basedosdados/upload/table.py def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) create ( self , path = None , source_format = 'csv' , csv_delimiter = ',' , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = 'raise' , if_storage_data_exists = 'raise' , if_dataset_exists = 'pass' , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True ) Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at <dataset_id>_staging.<table_id> in BigQuery. Data can be found in Storage at <bucket_name>/staging/<dataset_id>/<table_id>/* and is used to build the table. The following data types are supported: Comma-Delimited CSV Apache Avro Apache Parquet Data can also be partitioned following the Hive partitioning scheme <key1>=<value1>/<key2>=<value2> ; for example, year=2012/country=BR . The partition is automatically detected by searching for partitions in the table_config.yaml file. Parameters: Name Type Description Default path str or pathlib.PosixPath The path to the file to be uploaded to create the table. None source_format str Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. 'csv' csv_delimiter str Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. ',' csv_skip_leading_rows(int) Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. required csv_allow_jagged_rows bool Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. False if_table_exists str Optional. Determines what to do if the table already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_storage_data_exists str Optional. Determines what to do if the data already exists on your bucket: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_dataset_exists str Optional. Determines what to do if the dataset already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the dataset 'pass' : Does nothing 'pass' dataset_is_public bool Optional. Controls if the prod dataset is public or not. By default, staging datasets like dataset_id_staging are not public. True location str Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None chunk_size int Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None biglake_table bool Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. False set_biglake_connection_permissions bool Optional. If set to True , attempts to grant the BigLake connection service account access to the table's data in GCS. True Source code in basedosdados/upload/table.py def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None delete ( self , mode = 'all' ) Deletes table in BigQuery. Parameters: Name Type Description Default mode str Table of which table to delete [prod|staging] 'all' Source code in basedosdados/upload/table.py def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) publish ( self , if_exists = 'raise' , custon_publish_sql = None , custom_schema = None ) Creates BigQuery table at production dataset. Table should be located at <dataset_id>.<table_id> . It creates a view that uses the query from <metadata_path>/<dataset_id>/<table_id>/publish.sql . Make sure that all columns from the query also exists at <metadata_path>/<dataset_id>/<table_id>/table_config.sql , including the partitions. Parameters: Name Type Description Default if_exists str Optional. What to do if table exists. 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' Todo: * Check if all required fields are filled Source code in basedosdados/upload/table.py def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) table_exists ( self , mode ) Check if table exists in BigQuery. Parameters: Name Type Description Default mode str Which dataset to check [prod|staging]. required Source code in basedosdados/upload/table.py def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) update ( self , mode = 'prod' , custom_schema = None ) Updates BigQuery schema and description. Parameters: Name Type Description Default mode str Optional. Table of which table to update [prod] 'prod' not_found_ok bool Optional. What to do if table is not found required Source code in basedosdados/upload/table.py def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , )","title":"Python"},{"location":"en/api_reference_python/#python","text":"This API is composed of functions with two types of functionality: Modules for data request : for those who only want to consult the data and metadata of our project. Classes for data management in Google Cloud: for those who want to upload data to our project (or any other project in Google Cloud, following our methodology and infrastructure).","title":"Python"},{"location":"en/api_reference_python/#modules-data-requests","text":"Functions to get metadata from BD's API","title":"Modules (Data requests)"},{"location":"en/api_reference_python/#classes-data-management","text":"Class for managing the files in cloud storage.","title":"Classes (Data management)"},{"location":"en/api_reference_r/","text":"R This API consists only of modules for data requests (i.e., downloading and/or loading project data into your analysis environment). For data management in Google Cloud, look for functions in the command line or Python APIs. The complete documentation can be found on the project's CRAN page, as shown below. All documentation for the code below is in English This browser does not support PDFs. Please download the PDF to view it: Download PDF . Oops, got an error! What now? The main errors found in the Base dos Dados package in RStudio are derived from two factors: * Authentication * Version of the `dbplyr` package Therefore, if any error appears, please first try to check if it's related to these two factors. Authentication Most errors in our package are related to authentication problems. The basedosdados package requires users to provide all authentications requested by the basedosdados::set_billing_id function, including those that appear as optional. Therefore, you need to be careful to check all selection boxes when RStudio displays this screen in the browser: Note that you need to check even the last two \"boxes\" that appear as optional . If you forgot to check them, all other package functions will not work afterward. If you have already authenticated with incomplete authorization, you need to repeat the authentication process. You can do this by running gargle::gargle_oauth_sitrep() . You should check the folder where your R authentications are saved, enter this folder, and delete the one referring to Google Cloud/BigQuery. After that, when running basedosdados::set_billing_id , you can authenticate again. See how simple it is: After completing all these procedures, it's very likely that the previous errors will no longer occur. Version of the dbplyr package Another common error is related to the use of the basedosdados::bdplyr function. Our R package was built using other packages available in the community. This means that updates to these packages can change their functionality and generate cascade effects on other packages developed on top of them. In this context, our package only works with version 2.1.1 of the dbplyr package, and does not work with later versions. You can check your dbplyr version by running utils::packageVersion(\"dbplyr\") in R. If it's higher than version 2.1.1, you need to downgrade to the correct version. To do this, you can run devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") . Other errors If errors persist, you can open an issue on our Github by clicking here . You can also visit the issues that have already been resolved and are tagged with the R label on our Github here .","title":"R"},{"location":"en/api_reference_r/#r","text":"This API consists only of modules for data requests (i.e., downloading and/or loading project data into your analysis environment). For data management in Google Cloud, look for functions in the command line or Python APIs. The complete documentation can be found on the project's CRAN page, as shown below. All documentation for the code below is in English This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"R"},{"location":"en/api_reference_r/#oops-got-an-error-what-now","text":"The main errors found in the Base dos Dados package in RStudio are derived from two factors: * Authentication * Version of the `dbplyr` package Therefore, if any error appears, please first try to check if it's related to these two factors.","title":"Oops, got an error! What now?"},{"location":"en/api_reference_r/#authentication","text":"Most errors in our package are related to authentication problems. The basedosdados package requires users to provide all authentications requested by the basedosdados::set_billing_id function, including those that appear as optional. Therefore, you need to be careful to check all selection boxes when RStudio displays this screen in the browser: Note that you need to check even the last two \"boxes\" that appear as optional . If you forgot to check them, all other package functions will not work afterward. If you have already authenticated with incomplete authorization, you need to repeat the authentication process. You can do this by running gargle::gargle_oauth_sitrep() . You should check the folder where your R authentications are saved, enter this folder, and delete the one referring to Google Cloud/BigQuery. After that, when running basedosdados::set_billing_id , you can authenticate again. See how simple it is: After completing all these procedures, it's very likely that the previous errors will no longer occur.","title":"Authentication"},{"location":"en/api_reference_r/#version-of-the-dbplyr-package","text":"Another common error is related to the use of the basedosdados::bdplyr function. Our R package was built using other packages available in the community. This means that updates to these packages can change their functionality and generate cascade effects on other packages developed on top of them. In this context, our package only works with version 2.1.1 of the dbplyr package, and does not work with later versions. You can check your dbplyr version by running utils::packageVersion(\"dbplyr\") in R. If it's higher than version 2.1.1, you need to downgrade to the correct version. To do this, you can run devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") .","title":"Version of the dbplyr package"},{"location":"en/api_reference_r/#other-errors","text":"If errors persist, you can open an issue on our Github by clicking here . You can also visit the issues that have already been resolved and are tagged with the R label on our Github here .","title":"Other errors"},{"location":"en/api_reference_stata/","text":"Stata This API consists of modules for data requests : for those who wish to only query data and metadata from our project (or any other project on Google Cloud). All code documentation below is in English Modules (Data Request) If this is your first time using the package, type db basedosdados and verify again if the steps above were completed successfully. The package contains 7 commands, with their functionalities described below: Command Description bd_download downloads data from Data Basis (DB). bd_read_sql downloads DB tables using specific queries. bd_read_table downloads DB tables using dataset_id and table_id . bd_list_datasets lists the dataset_id of available datasets in query_project_id . bd_list_dataset_tables lists table_id for available tables in the specified dataset_id . bd_get_table_description shows the complete description of the DB table. bd_get_table_columns shows the names, types, and descriptions of columns in the specified table. Each command has a supporting help file , just open the help and follow the instructions: help [command]","title":"Stata"},{"location":"en/api_reference_stata/#stata","text":"This API consists of modules for data requests : for those who wish to only query data and metadata from our project (or any other project on Google Cloud). All code documentation below is in English","title":"Stata"},{"location":"en/api_reference_stata/#modules-data-request","text":"If this is your first time using the package, type db basedosdados and verify again if the steps above were completed successfully. The package contains 7 commands, with their functionalities described below: Command Description bd_download downloads data from Data Basis (DB). bd_read_sql downloads DB tables using specific queries. bd_read_table downloads DB tables using dataset_id and table_id . bd_list_datasets lists the dataset_id of available datasets in query_project_id . bd_list_dataset_tables lists table_id for available tables in the specified dataset_id . bd_get_table_description shows the complete description of the DB table. bd_get_table_columns shows the names, types, and descriptions of columns in the specified table. Each command has a supporting help file , just open the help and follow the instructions: help [command]","title":"Modules (Data Request)"},{"location":"en/colab_checks/","text":"Collaborating with tests on DB To maintain the quality of databases present in DB, we rely on a set of automatic checks that are performed during the insertion and update of each database. These checks are necessary but not sufficient to ensure data quality. They perform basic queries, such as whether the table exists or if it has completely null columns. You can collaborate with DB by increasing test coverage, thus reducing data review work. To do this, simply create SQL queries that test data quality, such as: Verify if columns with proportions have values between 0 and 100 Verify if date columns follow the YYYY-MM-DD HH:MM:SS pattern What's the procedure? Including data tests should follow this workflow: Collaborating with tests on BD+ What's the procedure? 1. Express your interest 2. Write your query 3. Submit your query We suggest joining our Discord channel to ask questions and interact with other contributors! :) 1. Express your interest Chat with us in the infra chat or Monday meetings at 7 PM BRT, both on Discord. If you don't have an improvement suggestion, we can look for a query that hasn't been written yet. 2. Write your query Fork the Data Basis repository. Then add new queries and their respective execution functions in the files checks.yaml and test_data.py . Queries are written in a YAML file with Jinja and SQL, in the following way: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure And executed as pytest package tests: def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False Don't worry if you're not familiar with some of the syntax above; we can help you during the process. Note that the values between curly braces are variables contained in table_config.yaml files, which contain table metadata. Therefore, query writing is limited by existing metadata. We recommend consulting these files in the bases directory. 3. Submit your query Finally, make a pull request to the main repository for the query to be reviewed.","title":"Tests"},{"location":"en/colab_checks/#collaborating-with-tests-on-db","text":"To maintain the quality of databases present in DB, we rely on a set of automatic checks that are performed during the insertion and update of each database. These checks are necessary but not sufficient to ensure data quality. They perform basic queries, such as whether the table exists or if it has completely null columns. You can collaborate with DB by increasing test coverage, thus reducing data review work. To do this, simply create SQL queries that test data quality, such as: Verify if columns with proportions have values between 0 and 100 Verify if date columns follow the YYYY-MM-DD HH:MM:SS pattern","title":"Collaborating with tests on DB"},{"location":"en/colab_checks/#whats-the-procedure","text":"Including data tests should follow this workflow: Collaborating with tests on BD+ What's the procedure? 1. Express your interest 2. Write your query 3. Submit your query We suggest joining our Discord channel to ask questions and interact with other contributors! :)","title":"What's the procedure?"},{"location":"en/colab_checks/#1-express-your-interest","text":"Chat with us in the infra chat or Monday meetings at 7 PM BRT, both on Discord. If you don't have an improvement suggestion, we can look for a query that hasn't been written yet.","title":"1. Express your interest"},{"location":"en/colab_checks/#2-write-your-query","text":"Fork the Data Basis repository. Then add new queries and their respective execution functions in the files checks.yaml and test_data.py . Queries are written in a YAML file with Jinja and SQL, in the following way: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure And executed as pytest package tests: def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False Don't worry if you're not familiar with some of the syntax above; we can help you during the process. Note that the values between curly braces are variables contained in table_config.yaml files, which contain table metadata. Therefore, query writing is limited by existing metadata. We recommend consulting these files in the bases directory.","title":"2. Write your query"},{"location":"en/colab_checks/#3-submit-your-query","text":"Finally, make a pull request to the main repository for the query to be reviewed.","title":"3. Submit your query"},{"location":"en/colab_data/","text":"Upload data to DB Why should my organization upload data to DB? Ability to cross-reference your databases with data from different organizations in a simple and easy way. There are already hundreds of public datasets from the largest organizations in Brazil and worldwide present in our datalake . Commitment to transparency, data quality, and development of better research, analysis, and solutions for society. We not only democratize access to open data but also quality data. We have a specialized team that reviews and ensures the quality of data added to the datalake . Participation in an ever-growing community : thousands of journalists, researchers, developers already use and follow Data Basis. Step by step to upload data Want to upload data to DB and help us build this repository? Wonderful! We've organized everything you need in the manual below in 8 steps To facilitate the explanation, we'll follow a ready-made example with data from RAIS . You can navigate through the steps in the menu on the left. We strongly suggest joining our Discord channel to ask questions and interact with the team and other contributors! \ud83d\ude09 Before starting Some knowledge is necessary to carry out this process: Python, R, SQL and/or Stata : to create data capture and cleaning codes. Command line : to set up your local environment and connection with Google Cloud. Github : to upload your code for review by our team. Don't have some of these skills but want to contribute? We have a data team that can help you, just join our Discord and send a message in #want-to-contribute. How does the process work? Choose the dataset and understand more about the data - first we need to know what we're dealing with. Download our template folder - it's time to structure the work to be done Fill in the architecture tables - it's essential to define the data structure before we start treatment Write data capture and cleaning code - time to get to work! (If necessary) Organize auxiliary files - because even data needs guides (If necessary) Create dictionary table - time to build the dictionaries Upload everything to Google Cloud - after all, that's where DB data is stored Send everything for review - a look from our team to ensure everything is ready for production! 1. Choose the dataset and understand more about the data We keep the list of datasets for volunteers in our Github . To start uploading a base of your interest, just open a new issue with data. If your base (dataset) is already listed, just mark your Github user as assignee Your first task is to fill in the information in the issue. These information will help you understand the data better and will be very useful for treatment and filling in metadata. When you finish this step, call someone from the data team to that the information you mapped about the dataset already enter our site! 2. Download our template folder Download here the template template and rename it to <dataset_id> (defined in the issue of step 1 ). This template folder simplifies and organizes all the steps from here on. Its structure is as follows: <dataset_id>/ code/ : Necessary codes for capture and cleaning of data ( we'll see more in step 4 ). input/ : Contains all the original files with data, exactly as downloaded from the primary source. ( we'll see more in step 4 ). output/ : Final files, already in the ready-to-upload format ( we'll see more in step 4 ). tmp/ : Any temporary files created by the code in /code during the cleaning and treatment process ( we'll see more in step 4 ). extra/ architecture/ : Architecture tables ( we'll see more in step 3 ). auxiliary_files/ : Auxiliary files to the data ( we'll see more in step 5 ). dicionario.csv : Dictionary table for the entire dataset ( we'll see more in step 6 ). Only the code folder will be committed to your project, the other files will only exist locally or in Google Cloud. 3. Fill in the architecture tables The architecture tables determine what the structure of each table in your dataset is . They define, for example, the name, order, and metadata of the variables, as well as compatibilities when there are changes in versions (for example, if a variable changes name from one year to the next). Each dataset table must have its own architecture table (spreadsheet), which must be filled in Google Drive to allow correction by our data team. Example: RAIS - Architecture tables The RAIS architecture tables can be consulted here . They are a great reference for you to start your work since they have many variables and examples of various situations you might end up encountering. To fill in each table of your dataset, follow these steps: A each beginning and end of step, consult our style guide to ensure you're following the BD standardization List all the variables in the data in the original_name column Obs: If the base changes the name of the variables over time (like RAIS), it's necessary to make compatibilities between years for all the variables by filling in the original_name_YYYY column for each year or month available Rename the variables according to our manual in the name column Understand the type of variable and fill in the bigquery_type column Fill in the description in the description column according to the manual From the compatibilities between years and/or queries to the raw data, fill in the temporal coverage in temporal_coverage for each variable Obs: If the variables have the same temporal coverage as the table, fill in only with '(1)' Indicate with 'yes' or 'no' if there's a dictionary for the variables in covered_by_dictionary Check if the variables represent any entity present in the directories to fill in the directory_column For variables of type int64 or float64 , check if it's necessary to include a measurement unit Reorder the variables according to the manual When you finish filling in the architecture tables, contact the Data Basis team to validate everything. It's necessary that it's clear what the final format of the data should be before starting to write the code. This way we avoid redoing the work. 4. Write data capture and cleaning code After validating the architecture tables, we can write the capture and cleaning codes for the data. Capture : Code that automatically downloads all the original data and saves it in /input . These data can be available on portals or links FTP, can be scraped from websites, among others. Cleaning : Code that transforms the original data saved in /input into clean data, saves it in the /output folder, to be later uploaded to DB. Each clean table for production can be saved as a single file or, if it's very large (e.g. above 200 mb), it can be partitioned in the Hive format in several sub-files. The accepted formats are .csv or .parquet . Our recommendation is to partition tables by year , month , and state_abbreviation . The partitioning is done through the folder structure, see the example below to visualize how. Example: RAIS - Partitioning The microdados_vinculos table from RAIS, for example, is a very large table (+250GB) so we partition it by year and state_abbreviation . The partitioning was done using the folder structure /microdados_vinculos/year=YYYY/state_abbreviation=XX . Required patterns in the code Must be written in Python , R or Stata - so that the review can be performed by our team. Can be in script ( .py , .R , ...) or notebooks (Google Colab, Jupyter, Rmarkdown, etc). File paths must be shortcuts relative to the root folder ( <dataset_id> ), that is, they must not depend on the paths of your computer. The cleaning must follow our style guide and the best programming practices . Example: PNAD Continuous - Cleaning Code The cleaning code was built in R and can be consulted here . Example: Activity in the Legislative Chamber - Download and Cleaning Code The cleaning code was built in Python can be consulted here 5. (If necessary) Organize auxiliary files It's common for databases to be made available with auxiliary files. These can include technical notes, collection and sampling descriptions, etc. To help users of Data Basis have more context and understand the data better, organize all these auxiliary files in /extra/auxiliary_files . Feel free to structure sub-folders as you like there. What matters is that it's clear what these files are. 6. (If necessary) Create dictionary table Sometimes, especially with old bases, there are multiple dictionaries in Excel or other formats. In Data Basis, we unify everything in a single file in .csv format - a single dictionary for all columns of all tables in your dataset. Important details on how to build your dictionary are in our style guide . Example: RAIS - Dictionary The complete dictionary can be consulted here . It already has the standard structure we use for dictionaries. 7. Upload everything to Google Cloud All set! Now all that's left is to upload to Google Cloud and send for review. For that, we'll use the basedosdados client (available in Python) that facilitates the process. Since there's a cost for storage in the storage, to finalize this step we'll need to make you available an api_key specifically for volunteers to upload the data to our development environment. So, join our Discord channel and call us in 'want-to-contribute' Configure your credentials locally 7.1 Install our client in your terminal: pip install basedosdados . 7.2 Run import basedosdados as bd in python and follow the step-by-step process to configure locally with the credentials of your project in Google Cloud. Fill in the information as follows: * STEP 1: y * STEP 2: basedosdados-dev (put the .json passed by the bd team in the credentials folder) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql Upload the files to the Cloud The data will pass through 3 places in Google Cloud: Storage : also called GCS is the local where the \"cold\" files (architectures, data, auxiliary files) will be stored. BigQuery-DEV-Staging : table that connects the data from storage to the basedosdados-dev project in bigquery BigQuery-DEV-Production : table used for testing and treatment via SQL of the dataset 7.3 Create the table in the GCS bucket and BigQuery-DEV-staging , using the Python API, as follows: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<path_to_the_data>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` The following parameters can be used: - `path` (required): the complete path of the file on your computer, like: `/Users/<your_username>/projects/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"If your data is partitioned, the path must point to the folder where the partitions are. Otherwise, it must point to a `.csv` file (for example, microdados.csv).\" - `force_dataset`: command that creates the dataset configuration files in BigQuery. - _True_: the dataset configuration files will be created in your project and, if it doesn't exist in BigQuery, it will be created automatically. **If you already created and configured the dataset, don't use this option, as it will overwrite files**. - _False_: the dataset won't be recreated and, if it doesn't exist, it will be created automatically. - `if_table_exists` : command used if the **table already exists in BQ**: - _raise_: returns an error message. - _replace_: replaces the table. - _pass_: does nothing. - `if_storage_data_exists`: command used if the **data already exists in Google Cloud Storage**: - _raise_: returns an error message - _replace_: replaces the existing data. - _pass_: does nothing. !!! Info \"If the project doesn't exist in BigQuery, it will be automatically created\" Consult our API for more details on each method. 7.4 Create the .sql and schema.yml files from the architecture table following this documentation If you need, at this moment you can change the SQL query to perform final treatments from the staging table, you can include columns, remove columns, perform algebraic operations, substitute strings, etc. SQL is the limit! 7.5 Run and test the models locally following this documentation 7.6 Upload the table metadata to the site: For now, only the data team has permissions to upload the table metadata to the site, so it will be necessary to contact us. We're already working to make it possible for volunteers to update data on the site in the near future. 7.7 Upload the auxiliary files: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'caminho_para_os_auxiliary_files' , mode = 'auxiliary_files' , if_exists = 'raise' ) 8. Send everything for review Yay, that's it! Now all that's left is to send everything for review in the repository of Data Basis. Clone our repository locally. Give a cd to the local folder of the repository and open a new branch with git checkout -b [dataset_id] . All additions and modifications will be included in this branch . For each new table, include the file with name table_id.sql in the queries-basedosdados/models/dataset_id/ folder by copying the queries you developed in step 7. Include the schema.yaml file developed in step 7 If it's a new dataset, include the dataset according to the instructions in the queries-basedosdados/dbt_project.yaml file (don't forget to follow the alphabetical order to not mess up the organization) Include your data capture and cleaning code in the queries-basedosdados/models/dataset_id/code folder Now it's just about publishing the branch, opening a PR with the labels 'table-approve' and marking the data team for correction And now? Our team will review the data and metadata submitted via Github. We can contact you to ask questions or request changes to the code. When everything is OK, we'll do a merge of your pull request and the data will be automatically published on our platform!","title":"Data"},{"location":"en/colab_data/#upload-data-to-db","text":"","title":"Upload data to DB"},{"location":"en/colab_data/#why-should-my-organization-upload-data-to-db","text":"Ability to cross-reference your databases with data from different organizations in a simple and easy way. There are already hundreds of public datasets from the largest organizations in Brazil and worldwide present in our datalake . Commitment to transparency, data quality, and development of better research, analysis, and solutions for society. We not only democratize access to open data but also quality data. We have a specialized team that reviews and ensures the quality of data added to the datalake . Participation in an ever-growing community : thousands of journalists, researchers, developers already use and follow Data Basis.","title":"Why should my organization upload data to DB?"},{"location":"en/colab_data/#step-by-step-to-upload-data","text":"Want to upload data to DB and help us build this repository? Wonderful! We've organized everything you need in the manual below in 8 steps To facilitate the explanation, we'll follow a ready-made example with data from RAIS . You can navigate through the steps in the menu on the left. We strongly suggest joining our Discord channel to ask questions and interact with the team and other contributors! \ud83d\ude09","title":"Step by step to upload data"},{"location":"en/colab_data/#before-starting","text":"Some knowledge is necessary to carry out this process: Python, R, SQL and/or Stata : to create data capture and cleaning codes. Command line : to set up your local environment and connection with Google Cloud. Github : to upload your code for review by our team. Don't have some of these skills but want to contribute? We have a data team that can help you, just join our Discord and send a message in #want-to-contribute.","title":"Before starting"},{"location":"en/colab_data/#how-does-the-process-work","text":"Choose the dataset and understand more about the data - first we need to know what we're dealing with. Download our template folder - it's time to structure the work to be done Fill in the architecture tables - it's essential to define the data structure before we start treatment Write data capture and cleaning code - time to get to work! (If necessary) Organize auxiliary files - because even data needs guides (If necessary) Create dictionary table - time to build the dictionaries Upload everything to Google Cloud - after all, that's where DB data is stored Send everything for review - a look from our team to ensure everything is ready for production!","title":"How does the process work?"},{"location":"en/colab_data/#1-choose-the-dataset-and-understand-more-about-the-data","text":"We keep the list of datasets for volunteers in our Github . To start uploading a base of your interest, just open a new issue with data. If your base (dataset) is already listed, just mark your Github user as assignee Your first task is to fill in the information in the issue. These information will help you understand the data better and will be very useful for treatment and filling in metadata. When you finish this step, call someone from the data team to that the information you mapped about the dataset already enter our site!","title":"1. Choose the dataset and understand more about the data"},{"location":"en/colab_data/#2-download-our-template-folder","text":"Download here the template template and rename it to <dataset_id> (defined in the issue of step 1 ). This template folder simplifies and organizes all the steps from here on. Its structure is as follows: <dataset_id>/ code/ : Necessary codes for capture and cleaning of data ( we'll see more in step 4 ). input/ : Contains all the original files with data, exactly as downloaded from the primary source. ( we'll see more in step 4 ). output/ : Final files, already in the ready-to-upload format ( we'll see more in step 4 ). tmp/ : Any temporary files created by the code in /code during the cleaning and treatment process ( we'll see more in step 4 ). extra/ architecture/ : Architecture tables ( we'll see more in step 3 ). auxiliary_files/ : Auxiliary files to the data ( we'll see more in step 5 ). dicionario.csv : Dictionary table for the entire dataset ( we'll see more in step 6 ). Only the code folder will be committed to your project, the other files will only exist locally or in Google Cloud.","title":"2. Download our template folder"},{"location":"en/colab_data/#3-fill-in-the-architecture-tables","text":"The architecture tables determine what the structure of each table in your dataset is . They define, for example, the name, order, and metadata of the variables, as well as compatibilities when there are changes in versions (for example, if a variable changes name from one year to the next). Each dataset table must have its own architecture table (spreadsheet), which must be filled in Google Drive to allow correction by our data team.","title":"3. Fill in the architecture tables"},{"location":"en/colab_data/#example-rais-architecture-tables","text":"The RAIS architecture tables can be consulted here . They are a great reference for you to start your work since they have many variables and examples of various situations you might end up encountering.","title":"Example: RAIS - Architecture tables"},{"location":"en/colab_data/#to-fill-in-each-table-of-your-dataset-follow-these-steps","text":"A each beginning and end of step, consult our style guide to ensure you're following the BD standardization List all the variables in the data in the original_name column Obs: If the base changes the name of the variables over time (like RAIS), it's necessary to make compatibilities between years for all the variables by filling in the original_name_YYYY column for each year or month available Rename the variables according to our manual in the name column Understand the type of variable and fill in the bigquery_type column Fill in the description in the description column according to the manual From the compatibilities between years and/or queries to the raw data, fill in the temporal coverage in temporal_coverage for each variable Obs: If the variables have the same temporal coverage as the table, fill in only with '(1)' Indicate with 'yes' or 'no' if there's a dictionary for the variables in covered_by_dictionary Check if the variables represent any entity present in the directories to fill in the directory_column For variables of type int64 or float64 , check if it's necessary to include a measurement unit Reorder the variables according to the manual When you finish filling in the architecture tables, contact the Data Basis team to validate everything. It's necessary that it's clear what the final format of the data should be before starting to write the code. This way we avoid redoing the work.","title":"To fill in each table of your dataset, follow these steps:"},{"location":"en/colab_data/#4-write-data-capture-and-cleaning-code","text":"After validating the architecture tables, we can write the capture and cleaning codes for the data. Capture : Code that automatically downloads all the original data and saves it in /input . These data can be available on portals or links FTP, can be scraped from websites, among others. Cleaning : Code that transforms the original data saved in /input into clean data, saves it in the /output folder, to be later uploaded to DB. Each clean table for production can be saved as a single file or, if it's very large (e.g. above 200 mb), it can be partitioned in the Hive format in several sub-files. The accepted formats are .csv or .parquet . Our recommendation is to partition tables by year , month , and state_abbreviation . The partitioning is done through the folder structure, see the example below to visualize how.","title":"4. Write data capture and cleaning code"},{"location":"en/colab_data/#example-rais-partitioning","text":"The microdados_vinculos table from RAIS, for example, is a very large table (+250GB) so we partition it by year and state_abbreviation . The partitioning was done using the folder structure /microdados_vinculos/year=YYYY/state_abbreviation=XX .","title":"Example: RAIS - Partitioning"},{"location":"en/colab_data/#required-patterns-in-the-code","text":"Must be written in Python , R or Stata - so that the review can be performed by our team. Can be in script ( .py , .R , ...) or notebooks (Google Colab, Jupyter, Rmarkdown, etc). File paths must be shortcuts relative to the root folder ( <dataset_id> ), that is, they must not depend on the paths of your computer. The cleaning must follow our style guide and the best programming practices .","title":"Required patterns in the code"},{"location":"en/colab_data/#example-pnad-continuous-cleaning-code","text":"The cleaning code was built in R and can be consulted here .","title":"Example: PNAD Continuous - Cleaning Code"},{"location":"en/colab_data/#example-activity-in-the-legislative-chamber-download-and-cleaning-code","text":"The cleaning code was built in Python can be consulted here","title":"Example: Activity in the Legislative Chamber - Download and Cleaning Code"},{"location":"en/colab_data/#5-if-necessary-organize-auxiliary-files","text":"It's common for databases to be made available with auxiliary files. These can include technical notes, collection and sampling descriptions, etc. To help users of Data Basis have more context and understand the data better, organize all these auxiliary files in /extra/auxiliary_files . Feel free to structure sub-folders as you like there. What matters is that it's clear what these files are.","title":"5. (If necessary) Organize auxiliary files"},{"location":"en/colab_data/#6-if-necessary-create-dictionary-table","text":"Sometimes, especially with old bases, there are multiple dictionaries in Excel or other formats. In Data Basis, we unify everything in a single file in .csv format - a single dictionary for all columns of all tables in your dataset. Important details on how to build your dictionary are in our style guide .","title":"6. (If necessary) Create dictionary table"},{"location":"en/colab_data/#example-rais-dictionary","text":"The complete dictionary can be consulted here . It already has the standard structure we use for dictionaries.","title":"Example: RAIS - Dictionary"},{"location":"en/colab_data/#7-upload-everything-to-google-cloud","text":"All set! Now all that's left is to upload to Google Cloud and send for review. For that, we'll use the basedosdados client (available in Python) that facilitates the process. Since there's a cost for storage in the storage, to finalize this step we'll need to make you available an api_key specifically for volunteers to upload the data to our development environment. So, join our Discord channel and call us in 'want-to-contribute'","title":"7. Upload everything to Google Cloud"},{"location":"en/colab_data/#configure-your-credentials-locally","text":"7.1 Install our client in your terminal: pip install basedosdados . 7.2 Run import basedosdados as bd in python and follow the step-by-step process to configure locally with the credentials of your project in Google Cloud. Fill in the information as follows: * STEP 1: y * STEP 2: basedosdados-dev (put the .json passed by the bd team in the credentials folder) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql","title":"Configure your credentials locally"},{"location":"en/colab_data/#upload-the-files-to-the-cloud","text":"The data will pass through 3 places in Google Cloud: Storage : also called GCS is the local where the \"cold\" files (architectures, data, auxiliary files) will be stored. BigQuery-DEV-Staging : table that connects the data from storage to the basedosdados-dev project in bigquery BigQuery-DEV-Production : table used for testing and treatment via SQL of the dataset 7.3 Create the table in the GCS bucket and BigQuery-DEV-staging , using the Python API, as follows: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<path_to_the_data>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` The following parameters can be used: - `path` (required): the complete path of the file on your computer, like: `/Users/<your_username>/projects/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"If your data is partitioned, the path must point to the folder where the partitions are. Otherwise, it must point to a `.csv` file (for example, microdados.csv).\" - `force_dataset`: command that creates the dataset configuration files in BigQuery. - _True_: the dataset configuration files will be created in your project and, if it doesn't exist in BigQuery, it will be created automatically. **If you already created and configured the dataset, don't use this option, as it will overwrite files**. - _False_: the dataset won't be recreated and, if it doesn't exist, it will be created automatically. - `if_table_exists` : command used if the **table already exists in BQ**: - _raise_: returns an error message. - _replace_: replaces the table. - _pass_: does nothing. - `if_storage_data_exists`: command used if the **data already exists in Google Cloud Storage**: - _raise_: returns an error message - _replace_: replaces the existing data. - _pass_: does nothing. !!! Info \"If the project doesn't exist in BigQuery, it will be automatically created\" Consult our API for more details on each method. 7.4 Create the .sql and schema.yml files from the architecture table following this documentation If you need, at this moment you can change the SQL query to perform final treatments from the staging table, you can include columns, remove columns, perform algebraic operations, substitute strings, etc. SQL is the limit! 7.5 Run and test the models locally following this documentation 7.6 Upload the table metadata to the site: For now, only the data team has permissions to upload the table metadata to the site, so it will be necessary to contact us. We're already working to make it possible for volunteers to update data on the site in the near future. 7.7 Upload the auxiliary files: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'caminho_para_os_auxiliary_files' , mode = 'auxiliary_files' , if_exists = 'raise' )","title":"Upload the files to the Cloud"},{"location":"en/colab_data/#8-send-everything-for-review","text":"Yay, that's it! Now all that's left is to send everything for review in the repository of Data Basis. Clone our repository locally. Give a cd to the local folder of the repository and open a new branch with git checkout -b [dataset_id] . All additions and modifications will be included in this branch . For each new table, include the file with name table_id.sql in the queries-basedosdados/models/dataset_id/ folder by copying the queries you developed in step 7. Include the schema.yaml file developed in step 7 If it's a new dataset, include the dataset according to the instructions in the queries-basedosdados/dbt_project.yaml file (don't forget to follow the alphabetical order to not mess up the organization) Include your data capture and cleaning code in the queries-basedosdados/models/dataset_id/code folder Now it's just about publishing the branch, opening a PR with the labels 'table-approve' and marking the data team for correction And now? Our team will review the data and metadata submitted via Github. We can contact you to ask questions or request changes to the code. When everything is OK, we'll do a merge of your pull request and the data will be automatically published on our platform!","title":"8. Send everything for review"},{"location":"en/colab_infrastructure/","text":"DB Infrastructure Our infrastructure team ensures that all packages and pipelines are working optimally for the public. We use Github to manage all code and keep it organized, where you can find issues for new features, bugs, and improvements we're working on. How our infrastructure works Our infrastructure consists of 3 main fronts: Data ingestion system : from upload to production deployment; Access packages Website : Front-end, Back-end, and APIs. Currently, it's possible to collaborate on all fronts, with emphasis on developing checks and balances and website updates. We suggest joining our Discord channel to ask questions and interact with other contributors! :) Data ingestion system The system has development ( basedosdados-dev ), staging ( basedosdados-staging ), and production ( basedosdados ) environments in BigQuery. The data upload processes are detailed in the image below, with some of them being automated via Github Actions. We explain the system's operation in more detail on our blog . How to contribute? Improving system documentation here :) Creating automatic data and metadata quality checks (in Python) Creating new issues and improvement suggestions Access packages The datalake access packages are constantly being improved, and you can collaborate with us on new features, bug fixes, and much more. How to contribute? Explore Python package issues Explore R package issues Help develop the Stata package Website Our website is developed in Next.js and consumes a CKAN metadata API. The site's code is also on our Github . How to contribute? Improve site UX (Next, CSS, HTML) Help with open BE, FE, or API issues Create new issues and improvement suggestions","title":"Infrastructure"},{"location":"en/colab_infrastructure/#db-infrastructure","text":"Our infrastructure team ensures that all packages and pipelines are working optimally for the public. We use Github to manage all code and keep it organized, where you can find issues for new features, bugs, and improvements we're working on.","title":"DB Infrastructure"},{"location":"en/colab_infrastructure/#how-our-infrastructure-works","text":"Our infrastructure consists of 3 main fronts: Data ingestion system : from upload to production deployment; Access packages Website : Front-end, Back-end, and APIs. Currently, it's possible to collaborate on all fronts, with emphasis on developing checks and balances and website updates. We suggest joining our Discord channel to ask questions and interact with other contributors! :)","title":"How our infrastructure works"},{"location":"en/colab_infrastructure/#data-ingestion-system","text":"The system has development ( basedosdados-dev ), staging ( basedosdados-staging ), and production ( basedosdados ) environments in BigQuery. The data upload processes are detailed in the image below, with some of them being automated via Github Actions. We explain the system's operation in more detail on our blog .","title":"Data ingestion system"},{"location":"en/colab_infrastructure/#how-to-contribute","text":"Improving system documentation here :) Creating automatic data and metadata quality checks (in Python) Creating new issues and improvement suggestions","title":"How to contribute?"},{"location":"en/colab_infrastructure/#access-packages","text":"The datalake access packages are constantly being improved, and you can collaborate with us on new features, bug fixes, and much more.","title":"Access packages"},{"location":"en/colab_infrastructure/#how-to-contribute_1","text":"Explore Python package issues Explore R package issues Help develop the Stata package","title":"How to contribute?"},{"location":"en/colab_infrastructure/#website","text":"Our website is developed in Next.js and consumes a CKAN metadata API. The site's code is also on our Github .","title":"Website"},{"location":"en/colab_infrastructure/#how-to-contribute_2","text":"Improve site UX (Next, CSS, HTML) Help with open BE, FE, or API issues Create new issues and improvement suggestions","title":"How to contribute?"},{"location":"en/style_data/","text":"Style Guide In this section we list all the standards from our style guide and data guidelines that we use at Data Basis. They help us maintain high quality in the data and metadata we publish. You can use the left menu to navigate through the different topics on this page. Naming datasets and tables Datasets ( dataset_id ) We name datasets in the format <organization_id>_<description> , where organization_id follows by default the geographic scope of the organization that publishes the dataset: organization_id Global world_<organization> Federal <country_code>_<organization> State <country_code>_<state_code>_<organization> Municipal <country_code>_<state_code>_<city>_<organization> country_code and state_code are always 2 lowercase letters; organization is the name or acronym (preferably) of the organization that published the original data (e.g., ibge , tse , inep ). description is a brief description of the dataset For example, the GDP dataset from IBGE has as dataset_id : br_ibge_pib Not sure how to name the organization? We suggest visiting their website and seeing how they refer to themselves (e.g., DETRAN-RJ would be br_rj_detran ) Tables Naming tables is less structured and therefore requires good judgment. But we have some rules: If there are tables for different entities, include the entity at the beginning of the name. Example: municipality_value , state_value . Do not include the time unit in the name. Example: name it municipality , not municipality_year . Keep names in singular. Example: school , not schools . Name the most disaggregated tables as microdata . Generally these have data at the person or transaction level. Examples of dataset_id.table_id Global world_waze.alerts Waze alert data from different cities. Federal br_tse_elections.candidates TSE political candidate data. Federal br_ibge_pnad.microdata Microdata from the National Household Sample Survey produced by IBGE. Federal br_ibge_pnadc.microdata Microdata from the Continuous National Household Sample Survey (PNAD-C) produced by IBGE. State br_sp_see_teachers.workload Anonymized workload of active teachers in SP state education network. Municipal br_rj_riodejaneiro_cmrj_legislative.votes Voting data from Rio de Janeiro City Council (RJ). Table formats Tables should, whenever possible, be in long format, rather than wide . Variable naming Variable names must follow some rules: Use existing names in the repository as much as possible. Examples: year , month , municipality_id , state_code , age , position , result , votes , revenue , expense , price , etc. Respect directory table patterns. Be as intuitive, clear, and extensive as possible. Have all lowercase letters (including acronyms), without accents, connected by _ . Do not include connectors like of , the , and , in , etc. Only have the id_ prefix when the variable represents primary keys of entities (that would eventually have a directory table). Examples that have it: municipality_id , state_id , school_id , person_id . Examples that don't: network , location . Important : when the dataset is in English, id becomes a suffix Only have entity suffixes when the column's entity is different from the table's entity. Examples that have it: in a table with entity person , a column about municipal GDP would be called municipality_gdp . Examples that don't: in a table with entity person , person characteristics would be called name , age , sex , etc. List of allowed prefixes name_ , date_ , number_ , quantity_ , proportion_ (percentage variables 0-100%), rate_ , ratio_ , index_ , indicator_ (boolean type variables), type_ , code_ , sequential_ . List of common suffixes _pc (per capita) Measurement units The rule is to keep variables with their original measurement units listed in this code , with the exception of financial variables where we convert old currencies to current ones (e.g. Cruzeiro to Real). We catalog measurement units in standard format in the architecture table. Complete list here Examples: m , km/h , BRL . For deflated financial columns, we list the currency with the base year. Example: a column measured in reais in 2010 has unit BRL_2010 . Variables must always have measurement units with base 1. In other words, having BRL instead of 1000 BRL , or person instead of 1000 persons . This information, as well as other column metadata, is recorded in the architecture table of the table. Which variables to keep, add, and remove We partially normalize our tables and have rules for which variables to include in production. They are: Remove variables from entity names that already exist in directories. Example: remove municipality from the table that already includes municipality_id . Remove variables serving as partitions. Example: remove year and state_code if the table is partitioned in these two dimensions. Add primary keys for each existing entity. Example: add municipality_id to tables that only include municipality_tse . Keep all primary keys that already come with the table, but (1) add relevant keys (e.g. state_code , municipality_id ) and (2) remove irrelevant keys (e.g. region ). Temporal coverage Fill in the temporal_coverage column in table, column, and key metadata (in dictionaries) according to the following pattern. General format: initial_date(temporal_unit)final_date initial_date and final_date are in the corresponding temporal unit. Example: table with unit year has coverage 2005(1)2018 . Example: table with unit month has coverage 2005-08(1)2018-12 . Example: table with unit week has coverage 2005-08-01(7)2018-08-31 . Example: table with unit day has coverage 2005-08-01(1)2018-12-31 . Rules for filling in Table metadata Fill in the general format. Column metadata Fill in the general format, except when initial_date or final_date are equal to the table's. In that case, leave it empty. Example: suppose the table's coverage is 2005(1)2018 . If a column appears only in 2012 and exists until 2018, we fill in its coverage as 2012(1) . If a column disappears in 2013, we fill in its coverage as (1)2013 . If a column exists in the same temporal coverage as the table, we fill in its coverage as (1) . Key metadata Fill in the same pattern of columns, but with the reference being the corresponding column, not the table. Cleaning STRINGs Categorical variables: initial uppercase and rest lowercase, with accents. Unstructured STRINGs: keep them as they are. Value formats Decimal: American format, i.e., always . (dot) instead of , (comma). Date: YYYY-MM-DD Time (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Null value: \"\" (csv), NULL (Python), NA (R), . or \"\" (Stata) Proportion/percentage: between 0-100 Table partitioning What is partitioning and what is its goal? In a nutshell, partitioning a table is dividing it into multiple blocks/parts. The central objective is to reduce financial costs and increase performance, as the larger the volume of data, the greater the storage and query costs. The reduction in costs and the increase in performance mainly occur because partitioning allows the data set to be reorganized into small grouped blocks . In practice, by performing the partitioning, it is possible to avoid that a query traverses the entire table just to bring a small data slice. An example of our beloved RAIS: Without using partition filtering: For this case, Bigquery scanned all (*) columns and rows of the dataset. It's worth noting that this cost is still not very large, as the base has already been partitioned. If this dataset hadn't passed through the partition process, this query would have cost a lot more money and time, as it involves a considerable volume of data. With partition filtering: Here, we filter by the partitioned columns year and state_code . As a result, Bigquery only queries and returns the values from the year folder and the state_code subfolder. When should a table be partitioned? The first question that arises when dealing with partitioning is: from which number of lines a table should be partitioned? The documentation of GCP does not define a quantity x or y of lines that should be partitioned. The ideal is that tables are partitioned, with few exceptions. For example, tables with less than 10,000 lines, which will no longer receive data ingestion, do not have high storage and processing costs and, therefore, there is no need to be partitioned. How to partition a table? If the data is stored locally, it is necessary: Create the partitioned folders in your /output folder, using the language you are using. Example of a partitioned table by year and month , using python : for year in [ * range ( 2005 , 2020 )]: for month in [ * range ( 1 , 13 )]: partition = output + f 'table_id/year= { year } /month= { month } ' if not os . path . exists ( partition ): os . makedirs ( partition ) 2. Save the partitioned files. for year in [ * range ( 2005 , 2020 )]: for month in [ * range ( 1 , 13 )]: df_partition = df [ df [ 'year' ] == year ] . copy () # The .copy is not necessary, it's just a good practice df_partition = df_partition [ df_partition [ 'month' ] == month ] df_partition . drop ([ 'year' , 'month' ], axis = 1 , inplace = True ) # It's necessary to exclude the columns used for partitioning partition = output + f 'table_id/year= { year } /month= { month } /table.csv' df_partition . to_csv ( partition , index = False , encoding = 'utf-8' , na_rep = '' ) Examples of partitioned tables in R : PNADC PAM Example of how to partition a table in SQL : CREATE TABLE ` dataset_id . table_id ` as ( year INT64 , month INT64 , col1 STRING , col1 STRING ) PARTITION BY year , month OPTIONS ( Description = 'Description of the table' ) Important rules for partitioning. The types of columns that BigQuery accepts as partitioning are: Time unit column : tables are partitioned based on a TIMESTAMP , DATE or DATETIME column. Processing time : tables are partitioned based on the data/time stamp when BigQuery processes the data. Range of integers : tables are partitioned based on a column of integers. The types of columns that BigQuery does not accept as partitioning are: BOOL , FLOAT64 , BYTES , etc. BigQuery accepts up to 4,000 partitions per table. In our BD, tables are usually partitioned by: year , month , quarter , and state_code . Note that when partitioning a table, it is necessary to exclude the corresponding column. Example: it is necessary to exclude the year column when partitioning by year . Number of bases per pull request Pull requests on Github should include a maximum of one dataset, but can include more than one base. In other words, they can involve one or more tables within the same dataset. Dictionaries Each base includes only one dictionary (which covers one or more tables). For each table, column, and temporal coverage, each key maps uniquely to a value. Keys cannot have null values. Dictionaries must cover all available keys in the original tables. Keys can only have zeros to the left when the variable's number of digits has meaning. When the variable is enum default, we exclude the zeros to the left. Example: we keep the zero to the left of the variable br_bd_diretorios_brasil.cbo_2002:cbo_2002 , which has six digits, because the first digit 0 means the category is from the grand group = \"Members of the armed forces, police, and firefighters\" . For other cases, such as br_inep_censo_escolar.stage:stage_education , we exclude the zeros to the left. In other words, we change 01 to 1 . Values are standardized: without extra spaces, initial uppercase and rest lowercase, etc. How to fill in the table dictionary metadata? Do not fill in the spatial_coverage ( spatial_coverage ), i.e., leave the field empty. Do not fill in the temporal_coverage ( temporal_coverage ), i.e., leave the field empty. Do not fill in the observation_level ( observation_level ), i.e., leave the field empty. Directories Directories are the fundamental building blocks of our datalake . Our rules for managing directories are: Directories represent entities of the repository that have primary keys (e.g., state , municipality , school ) and time-based units (e.g., data , time , day , month , year ). Each directory table has at least one primary key with unique values and no nulls. Examples: municipality:municipality_id , state:state_code . Variable names with the id_ prefix are reserved for primary keys of entities. See all the tables already available here. How to fill in the directory table metadata? Fill in the spatial_coverage ( spatial_coverage ), which is the maximum spatial unit that the table covers. Example: sa.br, which means that the spatial aggregation level of the table is Brazil. Do not fill in the temporal_coverage ( temporal_coverage ), i.e., leave the field empty. Fill in the observation_level ( observation_level ), which consists of the observation level of the table, i.e., what each line represents. Do not fill in the temporal_coverage ( temporal_coverage ) of the columns of the table, i.e., leave the field empty. Raw Data Sources The field refers to the data in the raw data source, which has not yet passed through the Data Basis methodology, i.e., our _input_ . When you click on it, the idea is to redirect the user to the original data source page. Our rules for managing the raw data sources are: Include the name of the external link that leads to the raw data source. As a default, this name should be the organization's name or the portal's name that stores the data. Examples: Educational Statistics: Open Data from Inep , Penn World Tables: Groningen Growth and Development Centre . Fill in the raw data source metadata: Description, URL, Language, Has Structured Data, Has an API, Is Free, Requires Registration, Availability, Requires IP from Some Country, License Type, Temporal Coverage, Spatial Coverage, and Observation Level. Thought of improvements for the standards defined? Open an issue on our Github or send a message on Discord to talk to us :)","title":"Style guide"},{"location":"en/style_data/#style-guide","text":"In this section we list all the standards from our style guide and data guidelines that we use at Data Basis. They help us maintain high quality in the data and metadata we publish. You can use the left menu to navigate through the different topics on this page.","title":"Style Guide"},{"location":"en/style_data/#naming-datasets-and-tables","text":"","title":"Naming datasets and tables"},{"location":"en/style_data/#datasets-dataset_id","text":"We name datasets in the format <organization_id>_<description> , where organization_id follows by default the geographic scope of the organization that publishes the dataset: organization_id Global world_<organization> Federal <country_code>_<organization> State <country_code>_<state_code>_<organization> Municipal <country_code>_<state_code>_<city>_<organization> country_code and state_code are always 2 lowercase letters; organization is the name or acronym (preferably) of the organization that published the original data (e.g., ibge , tse , inep ). description is a brief description of the dataset For example, the GDP dataset from IBGE has as dataset_id : br_ibge_pib Not sure how to name the organization? We suggest visiting their website and seeing how they refer to themselves (e.g., DETRAN-RJ would be br_rj_detran )","title":"Datasets (dataset_id)"},{"location":"en/style_data/#tables","text":"Naming tables is less structured and therefore requires good judgment. But we have some rules: If there are tables for different entities, include the entity at the beginning of the name. Example: municipality_value , state_value . Do not include the time unit in the name. Example: name it municipality , not municipality_year . Keep names in singular. Example: school , not schools . Name the most disaggregated tables as microdata . Generally these have data at the person or transaction level.","title":"Tables"},{"location":"en/style_data/#examples-of-dataset_idtable_id","text":"Global world_waze.alerts Waze alert data from different cities. Federal br_tse_elections.candidates TSE political candidate data. Federal br_ibge_pnad.microdata Microdata from the National Household Sample Survey produced by IBGE. Federal br_ibge_pnadc.microdata Microdata from the Continuous National Household Sample Survey (PNAD-C) produced by IBGE. State br_sp_see_teachers.workload Anonymized workload of active teachers in SP state education network. Municipal br_rj_riodejaneiro_cmrj_legislative.votes Voting data from Rio de Janeiro City Council (RJ).","title":"Examples of dataset_id.table_id"},{"location":"en/style_data/#table-formats","text":"Tables should, whenever possible, be in long format, rather than wide .","title":"Table formats"},{"location":"en/style_data/#variable-naming","text":"Variable names must follow some rules: Use existing names in the repository as much as possible. Examples: year , month , municipality_id , state_code , age , position , result , votes , revenue , expense , price , etc. Respect directory table patterns. Be as intuitive, clear, and extensive as possible. Have all lowercase letters (including acronyms), without accents, connected by _ . Do not include connectors like of , the , and , in , etc. Only have the id_ prefix when the variable represents primary keys of entities (that would eventually have a directory table). Examples that have it: municipality_id , state_id , school_id , person_id . Examples that don't: network , location . Important : when the dataset is in English, id becomes a suffix Only have entity suffixes when the column's entity is different from the table's entity. Examples that have it: in a table with entity person , a column about municipal GDP would be called municipality_gdp . Examples that don't: in a table with entity person , person characteristics would be called name , age , sex , etc. List of allowed prefixes name_ , date_ , number_ , quantity_ , proportion_ (percentage variables 0-100%), rate_ , ratio_ , index_ , indicator_ (boolean type variables), type_ , code_ , sequential_ . List of common suffixes _pc (per capita)","title":"Variable naming"},{"location":"en/style_data/#measurement-units","text":"The rule is to keep variables with their original measurement units listed in this code , with the exception of financial variables where we convert old currencies to current ones (e.g. Cruzeiro to Real). We catalog measurement units in standard format in the architecture table. Complete list here Examples: m , km/h , BRL . For deflated financial columns, we list the currency with the base year. Example: a column measured in reais in 2010 has unit BRL_2010 . Variables must always have measurement units with base 1. In other words, having BRL instead of 1000 BRL , or person instead of 1000 persons . This information, as well as other column metadata, is recorded in the architecture table of the table.","title":"Measurement units"},{"location":"en/style_data/#which-variables-to-keep-add-and-remove","text":"We partially normalize our tables and have rules for which variables to include in production. They are: Remove variables from entity names that already exist in directories. Example: remove municipality from the table that already includes municipality_id . Remove variables serving as partitions. Example: remove year and state_code if the table is partitioned in these two dimensions. Add primary keys for each existing entity. Example: add municipality_id to tables that only include municipality_tse . Keep all primary keys that already come with the table, but (1) add relevant keys (e.g. state_code , municipality_id ) and (2) remove irrelevant keys (e.g. region ).","title":"Which variables to keep, add, and remove"},{"location":"en/style_data/#temporal-coverage","text":"Fill in the temporal_coverage column in table, column, and key metadata (in dictionaries) according to the following pattern. General format: initial_date(temporal_unit)final_date initial_date and final_date are in the corresponding temporal unit. Example: table with unit year has coverage 2005(1)2018 . Example: table with unit month has coverage 2005-08(1)2018-12 . Example: table with unit week has coverage 2005-08-01(7)2018-08-31 . Example: table with unit day has coverage 2005-08-01(1)2018-12-31 . Rules for filling in Table metadata Fill in the general format. Column metadata Fill in the general format, except when initial_date or final_date are equal to the table's. In that case, leave it empty. Example: suppose the table's coverage is 2005(1)2018 . If a column appears only in 2012 and exists until 2018, we fill in its coverage as 2012(1) . If a column disappears in 2013, we fill in its coverage as (1)2013 . If a column exists in the same temporal coverage as the table, we fill in its coverage as (1) . Key metadata Fill in the same pattern of columns, but with the reference being the corresponding column, not the table.","title":"Temporal coverage"},{"location":"en/style_data/#cleaning-strings","text":"Categorical variables: initial uppercase and rest lowercase, with accents. Unstructured STRINGs: keep them as they are.","title":"Cleaning STRINGs"},{"location":"en/style_data/#value-formats","text":"Decimal: American format, i.e., always . (dot) instead of , (comma). Date: YYYY-MM-DD Time (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Null value: \"\" (csv), NULL (Python), NA (R), . or \"\" (Stata) Proportion/percentage: between 0-100","title":"Value formats"},{"location":"en/style_data/#table-partitioning","text":"","title":"Table partitioning"},{"location":"en/style_data/#what-is-partitioning-and-what-is-its-goal","text":"In a nutshell, partitioning a table is dividing it into multiple blocks/parts. The central objective is to reduce financial costs and increase performance, as the larger the volume of data, the greater the storage and query costs. The reduction in costs and the increase in performance mainly occur because partitioning allows the data set to be reorganized into small grouped blocks . In practice, by performing the partitioning, it is possible to avoid that a query traverses the entire table just to bring a small data slice. An example of our beloved RAIS: Without using partition filtering: For this case, Bigquery scanned all (*) columns and rows of the dataset. It's worth noting that this cost is still not very large, as the base has already been partitioned. If this dataset hadn't passed through the partition process, this query would have cost a lot more money and time, as it involves a considerable volume of data. With partition filtering: Here, we filter by the partitioned columns year and state_code . As a result, Bigquery only queries and returns the values from the year folder and the state_code subfolder.","title":"What is partitioning and what is its goal?"},{"location":"en/style_data/#when-should-a-table-be-partitioned","text":"The first question that arises when dealing with partitioning is: from which number of lines a table should be partitioned? The documentation of GCP does not define a quantity x or y of lines that should be partitioned. The ideal is that tables are partitioned, with few exceptions. For example, tables with less than 10,000 lines, which will no longer receive data ingestion, do not have high storage and processing costs and, therefore, there is no need to be partitioned.","title":"When should a table be partitioned?"},{"location":"en/style_data/#how-to-partition-a-table","text":"If the data is stored locally, it is necessary: Create the partitioned folders in your /output folder, using the language you are using. Example of a partitioned table by year and month , using python : for year in [ * range ( 2005 , 2020 )]: for month in [ * range ( 1 , 13 )]: partition = output + f 'table_id/year= { year } /month= { month } ' if not os . path . exists ( partition ): os . makedirs ( partition ) 2. Save the partitioned files. for year in [ * range ( 2005 , 2020 )]: for month in [ * range ( 1 , 13 )]: df_partition = df [ df [ 'year' ] == year ] . copy () # The .copy is not necessary, it's just a good practice df_partition = df_partition [ df_partition [ 'month' ] == month ] df_partition . drop ([ 'year' , 'month' ], axis = 1 , inplace = True ) # It's necessary to exclude the columns used for partitioning partition = output + f 'table_id/year= { year } /month= { month } /table.csv' df_partition . to_csv ( partition , index = False , encoding = 'utf-8' , na_rep = '' ) Examples of partitioned tables in R : PNADC PAM Example of how to partition a table in SQL : CREATE TABLE ` dataset_id . table_id ` as ( year INT64 , month INT64 , col1 STRING , col1 STRING ) PARTITION BY year , month OPTIONS ( Description = 'Description of the table' )","title":"How to partition a table?"},{"location":"en/style_data/#important-rules-for-partitioning","text":"The types of columns that BigQuery accepts as partitioning are: Time unit column : tables are partitioned based on a TIMESTAMP , DATE or DATETIME column. Processing time : tables are partitioned based on the data/time stamp when BigQuery processes the data. Range of integers : tables are partitioned based on a column of integers. The types of columns that BigQuery does not accept as partitioning are: BOOL , FLOAT64 , BYTES , etc. BigQuery accepts up to 4,000 partitions per table. In our BD, tables are usually partitioned by: year , month , quarter , and state_code . Note that when partitioning a table, it is necessary to exclude the corresponding column. Example: it is necessary to exclude the year column when partitioning by year .","title":"Important rules for partitioning."},{"location":"en/style_data/#number-of-bases-per-pull-request","text":"Pull requests on Github should include a maximum of one dataset, but can include more than one base. In other words, they can involve one or more tables within the same dataset.","title":"Number of bases per pull request"},{"location":"en/style_data/#dictionaries","text":"Each base includes only one dictionary (which covers one or more tables). For each table, column, and temporal coverage, each key maps uniquely to a value. Keys cannot have null values. Dictionaries must cover all available keys in the original tables. Keys can only have zeros to the left when the variable's number of digits has meaning. When the variable is enum default, we exclude the zeros to the left. Example: we keep the zero to the left of the variable br_bd_diretorios_brasil.cbo_2002:cbo_2002 , which has six digits, because the first digit 0 means the category is from the grand group = \"Members of the armed forces, police, and firefighters\" . For other cases, such as br_inep_censo_escolar.stage:stage_education , we exclude the zeros to the left. In other words, we change 01 to 1 . Values are standardized: without extra spaces, initial uppercase and rest lowercase, etc.","title":"Dictionaries"},{"location":"en/style_data/#how-to-fill-in-the-table-dictionary-metadata","text":"Do not fill in the spatial_coverage ( spatial_coverage ), i.e., leave the field empty. Do not fill in the temporal_coverage ( temporal_coverage ), i.e., leave the field empty. Do not fill in the observation_level ( observation_level ), i.e., leave the field empty.","title":"How to fill in the table dictionary metadata?"},{"location":"en/style_data/#directories","text":"Directories are the fundamental building blocks of our datalake . Our rules for managing directories are: Directories represent entities of the repository that have primary keys (e.g., state , municipality , school ) and time-based units (e.g., data , time , day , month , year ). Each directory table has at least one primary key with unique values and no nulls. Examples: municipality:municipality_id , state:state_code . Variable names with the id_ prefix are reserved for primary keys of entities. See all the tables already available here.","title":"Directories"},{"location":"en/style_data/#how-to-fill-in-the-directory-table-metadata","text":"Fill in the spatial_coverage ( spatial_coverage ), which is the maximum spatial unit that the table covers. Example: sa.br, which means that the spatial aggregation level of the table is Brazil. Do not fill in the temporal_coverage ( temporal_coverage ), i.e., leave the field empty. Fill in the observation_level ( observation_level ), which consists of the observation level of the table, i.e., what each line represents. Do not fill in the temporal_coverage ( temporal_coverage ) of the columns of the table, i.e., leave the field empty.","title":"How to fill in the directory table metadata?"},{"location":"en/style_data/#raw-data-sources","text":"The field refers to the data in the raw data source, which has not yet passed through the Data Basis methodology, i.e., our _input_ . When you click on it, the idea is to redirect the user to the original data source page. Our rules for managing the raw data sources are: Include the name of the external link that leads to the raw data source. As a default, this name should be the organization's name or the portal's name that stores the data. Examples: Educational Statistics: Open Data from Inep , Penn World Tables: Groningen Growth and Development Centre . Fill in the raw data source metadata: Description, URL, Language, Has Structured Data, Has an API, Is Free, Requires Registration, Availability, Requires IP from Some Country, License Type, Temporal Coverage, Spatial Coverage, and Observation Level.","title":"Raw Data Sources"},{"location":"en/style_data/#thought-of-improvements-for-the-standards-defined","text":"Open an issue on our Github or send a message on Discord to talk to us :)","title":"Thought of improvements for the standards defined?"},{"location":"en/tutorial_join_tables/","text":"How to join tables in the data lake We organize the data so that joining tables from different institutions and themes is as simple as any other query. For this, we defined a standard methodology for data treatment, column naming, tables, and datasets. How does the DB methodology work? Information from different tables can be aggregated through identifier keys . An identifier key is a column whose name is unique across all tables in the data lake and is used to identify an entity. Example of an identifier key The year column has the same name in all data lake tables - it always refers to the variable that has any years from our calendar as its value. When working with IBGE population data, the year column, along with the municipality column, uniquely identify each row in the table: There is no more than one row with the same year and municipality; There is no row with null values for year or municipality in the table; Test it yourself: the queries below should return empty! R library ( \"basedosdados\" ) # Search for any row that has repeated year and municipality query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipio` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Search for rows with null year or municipality query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipio` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Search for any row that has repeated year and municipality query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipio` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Search for rows with null year or municipality query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipio` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ... Crossing tables with identifier keys The indication of a set of columns as an identifier key is made directly in the table metadata. Thus, you can know which tables can be crossed by comparing the set of identifier keys of each one. Below we'll make an example of how to cross IBGE's population and GDP tables to obtain the GDP per capita of all Brazilian municipalities. In the population and GDP tables, the year and municipality columns are identifier keys. Therefore, we'll use these columns in our JOIN function to determine how to cross the tables. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # You can download to your computer dir <- tempdir () data <- download ( query , file.path ( dir , \"gdp_per_capita.csv\" )) # Or load the query result into your analysis environment data <- read_sql ( query ) Python import basedosdados as bd gdp_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # You can download to your computer bd . download ( query = gdp_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # Or load the query result into pandas df = bd . read_sql ( gdp_per_capita , billing_project_id =< YOUR_PROJECT_ID > ) List of identifier keys Geographic keys Census tract: id_setor_censitario Municipality: id_municipio (standard), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb Minimum Comparable Area: id_AMC Immediate region: id_regiao_imediata Intermediate region: id_regiao_intermediaria Microregion: id_microrregiao Mesoregion: id_mesorregiao Federal unit (State): sigla_uf (standard), id_uf , uf Region: regiao Time keys ano (year), semestre (semester), mes (month), semana (week), dia (day), hora (hour) Individual person keys cpf , pis , nis Legal entity keys Company: cnpj School: id_escola Political keys Candidate: id_candidato_bd Party: sigla_partido , partido","title":"How to join tables in the data lake"},{"location":"en/tutorial_join_tables/#how-to-join-tables-in-the-data-lake","text":"We organize the data so that joining tables from different institutions and themes is as simple as any other query. For this, we defined a standard methodology for data treatment, column naming, tables, and datasets. How does the DB methodology work? Information from different tables can be aggregated through identifier keys . An identifier key is a column whose name is unique across all tables in the data lake and is used to identify an entity.","title":"How to join tables in the data lake"},{"location":"en/tutorial_join_tables/#example-of-an-identifier-key","text":"The year column has the same name in all data lake tables - it always refers to the variable that has any years from our calendar as its value. When working with IBGE population data, the year column, along with the municipality column, uniquely identify each row in the table: There is no more than one row with the same year and municipality; There is no row with null values for year or municipality in the table; Test it yourself: the queries below should return empty! R library ( \"basedosdados\" ) # Search for any row that has repeated year and municipality query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipio` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Search for rows with null year or municipality query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipio` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Search for any row that has repeated year and municipality query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipio` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Search for rows with null year or municipality query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipio` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ...","title":"Example of an identifier key"},{"location":"en/tutorial_join_tables/#crossing-tables-with-identifier-keys","text":"The indication of a set of columns as an identifier key is made directly in the table metadata. Thus, you can know which tables can be crossed by comparing the set of identifier keys of each one. Below we'll make an example of how to cross IBGE's population and GDP tables to obtain the GDP per capita of all Brazilian municipalities. In the population and GDP tables, the year and municipality columns are identifier keys. Therefore, we'll use these columns in our JOIN function to determine how to cross the tables. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # You can download to your computer dir <- tempdir () data <- download ( query , file.path ( dir , \"gdp_per_capita.csv\" )) # Or load the query result into your analysis environment data <- read_sql ( query ) Python import basedosdados as bd gdp_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # You can download to your computer bd . download ( query = gdp_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # Or load the query result into pandas df = bd . read_sql ( gdp_per_capita , billing_project_id =< YOUR_PROJECT_ID > )","title":"Crossing tables with identifier keys"},{"location":"en/tutorial_join_tables/#list-of-identifier-keys","text":"","title":"List of identifier keys"},{"location":"en/tutorial_join_tables/#geographic-keys","text":"Census tract: id_setor_censitario Municipality: id_municipio (standard), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb Minimum Comparable Area: id_AMC Immediate region: id_regiao_imediata Intermediate region: id_regiao_intermediaria Microregion: id_microrregiao Mesoregion: id_mesorregiao Federal unit (State): sigla_uf (standard), id_uf , uf Region: regiao","title":"Geographic keys"},{"location":"en/tutorial_join_tables/#time-keys","text":"ano (year), semestre (semester), mes (month), semana (week), dia (day), hora (hour)","title":"Time keys"},{"location":"en/tutorial_join_tables/#individual-person-keys","text":"cpf , pis , nis","title":"Individual person keys"},{"location":"en/tutorial_join_tables/#legal-entity-keys","text":"Company: cnpj School: id_escola","title":"Legal entity keys"},{"location":"en/tutorial_join_tables/#political-keys","text":"Candidate: id_candidato_bd Party: sigla_partido , partido","title":"Political keys"},{"location":"es/","text":"Hello, world! La misi\u00f3n de Base de los Datos es universalizar el uso de datos de calidad en Brasil y el mundo. Para ello, creamos una herramienta que te permite acceder a recursos importantes de diversos conjuntos de datos p\u00fablicos , como: Tablas procesadas BD+ : Tablas completas, ya procesadas y listas para an\u00e1lisis, disponibles en nuestro datalake p\u00fablico. Datos originales : Enlaces con informaci\u00f3n \u00fatil para explorar m\u00e1s sobre el conjunto de datos, como la fuente original y otros. Tenemos un equipo de Datos y voluntarios(as) de todo Brasil que ayudan a limpiar y mantener las tablas procesadas. Aprende c\u00f3mo formar parte Accediendo a tablas procesadas BD+ En nuestro sitio encontrar\u00e1s la lista de todas las tablas procesadas de cada conjunto de datos. Tambi\u00e9n presentamos informaci\u00f3n importante de todas las tablas, como la lista de columnas, cobertura temporal, periodicidad, entre otra informaci\u00f3n. Puedes consultar los datos de las tablas v\u00eda: Descarga Puedes descargar el archivo CSV completo de la tabla directamente en el sitio. Este tipo de consulta no est\u00e1 disponible para archivos que excedan 200 mil filas. BigQuery (SQL) BigQuery es un servicio de base de datos en la nube de Google. Directamente desde el navegador, puedes realizar consultas a las tablas procesadas con: Rapidez: Incluso las consultas muy largas tardan solo minutos en procesarse. Escala: BigQuery escala m\u00e1gicamente a hexabytes si es necesario. Econom\u00eda: Cada usuario tiene 1 TB gratuito por mes para consultar los datos . Aprende Paquetes Los paquetes de Base de los Datos permiten el acceso al data lake p\u00fablico directamente desde tu computadora o entorno de desarrollo. Los paquetes actualmente disponibles son: Python R Stata Aprende Consejos para un mejor uso de los datos Nuestro equipo de datos trabaja constantemente en desarrollar mejores est\u00e1ndares y metodolog\u00edas para facilitar el proceso de an\u00e1lisis de datos. Hemos separado algunos materiales \u00fatiles para que entiendas mejor lo que hacemos y c\u00f3mo sacar el mejor provecho de los datos: Cruzar datos de diferentes organizaciones de forma r\u00e1pida Entender patrones de tablas, conjuntos y variables","title":"Home"},{"location":"es/#hello-world","text":"La misi\u00f3n de Base de los Datos es universalizar el uso de datos de calidad en Brasil y el mundo. Para ello, creamos una herramienta que te permite acceder a recursos importantes de diversos conjuntos de datos p\u00fablicos , como: Tablas procesadas BD+ : Tablas completas, ya procesadas y listas para an\u00e1lisis, disponibles en nuestro datalake p\u00fablico. Datos originales : Enlaces con informaci\u00f3n \u00fatil para explorar m\u00e1s sobre el conjunto de datos, como la fuente original y otros. Tenemos un equipo de Datos y voluntarios(as) de todo Brasil que ayudan a limpiar y mantener las tablas procesadas. Aprende c\u00f3mo formar parte","title":"Hello, world!"},{"location":"es/#accediendo-a-tablas-procesadas-bd","text":"En nuestro sitio encontrar\u00e1s la lista de todas las tablas procesadas de cada conjunto de datos. Tambi\u00e9n presentamos informaci\u00f3n importante de todas las tablas, como la lista de columnas, cobertura temporal, periodicidad, entre otra informaci\u00f3n. Puedes consultar los datos de las tablas v\u00eda:","title":"Accediendo a tablas procesadas BD+"},{"location":"es/#descarga","text":"Puedes descargar el archivo CSV completo de la tabla directamente en el sitio. Este tipo de consulta no est\u00e1 disponible para archivos que excedan 200 mil filas.","title":"Descarga"},{"location":"es/#bigquery-sql","text":"BigQuery es un servicio de base de datos en la nube de Google. Directamente desde el navegador, puedes realizar consultas a las tablas procesadas con: Rapidez: Incluso las consultas muy largas tardan solo minutos en procesarse. Escala: BigQuery escala m\u00e1gicamente a hexabytes si es necesario. Econom\u00eda: Cada usuario tiene 1 TB gratuito por mes para consultar los datos . Aprende","title":"BigQuery (SQL)"},{"location":"es/#paquetes","text":"Los paquetes de Base de los Datos permiten el acceso al data lake p\u00fablico directamente desde tu computadora o entorno de desarrollo. Los paquetes actualmente disponibles son: Python R Stata Aprende","title":"Paquetes"},{"location":"es/#consejos-para-un-mejor-uso-de-los-datos","text":"Nuestro equipo de datos trabaja constantemente en desarrollar mejores est\u00e1ndares y metodolog\u00edas para facilitar el proceso de an\u00e1lisis de datos. Hemos separado algunos materiales \u00fatiles para que entiendas mejor lo que hacemos y c\u00f3mo sacar el mejor provecho de los datos: Cruzar datos de diferentes organizaciones de forma r\u00e1pida Entender patrones de tablas, conjuntos y variables","title":"Consejos para un mejor uso de los datos"},{"location":"es/access_data_bq/","text":"BigQuery BigQuery es el servicio de base de datos en la nube de Google. Puedes hacer consultas a la base de datos en SQL directamente desde el navegador con: Rapidez : Incluso las consultas muy largas tardan solo minutos en procesarse. Escala : BigQuery escala m\u00e1gicamente a hexabytes si es necesario. Econom\u00eda : Cada usuario tiene 1 TB gratuito por mes para consultar los datos . \u00bfListo(a) para empezar? En esta p\u00e1gina encontrar\u00e1s: Primeros pasos Entiende el uso gratuito de Big Query BQ Tutoriales Manuales y Cursos de SQL Primeros pasos Antes de empezar: Crea tu proyecto en Google Cloud Para crear un proyecto en Google Cloud solo necesitas tener un correo registrado en Google. Es necesario tener un proyecto propio, aunque est\u00e9 vac\u00edo, para poder hacer consultas en nuestro datalake p\u00fablico. Accede a Google Cloud . Si es tu primera vez, acepta los T\u00e9rminos de Servicio. Haz clic en Create Project/Crear Proyecto . Elige un nombre atractivo para el proyecto. Haz clic en Create/Crear \u00bfPor qu\u00e9 necesito crear un proyecto en Google Cloud? Google proporciona 1 TB gratuito por mes de uso de BigQuery para cada proyecto que posees. Un proyecto es necesario para activar los servicios de Google Cloud, incluyendo el permiso de uso de BigQuery. Piensa en el proyecto como la \"cuenta\" en la que Google contabilizar\u00e1 cu\u00e1nto procesamiento has utilizado. No es necesario agregar ninguna tarjeta o forma de pago - BigQuery inicia autom\u00e1ticamente en modo Sandbox, que te permite utilizar sus recursos sin agregar un m\u00e9todo de pago. Lee m\u00e1s aqu\u00ed . Accediendo al datalake de Base de los Datos El bot\u00f3n de abajo te dirigir\u00e1 a nuestro proyecto en Google BigQuery: Ir a BigQuery Ahora necesitas fijar el proyecto de BD en tu BigQuery, es muy simple, mira: !!! Warning La opci\u00f3n Fijar un proyecto puede aparecer tambi\u00e9n como Marcar proyecto con estrella por nombre Dentro del proyecto existen dos niveles de organizaci\u00f3n de los datos, datasets (conjuntos de datos) y tables (tablas), en los cuales: Todas las tablas est\u00e1n organizadas dentro de conjuntos de datos , que representan su organizaci\u00f3n/tema (ej: el conjunto br_ibge_populacao contiene una tabla municipio con la serie hist\u00f3rica de poblaci\u00f3n a nivel municipal) Cada tabla pertenece a un \u00fanico conjunto de datos (ej: la tabla municipio en br_ibge_populacao es diferente de municipio en br_bd_diretorios_brasil ) Mira aqu\u00ed la gu\u00eda de Google sobre c\u00f3mo funciona la interfaz de BigQuery . Si no aparecen las tablas la primera vez que accedes, actualiza la p\u00e1gina. \u00a1Haz tu primera consulta! \u00bfQu\u00e9 tal hacer una consulta simple? Vamos a usar el Editor de Consultas de BigQuery para ver la informaci\u00f3n sobre municipios directamente en nuestra base de directorios brasile\u00f1os. Para esto, copia y pega el c\u00f3digo siguiente: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` \u00a1Solo haz clic en Ejecutar y listo! Consejo Haciendo clic en el bot\u00f3n \ud83d\udd0d Consultar tabla/Query View , BigQuery crea autom\u00e1ticamente la estructura b\u00e1sica de tu consulta en Query Editor/Editor de consultas - solo necesitas completar con los campos y filtros que consideres necesarios. Entiende el uso gratuito de Big Query BQ Esta secci\u00f3n est\u00e1 dedicada a presentar consejos sobre c\u00f3mo reducir costos de procesamiento para aprovechar al m\u00e1ximo los datos de BD. Para usuarios que acceden a los datos en proyectos p\u00fablicos como el de Base de los Datos, el \u00fanico tipo de costo asociado se refiere al costo de procesamiento de las consultas . La buena noticia, como se mencion\u00f3 arriba, es que cada usuario tiene 1 TB gratuito por mes para consultar libremente los datos del mayor data lake p\u00fablico de Brasil . Si a\u00fan no tienes un proyecto en BQ, consulta la secci\u00f3n anterior para crearlo. Conocer lo b\u00e1sico de la interfaz de BQ es importante para entender el art\u00edculo. Si no est\u00e1s familiarizado o quieres revisar la interfaz, sugerimos 3 rutas: Nuestra gu\u00eda utilizando las tablas de RAIS - Relaci\u00f3n Anual de Informaciones Sociales Nuestro acervo de videos en YouTube La introducci\u00f3n a la interfaz hecha por Google Ve c\u00f3mo aprovechar al m\u00e1ximo las consultas gratuitas En esta secci\u00f3n, presentamos algunos consejos simples para reducir los costos de las consultas en Big Query y \u00a1aprovechar al m\u00e1ximo los datos de BD! Antes de pasar a los ejemplos, presentaremos el mecanismo b\u00e1sico de previsi\u00f3n de costos de procesamiento de consultas en Big Query (BQ). Estimaciones de costos En la esquina superior derecha de la interfaz de BQ se muestra un aviso con la estimaci\u00f3n del costo de procesamiento que se cobrar\u00e1 a tu proyecto despu\u00e9s de ejecutar la consulta. Este es el mecanismo b\u00e1sico y f\u00e1cilmente accesible de previsibilidad de los costos de procesamiento. Desafortunadamente, no funciona para todas las tablas. Por motivos de limitaci\u00f3n interna del propio Big Query, las consultas a tablas espec\u00edficas no muestran estimaciones de costos. Es el caso de las tablas que tienen Row Access Policy . Es decir, tablas donde el n\u00famero de filas accesibles est\u00e1 limitado seg\u00fan el usuario. Este es el caso de las tablas que forman parte del servicio BD Pro Ejemplo de la tabla agencia del conjunto br_bcb_estban . { width=100% } CONSEJO 1: Selecciona solo las columnas de inter\u00e9s La arquitectura de BigQuery utiliza el almacenamiento orientado a columnas, es decir, cada columna se almacena separadamente. Esta caracter\u00edstica tiene una implicaci\u00f3n clara en cuanto a los costos de procesamiento: cuantas m\u00e1s columnas se seleccionen, mayor ser\u00e1 el costo. Evita : Seleccionar columnas en exceso SELECT * Pr\u00e1ctica recomendada : selecciona solo las columnas de inter\u00e9s para reducir el costo final de la consulta. SELECT columna1 , columna2 - Mira esta diferencia obtenida con la tabla microdados del conjunto br_ms_sim . Sin selecci\u00f3n de columnas: costo estimado 5.83 GB Seleccionando 3 columnas: costo estimado 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` Para entender m\u00e1s a fondo la arquitectura columnar, consulta la documentaci\u00f3n oficial de Big Query CONSEJO 2: Utiliza columnas particionadas y clusterizadas para filtrar los datos Las particiones son divisiones hechas en una tabla para facilitar la gesti\u00f3n y la consulta de los datos. En el momento de ejecutar la consulta, Big Query ignora las filas que tienen un valor de partici\u00f3n diferente al utilizado en el filtro. Esto normalmente reduce significativamente la cantidad de filas le\u00eddas y, lo que nos interesa, reduce el costo de procesamiento . Los clusters son agrupaciones organizadas en una tabla basadas en los valores de una o m\u00e1s columnas especificadas. Durante la ejecuci\u00f3n de una consulta, BigQuery optimiza la lectura de los datos, accediendo solo a los segmentos que contienen los valores relevantes de las columnas de cluster. Esto significa que, en lugar de escanear toda la tabla, solo se leen las partes necesarias, lo que generalmente reduce la cantidad de datos procesados y, consecuentemente, reduce el costo de procesamiento. \u00bfC\u00f3mo saber qu\u00e9 columna se utiliz\u00f3 para particionar y clusterizar una tabla espec\u00edfica? Por los metadatos en la p\u00e1gina de tabla en el sitio de BD Nota que el campo Particiones en Big Query enumera tanto las particiones como los clusters. Por los metadatos en la p\u00e1gina de 'Detalles' en Big Query Nota que se enumeran ambas informaciones: particiones y clusters . En este caso, la columna a\u00f1o fue definida como partici\u00f3n y la columna sigla_uf como cluster. Pr\u00e1ctica recomendada : siempre que sea posible, utiliza columnas particionadas y clusterizadas para filtrar/agregar los datos. Ejemplo Consulta utilizando la columna particionada como filtro: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 costo estimado : 31.32 MB. La combinaci\u00f3n de t\u00e9cnicas de selecci\u00f3n de columnas y filtro utilizando partici\u00f3n redujo el costo estimado de la consulta inicial de 5.83 GB a solo 31.32 MB CONSEJO 3: Mucha atenci\u00f3n al realizar joins entre tablas Eval\u00faa la necesidad real del JOIN Aseg\u00farate de que el join es realmente necesario para el an\u00e1lisis que est\u00e1s realizando. A veces, operaciones alternativas como subconsultas o agregaciones pueden ser m\u00e1s eficientes. Entiende la L\u00f3gica del JOIN Diferentes tipos de joins (INNER, LEFT, RIGHT, FULL) tienen diferentes implicaciones de rendimiento y resultado. Dedicar un tiempo a entender la mejor opci\u00f3n para tu objetivo de an\u00e1lisis puede ayudar a tener un control de costos m\u00e1s eficiente. Uno de los problemas m\u00e1s comunes es la multiplicaci\u00f3n de filas indeseadas en el resultado final. Para entender a fondo buenas pr\u00e1cticas y problemas recurrentes con joins sugerimos las gu\u00edas SQL Joins en la pr\u00e1ctica y Maximizando la Eficiencia con JOIN en Consultas SQL para Combinar Tablas Utiliza los consejos anteriores Selecciona solo columnas de inter\u00e9s Haz uso de las columnas particionadas para filtrar los datos Presta atenci\u00f3n a la estimaci\u00f3n de costos antes de ejecutar la consulta Tutoriales C\u00f3mo navegar por BigQuery Para entender m\u00e1s sobre la interfaz de BigQuery y c\u00f3mo explorar los datos, preparamos un texto completo en el blog con un ejemplo de b\u00fasqueda de los datos de RAIS - Ministerio de Econom\u00eda . \u00bfCansado(a) de la lectura? Tambi\u00e9n tenemos un video completo en nuestro Youtube . Entiende los datos BigQuery tiene un mecanismo de b\u00fasqueda que permite buscar por nombres de datasets (conjuntos), tables (tablas) o labels (grupos). Construimos reglas de nomenclatura simples y pr\u00e1cticas para facilitar tu b\u00fasqueda - ver m\u00e1s . Conectando con PowerBI Power BI es una de las tecnolog\u00edas m\u00e1s populares para el desarrollo de dashboards con datos relacionales. Por eso, preparamos un tutorial para que descubras c\u00f3mo usar los datos del data lake en el desarrollo de tus dashboards . Manuales y Cursos de SQL \u00bfEst\u00e1s empezando a aprender sobre SQL para hacer tus consultas? Abajo colocamos algunas recomendaciones usadas por nuestro equipo tanto en el aprendizaje como en el d\u00eda a d\u00eda: Lista de funciones en SQL de W3 Curso SQL en Codeacademy Curso de SQL de Programaci\u00f3n Din\u00e1mica","title":"BigQuery"},{"location":"es/access_data_bq/#bigquery","text":"BigQuery es el servicio de base de datos en la nube de Google. Puedes hacer consultas a la base de datos en SQL directamente desde el navegador con: Rapidez : Incluso las consultas muy largas tardan solo minutos en procesarse. Escala : BigQuery escala m\u00e1gicamente a hexabytes si es necesario. Econom\u00eda : Cada usuario tiene 1 TB gratuito por mes para consultar los datos . \u00bfListo(a) para empezar? En esta p\u00e1gina encontrar\u00e1s: Primeros pasos Entiende el uso gratuito de Big Query BQ Tutoriales Manuales y Cursos de SQL","title":"BigQuery"},{"location":"es/access_data_bq/#primeros-pasos","text":"","title":"Primeros pasos"},{"location":"es/access_data_bq/#antes-de-empezar-crea-tu-proyecto-en-google-cloud","text":"Para crear un proyecto en Google Cloud solo necesitas tener un correo registrado en Google. Es necesario tener un proyecto propio, aunque est\u00e9 vac\u00edo, para poder hacer consultas en nuestro datalake p\u00fablico. Accede a Google Cloud . Si es tu primera vez, acepta los T\u00e9rminos de Servicio. Haz clic en Create Project/Crear Proyecto . Elige un nombre atractivo para el proyecto. Haz clic en Create/Crear \u00bfPor qu\u00e9 necesito crear un proyecto en Google Cloud? Google proporciona 1 TB gratuito por mes de uso de BigQuery para cada proyecto que posees. Un proyecto es necesario para activar los servicios de Google Cloud, incluyendo el permiso de uso de BigQuery. Piensa en el proyecto como la \"cuenta\" en la que Google contabilizar\u00e1 cu\u00e1nto procesamiento has utilizado. No es necesario agregar ninguna tarjeta o forma de pago - BigQuery inicia autom\u00e1ticamente en modo Sandbox, que te permite utilizar sus recursos sin agregar un m\u00e9todo de pago. Lee m\u00e1s aqu\u00ed .","title":"Antes de empezar: Crea tu proyecto en Google Cloud"},{"location":"es/access_data_bq/#accediendo-al-datalake-de-base-de-los-datos","text":"El bot\u00f3n de abajo te dirigir\u00e1 a nuestro proyecto en Google BigQuery: Ir a BigQuery Ahora necesitas fijar el proyecto de BD en tu BigQuery, es muy simple, mira: !!! Warning La opci\u00f3n Fijar un proyecto puede aparecer tambi\u00e9n como Marcar proyecto con estrella por nombre Dentro del proyecto existen dos niveles de organizaci\u00f3n de los datos, datasets (conjuntos de datos) y tables (tablas), en los cuales: Todas las tablas est\u00e1n organizadas dentro de conjuntos de datos , que representan su organizaci\u00f3n/tema (ej: el conjunto br_ibge_populacao contiene una tabla municipio con la serie hist\u00f3rica de poblaci\u00f3n a nivel municipal) Cada tabla pertenece a un \u00fanico conjunto de datos (ej: la tabla municipio en br_ibge_populacao es diferente de municipio en br_bd_diretorios_brasil ) Mira aqu\u00ed la gu\u00eda de Google sobre c\u00f3mo funciona la interfaz de BigQuery . Si no aparecen las tablas la primera vez que accedes, actualiza la p\u00e1gina.","title":"Accediendo al datalake de Base de los Datos"},{"location":"es/access_data_bq/#haz-tu-primera-consulta","text":"\u00bfQu\u00e9 tal hacer una consulta simple? Vamos a usar el Editor de Consultas de BigQuery para ver la informaci\u00f3n sobre municipios directamente en nuestra base de directorios brasile\u00f1os. Para esto, copia y pega el c\u00f3digo siguiente: SELECT * FROM ` basedosdados . br_bd_diretorios_brasil . municipio ` \u00a1Solo haz clic en Ejecutar y listo! Consejo Haciendo clic en el bot\u00f3n \ud83d\udd0d Consultar tabla/Query View , BigQuery crea autom\u00e1ticamente la estructura b\u00e1sica de tu consulta en Query Editor/Editor de consultas - solo necesitas completar con los campos y filtros que consideres necesarios.","title":"\u00a1Haz tu primera consulta!"},{"location":"es/access_data_bq/#entiende-el-uso-gratuito-de-big-query-bq","text":"Esta secci\u00f3n est\u00e1 dedicada a presentar consejos sobre c\u00f3mo reducir costos de procesamiento para aprovechar al m\u00e1ximo los datos de BD. Para usuarios que acceden a los datos en proyectos p\u00fablicos como el de Base de los Datos, el \u00fanico tipo de costo asociado se refiere al costo de procesamiento de las consultas . La buena noticia, como se mencion\u00f3 arriba, es que cada usuario tiene 1 TB gratuito por mes para consultar libremente los datos del mayor data lake p\u00fablico de Brasil . Si a\u00fan no tienes un proyecto en BQ, consulta la secci\u00f3n anterior para crearlo. Conocer lo b\u00e1sico de la interfaz de BQ es importante para entender el art\u00edculo. Si no est\u00e1s familiarizado o quieres revisar la interfaz, sugerimos 3 rutas: Nuestra gu\u00eda utilizando las tablas de RAIS - Relaci\u00f3n Anual de Informaciones Sociales Nuestro acervo de videos en YouTube La introducci\u00f3n a la interfaz hecha por Google","title":"Entiende el uso gratuito de Big Query BQ"},{"location":"es/access_data_bq/#ve-como-aprovechar-al-maximo-las-consultas-gratuitas","text":"En esta secci\u00f3n, presentamos algunos consejos simples para reducir los costos de las consultas en Big Query y \u00a1aprovechar al m\u00e1ximo los datos de BD! Antes de pasar a los ejemplos, presentaremos el mecanismo b\u00e1sico de previsi\u00f3n de costos de procesamiento de consultas en Big Query (BQ). Estimaciones de costos En la esquina superior derecha de la interfaz de BQ se muestra un aviso con la estimaci\u00f3n del costo de procesamiento que se cobrar\u00e1 a tu proyecto despu\u00e9s de ejecutar la consulta. Este es el mecanismo b\u00e1sico y f\u00e1cilmente accesible de previsibilidad de los costos de procesamiento. Desafortunadamente, no funciona para todas las tablas. Por motivos de limitaci\u00f3n interna del propio Big Query, las consultas a tablas espec\u00edficas no muestran estimaciones de costos. Es el caso de las tablas que tienen Row Access Policy . Es decir, tablas donde el n\u00famero de filas accesibles est\u00e1 limitado seg\u00fan el usuario. Este es el caso de las tablas que forman parte del servicio BD Pro Ejemplo de la tabla agencia del conjunto br_bcb_estban . { width=100% }","title":"Ve c\u00f3mo aprovechar al m\u00e1ximo las consultas gratuitas"},{"location":"es/access_data_bq/#consejo-1-selecciona-solo-las-columnas-de-interes","text":"La arquitectura de BigQuery utiliza el almacenamiento orientado a columnas, es decir, cada columna se almacena separadamente. Esta caracter\u00edstica tiene una implicaci\u00f3n clara en cuanto a los costos de procesamiento: cuantas m\u00e1s columnas se seleccionen, mayor ser\u00e1 el costo. Evita : Seleccionar columnas en exceso SELECT * Pr\u00e1ctica recomendada : selecciona solo las columnas de inter\u00e9s para reducir el costo final de la consulta. SELECT columna1 , columna2 - Mira esta diferencia obtenida con la tabla microdados del conjunto br_ms_sim . Sin selecci\u00f3n de columnas: costo estimado 5.83 GB Seleccionando 3 columnas: costo estimado 0.531 GB (531 MB) SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` Para entender m\u00e1s a fondo la arquitectura columnar, consulta la documentaci\u00f3n oficial de Big Query","title":"CONSEJO 1: Selecciona solo las columnas de inter\u00e9s"},{"location":"es/access_data_bq/#consejo-2-utiliza-columnas-particionadas-y-clusterizadas-para-filtrar-los-datos","text":"Las particiones son divisiones hechas en una tabla para facilitar la gesti\u00f3n y la consulta de los datos. En el momento de ejecutar la consulta, Big Query ignora las filas que tienen un valor de partici\u00f3n diferente al utilizado en el filtro. Esto normalmente reduce significativamente la cantidad de filas le\u00eddas y, lo que nos interesa, reduce el costo de procesamiento . Los clusters son agrupaciones organizadas en una tabla basadas en los valores de una o m\u00e1s columnas especificadas. Durante la ejecuci\u00f3n de una consulta, BigQuery optimiza la lectura de los datos, accediendo solo a los segmentos que contienen los valores relevantes de las columnas de cluster. Esto significa que, en lugar de escanear toda la tabla, solo se leen las partes necesarias, lo que generalmente reduce la cantidad de datos procesados y, consecuentemente, reduce el costo de procesamiento. \u00bfC\u00f3mo saber qu\u00e9 columna se utiliz\u00f3 para particionar y clusterizar una tabla espec\u00edfica? Por los metadatos en la p\u00e1gina de tabla en el sitio de BD Nota que el campo Particiones en Big Query enumera tanto las particiones como los clusters. Por los metadatos en la p\u00e1gina de 'Detalles' en Big Query Nota que se enumeran ambas informaciones: particiones y clusters . En este caso, la columna a\u00f1o fue definida como partici\u00f3n y la columna sigla_uf como cluster. Pr\u00e1ctica recomendada : siempre que sea posible, utiliza columnas particionadas y clusterizadas para filtrar/agregar los datos. Ejemplo Consulta utilizando la columna particionada como filtro: SELECT sequencial_obito , tipo_obito , data_obito FROM ` basedosdados . br_ms_sim . microdados ` where ano = 2015 costo estimado : 31.32 MB. La combinaci\u00f3n de t\u00e9cnicas de selecci\u00f3n de columnas y filtro utilizando partici\u00f3n redujo el costo estimado de la consulta inicial de 5.83 GB a solo 31.32 MB","title":"CONSEJO 2: Utiliza columnas particionadas y clusterizadas para filtrar los datos"},{"location":"es/access_data_bq/#consejo-3-mucha-atencion-al-realizar-joins-entre-tablas","text":"Eval\u00faa la necesidad real del JOIN Aseg\u00farate de que el join es realmente necesario para el an\u00e1lisis que est\u00e1s realizando. A veces, operaciones alternativas como subconsultas o agregaciones pueden ser m\u00e1s eficientes. Entiende la L\u00f3gica del JOIN Diferentes tipos de joins (INNER, LEFT, RIGHT, FULL) tienen diferentes implicaciones de rendimiento y resultado. Dedicar un tiempo a entender la mejor opci\u00f3n para tu objetivo de an\u00e1lisis puede ayudar a tener un control de costos m\u00e1s eficiente. Uno de los problemas m\u00e1s comunes es la multiplicaci\u00f3n de filas indeseadas en el resultado final. Para entender a fondo buenas pr\u00e1cticas y problemas recurrentes con joins sugerimos las gu\u00edas SQL Joins en la pr\u00e1ctica y Maximizando la Eficiencia con JOIN en Consultas SQL para Combinar Tablas Utiliza los consejos anteriores Selecciona solo columnas de inter\u00e9s Haz uso de las columnas particionadas para filtrar los datos Presta atenci\u00f3n a la estimaci\u00f3n de costos antes de ejecutar la consulta","title":"CONSEJO 3: Mucha atenci\u00f3n al realizar joins entre tablas"},{"location":"es/access_data_bq/#tutoriales","text":"","title":"Tutoriales"},{"location":"es/access_data_bq/#como-navegar-por-bigquery","text":"Para entender m\u00e1s sobre la interfaz de BigQuery y c\u00f3mo explorar los datos, preparamos un texto completo en el blog con un ejemplo de b\u00fasqueda de los datos de RAIS - Ministerio de Econom\u00eda . \u00bfCansado(a) de la lectura? Tambi\u00e9n tenemos un video completo en nuestro Youtube .","title":"C\u00f3mo navegar por BigQuery"},{"location":"es/access_data_bq/#entiende-los-datos","text":"BigQuery tiene un mecanismo de b\u00fasqueda que permite buscar por nombres de datasets (conjuntos), tables (tablas) o labels (grupos). Construimos reglas de nomenclatura simples y pr\u00e1cticas para facilitar tu b\u00fasqueda - ver m\u00e1s .","title":"Entiende los datos"},{"location":"es/access_data_bq/#conectando-con-powerbi","text":"Power BI es una de las tecnolog\u00edas m\u00e1s populares para el desarrollo de dashboards con datos relacionales. Por eso, preparamos un tutorial para que descubras c\u00f3mo usar los datos del data lake en el desarrollo de tus dashboards .","title":"Conectando con PowerBI"},{"location":"es/access_data_bq/#manuales-y-cursos-de-sql","text":"\u00bfEst\u00e1s empezando a aprender sobre SQL para hacer tus consultas? Abajo colocamos algunas recomendaciones usadas por nuestro equipo tanto en el aprendizaje como en el d\u00eda a d\u00eda: Lista de funciones en SQL de W3 Curso SQL en Codeacademy Curso de SQL de Programaci\u00f3n Din\u00e1mica","title":"Manuales y Cursos de SQL"},{"location":"es/access_data_packages/","text":"Paquetes Los paquetes de Base de los Datos permiten el acceso al data lake p\u00fablico directamente desde tu computadora o entorno de desarrollo. Actualmente disponibles en: Python R Stata CLI (terminal) \u00bfListo(a) para empezar? En esta p\u00e1gina encontrar\u00e1s: Primeros pasos Tutoriales Manuales de referencia Primeros pasos Antes de empezar: Crea tu proyecto en Google Cloud Para crear un proyecto en Google Cloud solo necesitas tener un correo registrado en Google. Es necesario tener un proyecto propio, aunque est\u00e9 vac\u00edo, para poder hacer consultas en nuestro data lake p\u00fablico. Accede a Google Cloud . Si es tu primera vez, acepta los T\u00e9rminos de Servicio. Haz clic en Create Project/Crear Proyecto . Elige un buen nombre para el proyecto. Haz clic en Create/Crear \u00bfPor qu\u00e9 necesito crear un proyecto en Google Cloud? Google proporciona 1 TB gratuito por mes de uso de BigQuery para cada proyecto que posees. Un proyecto es necesario para activar los servicios de Google Cloud, incluyendo el permiso de uso de BigQuery. Piensa en el proyecto como la \"cuenta\" en la que Google contabilizar\u00e1 cu\u00e1nto procesamiento has utilizado. No es necesario agregar ninguna tarjeta o forma de pago - BigQuery inicia autom\u00e1ticamente en modo Sandbox, que te permite utilizar sus recursos sin agregar un m\u00e9todo de pago. Lee m\u00e1s aqu\u00ed . Instalando el paquete Para la instalaci\u00f3n del paquete en Python y l\u00ednea de comandos, puedes usar pip directamente desde tu terminal. En R, basta con instalarlo directamente en RStudio o el editor de tu preferencia. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimientos: Asegurarte de que tu Stata sea la versi\u00f3n 16+ Asegurarte de que Python est\u00e9 instalado en tu computadora. Con los requerimientos satisfechos, ejecutar los comandos siguientes: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" ) Configurando el paquete Una vez con tu proyecto, necesitas configurar el paquete para usar el ID de ese proyecto en las consultas al datalake . Para esto, debes usar el project_id que Google te proporciona tan pronto como el proyecto es creado. Python/CLI No es necesario configurar el proyecto de antemano. Tan pronto como ejecutes la primera consulta, el paquete indicar\u00e1 los pasos para la configuraci\u00f3n. R Una vez con el project_id , debes pasar esta informaci\u00f3n al paquete usando la funci\u00f3n set_billing_id . set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata Es necesario especificar el project_id cada vez que uses el paquete. Haz tu primera consulta Un ejemplo simple para empezar a explorar el datalake es obtener informaci\u00f3n catastral de municipios directamente en nuestra base de Directorios Brasile\u00f1os (tabla municipio ) . Para esto, usaremos la funci\u00f3n download , descargando los datos directamente a nuestra m\u00e1quina. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia . Tutoriales C\u00f3mo usar los paquetes Preparamos tutoriales presentando las principales funciones de cada paquete para que empieces a usarlos. Python Blog: Introducci\u00f3n al paquete Python Introducci\u00f3n al paquete Python (cont.) Videos: Workshop: Aplicaciones en Python R Blog: Introducci\u00f3n al paquete R Explorando el Censo Escolar An\u00e1lisis: Brasil en las Olimpiadas Videos: Workshop: Aprende a acceder a datos p\u00fablicos en R Stata Documentaci\u00f3n: GitHub Manuales de referencia (API) Python R Stata CLI","title":"Paquetes"},{"location":"es/access_data_packages/#paquetes","text":"Los paquetes de Base de los Datos permiten el acceso al data lake p\u00fablico directamente desde tu computadora o entorno de desarrollo. Actualmente disponibles en: Python R Stata CLI (terminal) \u00bfListo(a) para empezar? En esta p\u00e1gina encontrar\u00e1s: Primeros pasos Tutoriales Manuales de referencia","title":"Paquetes"},{"location":"es/access_data_packages/#primeros-pasos","text":"","title":"Primeros pasos"},{"location":"es/access_data_packages/#antes-de-empezar-crea-tu-proyecto-en-google-cloud","text":"Para crear un proyecto en Google Cloud solo necesitas tener un correo registrado en Google. Es necesario tener un proyecto propio, aunque est\u00e9 vac\u00edo, para poder hacer consultas en nuestro data lake p\u00fablico. Accede a Google Cloud . Si es tu primera vez, acepta los T\u00e9rminos de Servicio. Haz clic en Create Project/Crear Proyecto . Elige un buen nombre para el proyecto. Haz clic en Create/Crear \u00bfPor qu\u00e9 necesito crear un proyecto en Google Cloud? Google proporciona 1 TB gratuito por mes de uso de BigQuery para cada proyecto que posees. Un proyecto es necesario para activar los servicios de Google Cloud, incluyendo el permiso de uso de BigQuery. Piensa en el proyecto como la \"cuenta\" en la que Google contabilizar\u00e1 cu\u00e1nto procesamiento has utilizado. No es necesario agregar ninguna tarjeta o forma de pago - BigQuery inicia autom\u00e1ticamente en modo Sandbox, que te permite utilizar sus recursos sin agregar un m\u00e9todo de pago. Lee m\u00e1s aqu\u00ed .","title":"Antes de empezar: Crea tu proyecto en Google Cloud"},{"location":"es/access_data_packages/#instalando-el-paquete","text":"Para la instalaci\u00f3n del paquete en Python y l\u00ednea de comandos, puedes usar pip directamente desde tu terminal. En R, basta con instalarlo directamente en RStudio o el editor de tu preferencia. Python/CLI pip install basedosdados R install.packages ( \"basedosdados\" ) Stata Requerimientos: Asegurarte de que tu Stata sea la versi\u00f3n 16+ Asegurarte de que Python est\u00e9 instalado en tu computadora. Con los requerimientos satisfechos, ejecutar los comandos siguientes: net install basedosdados, from( \"https://raw.githubusercontent.com/basedosdados/mais/master/stata-package\" )","title":"Instalando el paquete"},{"location":"es/access_data_packages/#configurando-el-paquete","text":"Una vez con tu proyecto, necesitas configurar el paquete para usar el ID de ese proyecto en las consultas al datalake . Para esto, debes usar el project_id que Google te proporciona tan pronto como el proyecto es creado. Python/CLI No es necesario configurar el proyecto de antemano. Tan pronto como ejecutes la primera consulta, el paquete indicar\u00e1 los pasos para la configuraci\u00f3n. R Una vez con el project_id , debes pasar esta informaci\u00f3n al paquete usando la funci\u00f3n set_billing_id . set_billing_id ( \"<YOUR_PROJECT_ID>\" ) Stata Es necesario especificar el project_id cada vez que uses el paquete.","title":"Configurando el paquete"},{"location":"es/access_data_packages/#haz-tu-primera-consulta","text":"Un ejemplo simple para empezar a explorar el datalake es obtener informaci\u00f3n catastral de municipios directamente en nuestra base de Directorios Brasile\u00f1os (tabla municipio ) . Para esto, usaremos la funci\u00f3n download , descargando los datos directamente a nuestra m\u00e1quina. Python import basedosdados as bd bd . download ( savepath = \"<PATH>\" , dataset_id = \"br-bd-diretorios-brasil\" , table_id = \"municipio\" ) Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia . R library ( \"basedosdados\" ) query <- \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\" dir <- tempdir () data <- download ( query , \"<PATH>\" ) Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia . Stata bd_read_sql, /// path( \"<PATH>\" ) /// query ( \"SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`\") /// billing_project_id(\"<PROJECT_ID>\") CLI basedosdados download \"where/to/save/file\" \\ --billing_project_id <YOUR_PROJECT_ID> \\ --query 'SELECT * FROM `basedosdados.br_bd_diretorios_brasil.municipio`' Para entender m\u00e1s sobre la funci\u00f3n download , lee el manual de referencia .","title":"Haz tu primera consulta"},{"location":"es/access_data_packages/#tutoriales","text":"","title":"Tutoriales"},{"location":"es/access_data_packages/#como-usar-los-paquetes","text":"Preparamos tutoriales presentando las principales funciones de cada paquete para que empieces a usarlos. Python Blog: Introducci\u00f3n al paquete Python Introducci\u00f3n al paquete Python (cont.) Videos: Workshop: Aplicaciones en Python R Blog: Introducci\u00f3n al paquete R Explorando el Censo Escolar An\u00e1lisis: Brasil en las Olimpiadas Videos: Workshop: Aprende a acceder a datos p\u00fablicos en R Stata Documentaci\u00f3n: GitHub","title":"C\u00f3mo usar los paquetes"},{"location":"es/access_data_packages/#manuales-de-referencia-api","text":"Python R Stata CLI","title":"Manuales de referencia (API)"},{"location":"es/api_reference_python/","text":"Python Esta API est\u00e1 compuesta por funciones con 2 tipos de funcionalidad: M\u00f3dulos para solicitud de datos : para aquellos que desean solamente consultar los datos y metadatos de nuestro proyecto. Clases para gesti\u00f3n de datos en Google Cloud: para aquellos que desean subir datos en nuestro proyecto (o cualquier otro proyecto en Google Cloud, siguiendo nuestra metodolog\u00eda e infraestructura). Toda la documentaci\u00f3n del c\u00f3digo siguiente est\u00e1 en ingl\u00e9s M\u00f3dulos (Solicitud de datos) Functions to get metadata from BD's API check_input ( f ) Checks if the number of inputs is valid Source code in basedosdados/download/metadata.py def check_input ( f ): \"\"\"Checks if the number of inputs is valid\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if sum ([ a is not None for a in args ]) > 1 : raise ValueError ( \"At most one of the inputs must be non null\" ) return f ( * args , ** kwargs ) return wrapper get_columns ( table_id = None , column_id = None , columns_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available columns, either by table_id , column_id or column_name Parameters: Name Type Description Default table_id(str) table slug in google big query (gbq). required column_id(str) column slug in google big query (gbq). required column_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_columns ( table_id : str = None , column_id : str = None , columns_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available columns, either by `table_id`, `column_id` or `column_name` Args: table_id(str): table slug in google big query (gbq). column_id(str): column slug in google big query (gbq). column_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" result = backend . get_columns ( table_id , column_id , columns_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"bigquery_type\" ] = item . pop ( \"bigqueryType\" , {}) . get ( \"name\" ) return result get_datasets ( dataset_id = None , dataset_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available datasets, either by dataset_id or dataset_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required dataset_name(str) dataset name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_datasets ( dataset_id : str = None , dataset_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available datasets, either by `dataset_id` or `dataset_name` Args: dataset_id(str): dataset slug in google big query (gbq). dataset_name(str): dataset name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets. \"\"\" result = backend . get_datasets ( dataset_id , dataset_name , page , page_size ) for item in result . get ( \"items\" , []) or []: item [ \"organization\" ] = item . get ( \"organization\" , {}) . get ( \"name\" ) item [ \"tags\" ] = [ i . get ( \"name\" ) for i in item . get ( \"tags\" , {}) . get ( \"items\" )] item [ \"themes\" ] = [ i . get ( \"name\" ) for i in item . get ( \"themes\" , {}) . get ( \"items\" )] return result get_tables ( dataset_id = None , table_id = None , table_name = None , page = 1 , page_size = 10 , backend = None ) Get a list of available tables, either by dataset_id , table_id or table_name Parameters: Name Type Description Default dataset_id(str) dataset slug in google big query (gbq). required table_id(str) table slug in google big query (gbq). required table_name(str) table name in base dos dados metadata. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of tables. Source code in basedosdados/download/metadata.py @check_input @inject_backend def get_tables ( dataset_id : str = None , table_id : str = None , table_name : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Get a list of available tables, either by `dataset_id`, `table_id` or `table_name` Args: dataset_id(str): dataset slug in google big query (gbq). table_id(str): table slug in google big query (gbq). table_name(str): table name in base dos dados metadata. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of tables. \"\"\" return backend . get_tables ( dataset_id , table_id , table_name , page , page_size ) inject_backend ( f ) Inject backend instance if doesn't exists Source code in basedosdados/download/metadata.py def inject_backend ( f ): \"\"\"Inject backend instance if doesn't exists\"\"\" @wraps ( f ) def wrapper ( * args , ** kwargs ): if \"backend\" not in kwargs : kwargs [ \"backend\" ] = Backend () return f ( * args , ** kwargs ) return wrapper search ( q = None , page = 1 , page_size = 10 , backend = None ) Search for datasets, querying all available metadata for the term q Parameters: Name Type Description Default q(str) search term. required page(int) page for pagination. required page_size(int) page size for pagination. required backend(Backend) backend instance, injected automatically. required Returns: Type Description dict List of datasets and metadata. Source code in basedosdados/download/metadata.py @check_input @inject_backend def search ( q : str = None , page : int = 1 , page_size : int = 10 , backend : Backend = None , ) -> list [ dict ]: \"\"\" Search for datasets, querying all available metadata for the term `q` Args: q(str): search term. page(int): page for pagination. page_size(int): page size for pagination. backend(Backend): backend instance, injected automatically. Returns: dict: List of datasets and metadata. \"\"\" items = [] for item in backend . search ( q , page , page_size ) . get ( \"results\" , []): items . append ( { \"slug\" : item . get ( \"slug\" ), \"name\" : item . get ( \"name\" ), \"description\" : item . get ( \"description\" ), \"n_tables\" : item . get ( \"n_tables\" ), \"n_raw_data_sources\" : item . get ( \"n_raw_data_sources\" ), \"n_information_requests\" : item . get ( \"n_information_requests\" ), \"organization\" : { \"slug\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"slug\" ), \"name\" : item . get ( \"organizations\" , [{}])[ 0 ] . get ( \"name\" ), }, } ) return items Functions for managing downloads download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , compression = 'GZIP' ) Download table or query result from basedosdados BigQuery (or other). Using a query : download('select * from basedosdados.br_suporte.diretorio_municipios limit 10') Using dataset_id & table_id : download(dataset_id='br_suporte', table_id='diretorio_municipios') You can also add arguments to modify save parameters: download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|') Parameters: Name Type Description Default savepath str, pathlib.PosixPath savepath must be a file path. Only supports .csv . required query str Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. None dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. None table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. None billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional Number of rows. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False compression str Optional. Compression type. Only GZIP is available for now. 'GZIP' Exceptions: Type Description Exception If either table_id, dataset_id or query are empty. Source code in basedosdados/download/download.py def download ( savepath , query = None , dataset_id = None , table_id = None , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , compression = \"GZIP\" , ): \"\"\"Download table or query result from basedosdados BigQuery (or other). * Using a **query**: `download('select * from `basedosdados.br_suporte.diretorio_municipios` limit 10')` * Using **dataset_id & table_id**: `download(dataset_id='br_suporte', table_id='diretorio_municipios')` You can also add arguments to modify save parameters: `download(dataset_id='br_suporte', table_id='diretorio_municipios', index=False, sep='|')` Args: savepath (str, pathlib.PosixPath): savepath must be a file path. Only supports `.csv`. query (str): Optional. Valid SQL Standard Query to basedosdados. If query is available, dataset_id and table_id are not required. dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional Number of rows. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. compression (str): Optional. Compression type. Only `GZIP` is available for now. Raises: Exception: If either table_id, dataset_id or query are empty. \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( query is None ) and (( table_id is None ) or ( dataset_id is None )): raise BaseDosDadosException ( \"Either table_id, dataset_id or query should be filled.\" ) client = _google_client ( billing_project_id , from_file , reauth ) # makes sure that savepath is a filepath and not a folder savepath = _sets_savepath ( savepath ) # if query is not defined (so it won't be overwritten) and if # table is a view or external or if limit is specified, # convert it to a query. if not query and ( not _is_table ( client , dataset_id , table_id , query_project_id ) or limit ): query = f \"\"\" SELECT * FROM { query_project_id } . { dataset_id } . { table_id } \"\"\" if limit is not None : query += f \" limit { limit } \" if query : # sql queries produces anonymous tables, whose names # can be found within `job._properties` job = client [ \"bigquery\" ] . query ( query ) # views may take longer: wait for job to finish. _wait_for ( job ) dest_table = job . _properties [ \"configuration\" ][ \"query\" ][ \"destinationTable\" ] project_id = dest_table [ \"projectId\" ] dataset_id = dest_table [ \"datasetId\" ] table_id = dest_table [ \"tableId\" ] _direct_download ( client , dataset_id , table_id , savepath , project_id , compression ) read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Parameters: Name Type Description Default query sql Valid SQL Standard Query to basedosdados required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_sql ( query , billing_project_id = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using a query. Just a wrapper around pandas.read_gbq Args: query (sql): Valid SQL Standard Query to basedosdados billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) try : # Set a two hours timeout bigquery_storage_v1 . client . BigQueryReadClient . read_rows = partialmethod ( bigquery_storage_v1 . client . BigQueryReadClient . read_rows , timeout = 3600 * 2 , ) return read_gbq ( query , project_id = config . billing_project_id , use_bqstorage_api = use_bqstorage_api , credentials = _credentials ( from_file = config . from_file , reauth = reauth ), ) except GenericGBQException as e : if \"Reason: 403\" in str ( e ): raise BaseDosDadosAccessDeniedException from e if re . match ( \"Reason: 400 POST .* [Pp]roject[ ]*I[Dd]\" , str ( e )): raise BaseDosDadosInvalidProjectIDException from e raise except PyDataCredentialsError as e : raise BaseDosDadosAuthorizationException from e except ( OSError , ValueError ) as e : no_billing_id = \"Could not determine project ID\" in str ( e ) no_billing_id |= \"reading from stdin while output is captured\" in str ( e ) if no_billing_id : raise BaseDosDadosNoBillingProjectIDException from e raise read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = 'basedosdados' , limit = None , from_file = False , reauth = False , use_bqstorage_api = False ) Load data from BigQuery using dataset_id and table_id. Parameters: Name Type Description Default dataset_id str Optional. Dataset id available in basedosdados. It should always come with table_id. required table_id str Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. required billing_project_id str Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard None query_project_id str Optional. Which project the table lives. You can change this you want to query different projects. 'basedosdados' limit int Optional. Number of rows to read from table. None from_file boolean Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ False reauth boolean Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. False use_bqstorage_api boolean Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. False Returns: Type Description pd.DataFrame Query result Source code in basedosdados/download/download.py def read_table ( dataset_id , table_id , billing_project_id = None , query_project_id = \"basedosdados\" , limit = None , from_file = False , reauth = False , use_bqstorage_api = False , ): \"\"\"Load data from BigQuery using dataset_id and table_id. Args: dataset_id (str): Optional. Dataset id available in basedosdados. It should always come with table_id. table_id (str): Optional. Table id available in basedosdados.dataset_id. It should always come with dataset_id. billing_project_id (str): Optional. Project that will be billed. Find your Project ID here https://console.cloud.google.com/projectselector2/home/dashboard query_project_id (str): Optional. Which project the table lives. You can change this you want to query different projects. limit (int): Optional. Number of rows to read from table. from_file (boolean): Optional. Uses the credentials from file, located in `~/.basedosdados/credentials/ reauth (boolean): Optional. Re-authorize Google Cloud Project in case you need to change user or reset configurations. use_bqstorage_api (boolean): Optional. Use the BigQuery Storage API to download query results quickly, but at an increased cost(https://cloud.google.com/bigquery/docs/reference/storage/). To use this API, first enable it in the Cloud Console(https://console.cloud.google.com/apis/library/bigquerystorage.googleapis.com). You must also have the bigquery.readsessions.create permission on the project you are billing queries to. Returns: pd.DataFrame: Query result \"\"\" billing_project_id , from_file = _set_config_variables ( billing_project_id = billing_project_id , from_file = from_file ) if ( dataset_id is not None ) and ( table_id is not None ): query = f \"\"\" SELECT * FROM ` { query_project_id } . { dataset_id } . { table_id } `\"\"\" if limit is not None : query += f \" LIMIT { limit } \" else : raise BaseDosDadosException ( \"Both table_id and dataset_id should be filled.\" ) return read_sql ( query , billing_project_id = billing_project_id , from_file = from_file , reauth = reauth , use_bqstorage_api = use_bqstorage_api , ) Clases (Gesti\u00f3n de datos) Class for managing the files in cloud storage. Storage ( Base ) Manage files on Google Cloud Storage. Source code in basedosdados/upload/storage.py class Storage ( Base ): \"\"\" Manage files on Google Cloud Storage. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . bucket = self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_id = table_id . replace ( \"-\" , \"_\" ) @staticmethod def _resolve_partitions ( partitions ): if isinstance ( partitions , dict ): return \"/\" . join ( f \" { k } = { v } \" for k , v in partitions . items ()) + \"/\" if isinstance ( partitions , str ): if partitions . endswith ( \"/\" ): partitions = partitions [: - 1 ] # If there is no partition if len ( partitions ) == 0 : return \"\" # It should fail if there is folder which is not a partition try : # check if it fits rule { b . split ( \"=\" )[ 0 ]: b . split ( \"=\" )[ 1 ] for b in partitions . split ( \"/\" )} except IndexError as e : raise Exception ( f \"The path { partitions } is not a valid partition\" ) from e return partitions + \"/\" raise Exception ( f \"Partitions format or type not accepted: { partitions } \" ) def _build_blob_name ( self , filename , mode , partitions = None ): \"\"\" Builds the blob name. \"\"\" # table folder blob_name = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # add partition folder if partitions is not None : blob_name += self . _resolve_partitions ( partitions ) # add file name blob_name += filename return blob_name def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) copy_table ( self , source_bucket_name = 'basedosdados' , destination_bucket_name = None , mode = 'staging' , new_table_id = None ) Copies table from a source bucket to your bucket, sends request in batches. Parameters: Name Type Description Default source_bucket_name str The bucket name from which to copy data. You can change it to copy from other external bucket. 'basedosdados' destination_bucket_name str Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) None mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' new_table_id str Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. None Source code in basedosdados/upload/storage.py def copy_table ( self , source_bucket_name = \"basedosdados\" , destination_bucket_name = None , mode = \"staging\" , new_table_id = None , ): \"\"\"Copies table from a source bucket to your bucket, sends request in batches. Args: source_bucket_name (str): The bucket name from which to copy data. You can change it to copy from other external bucket. destination_bucket_name (str): Optional The bucket name where data will be copied to. If None, defaults to the bucket initialized when instantiating the Storage object (You can check it with the Storage().bucket property) mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". new_table_id (str): Optional. New table id to be copied to. If None, defaults to the table id initialized when instantiating the Storage object. \"\"\" source_table_ref = list ( self . client [ \"storage_staging\" ] . bucket ( source_bucket_name ) . list_blobs ( prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" ) ) if not source_table_ref : raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) if destination_bucket_name is None : destination_bucket = self . bucket else : destination_bucket = self . client [ \"storage_staging\" ] . bucket ( destination_bucket_name ) # Divides source_table_ref list for maximum batch request size source_table_ref_chunks = [ source_table_ref [ i : i + 999 ] # noqa for i in range ( 0 , len ( source_table_ref ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( source_table_ref_chunks , desc = \"Copy Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : new_name = None if new_table_id : new_name = blob . name . replace ( self . table_id , new_table_id ) self . bucket . copy_blob ( blob , destination_bucket = destination_bucket , new_name = new_name , ) break except Exception : print ( f \"Copy Table Chunk { i } | Attempt { counter } : copy operation starts again in 5 seconds...\" , ) counter += 1 time . sleep ( 5 ) traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} to {new_object_id} _ {mode} !\" , object_id = self . table_id , new_object_id = new_table_id if new_table_id else self . table_id , mode = mode , object = \"Table\" , action = \"copied\" , ) delete_file ( self , filename , mode , partitions = None , not_found_ok = False ) Deletes file from path <bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename> . Parameters: Name Type Description Default filename str Name of the file to be deleted required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] required partitions str, pathlib.PosixPath, or dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None not_found_ok bool Optional. What to do if file not found False Source code in basedosdados/upload/storage.py def delete_file ( self , filename , mode , partitions = None , not_found_ok = False ): \"\"\"Deletes file from path `<bucket_name>/<mode>/<dataset_id>/<table_id>/<partitions>/<filename>`. Args: filename (str): Name of the file to be deleted mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` not_found_ok (bool): Optional. What to do if file not found \"\"\" self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : blob = self . bucket . blob ( self . _build_blob_name ( filename , m , partitions )) if blob . exists () or not blob . exists () and not not_found_ok : blob . delete () else : return logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filename , mode = mode , object = \"File\" , action = \"deleted\" , ) delete_table ( self , mode = 'staging' , bucket_name = None , not_found_ok = False ) Deletes a table from storage, sends request in batches. Parameters: Name Type Description Default mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". 'staging' bucket_name str The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) None not_found_ok bool Optional. What to do if table not found False Source code in basedosdados/upload/storage.py def delete_table ( self , mode = \"staging\" , bucket_name = None , not_found_ok = False ): \"\"\"Deletes a table from storage, sends request in batches. Args: mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture] Folder of which dataset to update. Defaults to \"staging\". bucket_name (str): The bucket name from which to delete the table. If None, defaults to the bucket initialized when instantiating the Storage object. (You can check it with the Storage().bucket property) not_found_ok (bool): Optional. What to do if table not found \"\"\" prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" if bucket_name is not None : table_blobs = list ( self . client [ \"storage_staging\" ] . bucket ( f \" { bucket_name } \" ) . list_blobs ( prefix = prefix ) ) else : table_blobs = list ( self . bucket . list_blobs ( prefix = prefix )) if not table_blobs : if not_found_ok : return raise FileNotFoundError ( f \"Could not find the requested table { self . dataset_id } . { self . table_id } \" ) # Divides table_blobs list for maximum batch request size table_blobs_chunks = [ table_blobs [ i : i + 999 ] for i in range ( 0 , len ( table_blobs ), 999 ) # noqa ] for i , source_table in enumerate ( tqdm ( table_blobs_chunks , desc = \"Delete Table Chunk\" ) ): counter = 0 while counter < 10 : try : with self . client [ \"storage_staging\" ] . batch (): for blob in source_table : blob . delete () break except Exception : print ( f \"Delete Table Chunk { i } | Attempt { counter } : delete operation starts again in 5 seconds...\" , ) time . sleep ( 5 ) counter += 1 traceback . print_exc ( file = sys . stderr ) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) download ( self , filename = '*' , savepath = '.' , partitions = None , mode = 'staging' , if_not_exists = 'raise' ) Download files from Google Storage from path mode / dataset_id / table_id / partitions / filename and replicate folder hierarchy on save, There are 5 modes: * raw : should contain raw files from datasource * staging : should contain pre-treated files ready to upload to BiqQuery * header : should contain the header of the tables * auxiliary_files : should contain auxiliary files from eache table * architecture : should contain the architecture sheet of the tables You can also use the partitions argument to choose files from a partition Parameters: Name Type Description Default filename str Optional Specify which file to download. If \" \" , downloads all files within the bucket folder. Defaults to \" \". '*' savepath str Where you want to save the data on your computer. Must be a path to a directory. '.' partitions str, dict Optional If downloading a single file, use this to specify the partition path from which to download. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None mode str Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] 'staging' if_not_exists str Optional. What to do if data not found. 'raise' : Raises FileNotFoundError. 'pass' : Do nothing and exit the function 'raise' Exceptions: Type Description FileNotFoundError If the given path <mode>/<dataset_id>/<table_id>/<partitions>/<filename> could not be found or there are no files to download. Source code in basedosdados/upload/storage.py def download ( self , filename = \"*\" , savepath = \".\" , partitions = None , mode = \"staging\" , if_not_exists = \"raise\" , ): \"\"\"Download files from Google Storage from path `mode`/`dataset_id`/`table_id`/`partitions`/`filename` and replicate folder hierarchy on save, There are 5 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables You can also use the `partitions` argument to choose files from a partition Args: filename (str): Optional Specify which file to download. If \"*\" , downloads all files within the bucket folder. Defaults to \"*\". savepath (str): Where you want to save the data on your computer. Must be a path to a directory. partitions (str, dict): Optional If downloading a single file, use this to specify the partition path from which to download. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` mode (str): Optional Folder of which dataset to update.[raw|staging|header|auxiliary_files|architecture] if_not_exists (str): Optional. What to do if data not found. * 'raise' : Raises FileNotFoundError. * 'pass' : Do nothing and exit the function Raises: FileNotFoundError: If the given path `<mode>/<dataset_id>/<table_id>/<partitions>/<filename>` could not be found or there are no files to download. \"\"\" # Prefix to locate files within the bucket prefix = f \" { mode } / { self . dataset_id } / { self . table_id } /\" # Add specific partition to search prefix if partitions : prefix += self . _resolve_partitions ( partitions ) # if no filename is passed, list all blobs within a given table if filename != \"*\" : prefix += filename blob_list = list ( self . bucket . list_blobs ( prefix = prefix )) # if there are no blobs matching the search raise FileNotFoundError or return if not blob_list : if if_not_exists == \"raise\" : raise FileNotFoundError ( f \"Could not locate files at { prefix } \" ) return # download all blobs matching the search to given savepath for blob in tqdm ( blob_list , desc = \"Download Blob\" ): # parse blob.name and get the csv file name csv_name = blob . name . split ( \"/\" )[ - 1 ] # build folder path replicating storage hierarchy blob_folder = blob . name . replace ( csv_name , \"\" ) # replicate folder hierarchy savepath = Path ( savepath ) ( savepath / blob_folder ) . mkdir ( parents = True , exist_ok = True ) # download blob to savepath save_file_path = savepath / blob . name blob . download_to_filename ( filename = save_file_path ) logger . success ( \" {object} {object_id} _ {mode} was {action} at: {path} !\" , object_id = self . dataset_id , mode = mode , object = \"File\" , action = \"downloaded\" , path = { str ( savepath )}, ) init ( self , replace = False , very_sure = False ) Initializes bucket and folders. Folder should be: raw : that contains really raw data staging : preprocessed data ready to upload to BigQuery Parameters: Name Type Description Default replace bool Optional. Whether to replace if bucket already exists False very_sure bool Optional. Are you aware that everything is going to be erased if you replace the bucket? False Exceptions: Type Description Warning very_sure argument is still False. Source code in basedosdados/upload/storage.py def init ( self , replace = False , very_sure = False ): \"\"\"Initializes bucket and folders. Folder should be: * `raw` : that contains really raw data * `staging` : preprocessed data ready to upload to BigQuery Args: replace (bool): Optional. Whether to replace if bucket already exists very_sure (bool): Optional. Are you aware that everything is going to be erased if you replace the bucket? Raises: Warning: very_sure argument is still False. \"\"\" if replace : if not very_sure : raise Warning ( \" \\n ********************************************************\" \" \\n You are trying to replace all the data that you have \" f \"in bucket { self . bucket_name } . \\n Are you sure? \\n \" \"If yes, add the flag --very_sure \\n \" \"********************************************************\" ) self . bucket . delete ( force = True ) self . client [ \"storage_staging\" ] . create_bucket ( self . bucket ) for folder in [ \"staging/\" , \"raw/\" ]: self . bucket . blob ( folder ) . upload_from_string ( \"\" ) upload ( self , path , mode = 'all' , partitions = None , if_exists = 'raise' , chunk_size = None , ** upload_args ) Upload to storage at <bucket_name>/<mode>/<dataset_id>/<table_id> . You can: Add a single file setting path = <file_path> . Add a folder with multiple files setting path = <folder_path> . The folder should just contain the files and no folders. Add partitioned files setting path = <folder_path> . This folder must follow the hive partitioning scheme i.e. <table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv (ex: mytable/country=brasil/year=2020/mypart.csv ). Remember all files must follow a single schema. Otherwise, things might fail in the future. There are 6 modes: raw : should contain raw files from datasource staging : should contain pre-treated files ready to upload to BiqQuery header : should contain the header of the tables auxiliary_files : should contain auxiliary files from eache table architecture : should contain the architecture sheet of the tables all : if no treatment is needed, use all . Parameters: Name Type Description Default path str or pathlib.PosixPath Where to find the file or folder that you want to upload to storage required mode str Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] 'all' partitions str, pathlib.PosixPath, or dict Optional. If adding a single file , use this to add it to a specific partition. str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str Optional. What to do if data exists 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None upload_args Extra arguments accepted by google.cloud.storage.blob.Blob.upload_from_file {} Source code in basedosdados/upload/storage.py def upload ( self , path , mode = \"all\" , partitions = None , if_exists = \"raise\" , chunk_size = None , ** upload_args , ): \"\"\"Upload to storage at `<bucket_name>/<mode>/<dataset_id>/<table_id>`. You can: * Add a single **file** setting `path = <file_path>`. * Add a **folder** with multiple files setting `path = <folder_path>`. *The folder should just contain the files and no folders.* * Add **partitioned files** setting `path = <folder_path>`. This folder must follow the hive partitioning scheme i.e. `<table_id>/<key>=<value>/<key2>=<value2>/<partition>.csv` (ex: `mytable/country=brasil/year=2020/mypart.csv`). *Remember all files must follow a single schema.* Otherwise, things might fail in the future. There are 6 modes: * `raw` : should contain raw files from datasource * `staging` : should contain pre-treated files ready to upload to BiqQuery * `header`: should contain the header of the tables * `auxiliary_files`: should contain auxiliary files from eache table * `architecture`: should contain the architecture sheet of the tables * `all`: if no treatment is needed, use `all`. Args: path (str or pathlib.PosixPath): Where to find the file or folder that you want to upload to storage mode (str): Folder of which dataset to update [raw|staging|header|auxiliary_files|architecture|all] partitions (str, pathlib.PosixPath, or dict): Optional. *If adding a single file*, use this to add it to a specific partition. * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): Optional. What to do if data exists * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. upload_args (): Extra arguments accepted by [`google.cloud.storage.blob.Blob.upload_from_file`](https://googleapis.dev/python/storage/latest/blobs.html?highlight=upload_from_filename#google.cloud.storage.blob.Blob.upload_from_filename) \"\"\" if ( self . dataset_id is None ) or ( self . table_id is None ): raise Exception ( \"You need to pass dataset_id and table_id\" ) path = Path ( path ) if path . is_dir (): paths = [ f for f in path . glob ( \"**/*\" ) if f . is_file () and f . suffix in [ \".csv\" , \".parquet\" , \"parquet.gzip\" ] ] parts = [ ( filepath . as_posix () . replace ( path . as_posix () + \"/\" , \"\" ) . replace ( str ( filepath . name ), \"\" ) ) for filepath in paths ] else : paths = [ path ] parts = [ partitions or None ] self . _check_mode ( mode ) mode = ( [ \"raw\" , \"staging\" , \"header\" , \"auxiliary_files\" , \"architecture\" ] if mode == \"all\" else [ mode ] ) for m in mode : for filepath , part in tqdm ( list ( zip ( paths , parts )), desc = \"Uploading files\" ): blob_name = self . _build_blob_name ( filepath . name , m , part ) blob = self . bucket . blob ( blob_name , chunk_size = chunk_size ) if not blob . exists () or if_exists == \"replace\" : upload_args [ \"timeout\" ] = upload_args . get ( \"timeout\" , None ) blob . upload_from_filename ( str ( filepath ), ** upload_args ) elif if_exists == \"pass\" : pass else : raise BaseDosDadosException ( f \"Data already exists at { self . bucket_name } / { blob_name } . \" \"If you are using Storage.upload then set if_exists to \" \"'replace' to overwrite data \\n \" \"If you are using Table.create then set if_storage_data_exists \" \"to 'replace' to overwrite data.\" ) logger . success ( \" {object} {filename} _ {mode} was {action} !\" , filename = filepath . name , mode = m , object = \"File\" , action = \"uploaded\" , ) Module for manage dataset to the server. Dataset ( Base ) Manage datasets in BigQuery. Source code in basedosdados/upload/dataset.py class Dataset ( Base ): \"\"\" Manage datasets in BigQuery. \"\"\" def __init__ ( self , dataset_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) @property @lru_cache def dataset_config ( self ): \"\"\" Dataset config file. \"\"\" return self . backend . get_dataset_config ( self . dataset_id ) def _loop_modes ( self , mode = \"all\" ): \"\"\" Loop modes. \"\"\" def dataset_tag ( m ): return f \"_ { m } \" if m == \"staging\" else \"\" mode = [ \"prod\" , \"staging\" ] if mode == \"all\" else [ mode ] return ( { \"client\" : self . client [ f \"bigquery_ { m } \" ], \"id\" : f \" { self . client [ f 'bigquery_ { m } ' ] . project } . { self . dataset_id }{ dataset_tag ( m ) } \" , \"mode\" : m , } for m in mode ) def _setup_dataset_object ( self , dataset_id , location = None , mode = \"staging\" ): \"\"\" Setup dataset object. \"\"\" dataset = bigquery . Dataset ( dataset_id ) if mode == \"staging\" : dataset_path = dataset_id . replace ( \"_staging\" , \"\" ) description = f \"staging dataset for ` { dataset_path } `\" labels = { \"staging\" : True } else : try : description = self . dataset_config . get ( \"descriptionPt\" , \"\" ) labels = { tag . get ( \"namePt\" ): True for tag in self . dataset_config . get ( \"tags\" ) } except BaseException : logger . warning ( f \"dataset { dataset_id } does not have a description in the API.\" ) description = \"description not available in the API.\" labels = {} dataset . description = description dataset . labels = labels dataset . location = location return dataset def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) dataset_config property readonly Dataset config file. create ( self , mode = 'all' , if_exists = 'raise' , dataset_is_public = True , location = None ) Creates BigQuery datasets given dataset_id . It can create two datasets: <dataset_id> (mode = 'prod') <dataset_id>_staging (mode = 'staging') If mode is all, it creates both. Parameters: Name Type Description Default mode str Optional. Which dataset to create [prod|staging|all]. 'all' if_exists str Optional. What to do if dataset exists raise : Raises Conflict exception replace : Drop all tables and replace dataset update : Update dataset description pass : Do nothing 'raise' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Exceptions: Type Description Warning Dataset already exists and if_exists is set to raise Source code in basedosdados/upload/dataset.py def create ( self , mode = \"all\" , if_exists = \"raise\" , dataset_is_public = True , location = None ): \"\"\"Creates BigQuery datasets given `dataset_id`. It can create two datasets: * `<dataset_id>` (mode = 'prod') * `<dataset_id>_staging` (mode = 'staging') If `mode` is all, it creates both. Args: mode (str): Optional. Which dataset to create [prod|staging|all]. if_exists (str): Optional. What to do if dataset exists * raise : Raises Conflict exception * replace : Drop all tables and replace dataset * update : Update dataset description * pass : Do nothing dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations Raises: Warning: Dataset already exists and if_exists is set to `raise` \"\"\" # Set dataset_id to the ID of the dataset to create. for m in self . _loop_modes ( mode ): if if_exists == \"replace\" : self . delete ( mode = m [ \"mode\" ]) elif if_exists == \"update\" : self . update ( mode = m [ \"mode\" ]) continue # Send the dataset to the API for creation, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. try : if not self . exists ( mode = m [ \"mode\" ]): # Construct a full Dataset object to send to the API. dataset_obj = self . _setup_dataset_object ( dataset_id = m [ \"id\" ], location = location , mode = m [ \"mode\" ] ) m [ \"client\" ] . create_dataset ( dataset_obj ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"created\" , ) # Make prod dataset public self . publicize ( dataset_is_public = dataset_is_public , mode = m [ \"mode\" ]) except Conflict as e : if if_exists == \"pass\" : continue raise Conflict ( f \"Dataset { self . dataset_id } already exists\" ) from e delete ( self , mode = 'all' ) Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Parameters: Name Type Description Default mode str Optional. Which dataset to delete [prod|staging|all] 'all' Source code in basedosdados/upload/dataset.py def delete ( self , mode = \"all\" ): \"\"\"Deletes dataset in BigQuery. Toogle mode to choose which dataset to delete. Args: mode (str): Optional. Which dataset to delete [prod|staging|all] \"\"\" for m in self . _loop_modes ( mode ): m [ \"client\" ] . delete_dataset ( m [ \"id\" ], delete_contents = True , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"deleted\" , ) exists ( self , mode = 'staging' ) Check if dataset exists. Source code in basedosdados/upload/dataset.py def exists ( self , mode = \"staging\" ): \"\"\" Check if dataset exists. \"\"\" ref_dataset_id = ( self . dataset_id if mode == \"prod\" else self . dataset_id + \"_staging\" ) try : ref = self . client [ f \"bigquery_ { mode } \" ] . get_dataset ( ref_dataset_id ) except Exception : ref = None return bool ( ref ) publicize ( self , mode = 'all' , dataset_is_public = True ) Changes IAM configuration to turn BigQuery dataset public. Parameters: Name Type Description Default mode bool Which dataset to create [prod|staging|all]. 'all' dataset_is_public bool Control if prod dataset is public or not. By default staging datasets like dataset_id_staging are not public. True Source code in basedosdados/upload/dataset.py def publicize ( self , mode = \"all\" , dataset_is_public = True ): \"\"\"Changes IAM configuration to turn BigQuery dataset public. Args: mode (bool): Which dataset to create [prod|staging|all]. dataset_is_public (bool): Control if prod dataset is public or not. By default staging datasets like `dataset_id_staging` are not public. \"\"\" for m in self . _loop_modes ( mode ): dataset = m [ \"client\" ] . get_dataset ( m [ \"id\" ]) entries = dataset . access_entries # TODO https://github.com/basedosdados/mais/pull/1020 # TODO if staging dataset is private, the prod view can't acess it: if dataset_is_public and \"staging\" not in dataset.dataset_id: if dataset_is_public : if \"staging\" not in dataset . dataset_id : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.metadataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), bigquery . AccessEntry ( role = \"roles/bigquery.user\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) else : entries . extend ( [ bigquery . AccessEntry ( role = \"roles/bigquery.dataViewer\" , entity_type = \"iamMember\" , entity_id = \"allUsers\" , ), ] ) dataset . access_entries = entries m [ \"client\" ] . update_dataset ( dataset , [ \"access_entries\" ]) logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"publicized\" , ) update ( self , mode = 'all' , location = None ) Update dataset description. Toogle mode to choose which dataset to update. Parameters: Name Type Description Default mode str Optional. Which dataset to update [prod|staging|all] 'all' location str Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None Source code in basedosdados/upload/dataset.py def update ( self , mode = \"all\" , location = None ): \"\"\"Update dataset description. Toogle mode to choose which dataset to update. Args: mode (str): Optional. Which dataset to update [prod|staging|all] location (str): Optional. Location of dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations \"\"\" for m in self . _loop_modes ( mode ): # Send the dataset to the API to update, with an explicit timeout. # Raises google.api_core.exceptions.Conflict if the Dataset already # exists within the project. m [ \"client\" ] . update_dataset ( self . _setup_dataset_object ( m [ \"id\" ], location = location , mode = m [ \"mode\" ]), fields = [ \"description\" ], ) # Make an API request. logger . success ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . dataset_id , mode = m [ \"mode\" ], object = \"Dataset\" , action = \"updated\" , ) Class for manage tables in Storage and Big Query Table ( Base ) Manage tables in Google Cloud Storage and BigQuery. Source code in basedosdados/upload/table.py class Table ( Base ): \"\"\" Manage tables in Google Cloud Storage and BigQuery. \"\"\" def __init__ ( self , dataset_id , table_id , ** kwargs ): super () . __init__ ( ** kwargs ) self . table_id = table_id . replace ( \"-\" , \"_\" ) self . dataset_id = dataset_id . replace ( \"-\" , \"_\" ) self . table_full_name = dict ( prod = f \" { self . client [ 'bigquery_prod' ] . project } . { self . dataset_id } . { self . table_id } \" , staging = f \" { self . client [ 'bigquery_staging' ] . project } . { self . dataset_id } _staging. { self . table_id } \" , ) self . table_full_name . update ( dict ( all = deepcopy ( self . table_full_name ))) @property @lru_cache ( 256 ) def table_config ( self ): \"\"\" Load table config \"\"\" # return self._load_yaml(self.table_folder / \"table_config.yaml\") return self . backend . get_table_config ( self . dataset_id , self . table_id ) def _get_table_obj ( self , mode ): \"\"\" Get table object from BigQuery \"\"\" return self . client [ f \"bigquery_ { mode } \" ] . get_table ( self . table_full_name [ mode ]) def _is_partitioned ( self , data_sample_path = None , source_format = None , csv_delimiter = None ): if data_sample_path is not None : table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) else : table_columns = self . _get_columns_metadata_from_api () return bool ( table_columns . get ( \"partition_columns\" , [])) def _load_schema_from_json ( self , columns = None , ): schema = [] for col in columns : # ref: https://cloud.google.com/python/docs/reference/bigquery/latest/google.cloud.bigquery.schema.SchemaField if col . get ( \"name\" ) is None : msg = \"Columns must have a name! Check your data files for columns without name\" raise BaseDosDadosException ( msg ) schema . append ( SchemaField ( name = col . get ( \"name\" ), field_type = col . get ( \"type\" ), description = col . get ( \"description\" , None ), ) ) return schema def _load_staging_schema_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" ): \"\"\" Generate schema from columns metadata in data sample \"\"\" if self . table_exists ( mode = \"staging\" ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_from_data ( data_sample_path = data_sample_path , source_format = source_format , csv_delimiter = csv_delimiter , mode = \"staging\" , ) return self . _load_schema_from_json ( columns = table_columns . get ( \"columns\" )) def _load_schema_from_bq ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" table_columns = self . _get_columns_from_bq () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _load_schema_from_api ( self , mode = \"staging\" ): \"\"\"Load schema from table config Args: mode (bool): Which dataset to create [prod|staging]. \"\"\" if self . table_exists ( mode = mode ): logger . warning ( \" {object} {object_id} allready exists, replacing schema!\" , object_id = self . table_id , object = \"Table\" , ) table_columns = self . _get_columns_metadata_from_api () columns = table_columns . get ( \"partition_columns\" ) + table_columns . get ( \"columns\" ) return self . _load_schema_from_json ( columns = columns ) def _get_columns_from_data ( self , data_sample_path = None , source_format = \"csv\" , csv_delimiter = \",\" , mode = \"staging\" , ): # sourcery skip: low-code-quality \"\"\" Get the partition columns from the structure of data_sample_path. Args: data_sample_path (str, pathlib.PosixPath): Optional. Data sample path to auto complete columns names It supports Comma Delimited CSV, Apache Avro and Apache Parquet. source_format (str): Optional Data source format. Only 'csv', 'avro' and 'parquet' are supported. Defaults to 'csv'. \"\"\" partition_columns = [] if isinstance ( data_sample_path , ( str , Path , ), ): # Check if partitioned and get data sample and partition columns data_sample_path = Path ( data_sample_path ) if data_sample_path . is_dir (): data_sample_path = [ f for f in data_sample_path . glob ( \"**/*\" ) if f . is_file () and f . suffix == f \". { source_format } \" ][ 0 ] partition_columns = [ k . split ( \"=\" )[ 0 ] for k in data_sample_path . as_posix () . split ( \"/\" ) if \"=\" in k ] columns = Datatype ( source_format = source_format ) . header ( data_sample_path = data_sample_path , csv_delimiter = csv_delimiter ) return { \"columns\" : [{ \"name\" : col , \"type\" : \"STRING\" } for col in columns ], \"partition_columns\" : [ { \"name\" : col , \"type\" : \"STRING\" } for col in partition_columns ], } def _get_columns_metadata_from_api ( self , ): \"\"\" Get columns and partition columns from API. \"\"\" table_columns = self . table_config . get ( \"columns\" , {}) columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is False ] partition_columns = [ col for col in table_columns if col . get ( \"isPartition\" , {}) is True ] return { \"columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in columns ], \"partition_columns\" : [ { \"name\" : col . get ( \"name\" ), \"type\" : col . get ( \"bigqueryType\" ) . get ( \"name\" ), \"description\" : col . get ( \"descriptionPt\" ), } for col in partition_columns ], } def _parser_blobs_to_partition_dict ( self ) -> dict : \"\"\" Extracts the partition information from the blobs. \"\"\" if not self . table_exists ( mode = \"staging\" ): return blobs = ( self . client [ \"storage_staging\" ] . bucket ( self . bucket_name ) . list_blobs ( prefix = f \"staging/ { self . dataset_id } / { self . table_id } /\" ) ) partitions_dict = {} # only needs the first bloob for blob in blobs : for folder in blob . name . split ( \"/\" ): if \"=\" in folder : key = folder . split ( \"=\" )[ 0 ] value = folder . split ( \"=\" ) try : partitions_dict [ key ] . append ( value ) except KeyError : partitions_dict [ key ] = [ value ] return partitions_dict def _get_columns_from_bq ( self , mode = \"staging\" ): if not self . table_exists ( mode = mode ): msg = f \"Table { self . dataset_id } . { self . table_id } does not exist in { mode } , please create first!\" raise logger . error ( msg ) else : schema = self . _get_table_obj ( mode = mode ) . schema partition_dict = self . _parser_blobs_to_partition_dict () if partition_dict : partition_columns = list ( partition_dict . keys ()) else : partition_columns = [] return { \"columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name not in partition_columns ], \"partition_columns\" : [ { \"name\" : col . name , \"type\" : col . field_type , \"description\" : col . description , } for col in schema if col . name in partition_columns ], } def _get_cross_columns_from_bq_api ( self ): bq = self . _get_columns_from_bq ( mode = \"staging\" ) bq_columns = bq . get ( \"partition_columns\" ) + bq . get ( \"columns\" ) api = self . _get_columns_metadata_from_api () api_columns = api . get ( \"partition_columns\" ) + api . get ( \"columns\" ) if api_columns != []: for bq_col in bq_columns : for api_col in api_columns : if bq_col . get ( \"name\" ) == api_col . get ( \"name\" ): bq_col [ \"type\" ] = api_col . get ( \"type\" ) bq_col [ \"description\" ] = api_col . get ( \"description\" ) return bq_columns def _make_publish_sql ( self ): \"\"\"Create publish.sql with columns and bigquery_type\"\"\" # publish.sql header and instructions publish_txt = \"\"\" /* Query para publicar a tabela. Esse \u00e9 o lugar para: - modificar nomes, ordem e tipos de colunas - dar join com outras tabelas - criar colunas extras (e.g. logs, propor\u00e7\u00f5es, etc.) Qualquer coluna definida aqui deve tamb\u00e9m existir em `table_config.yaml`. # Al\u00e9m disso, sinta-se \u00e0 vontade para alterar alguns nomes obscuros # para algo um pouco mais expl\u00edcito. TIPOS: - Para modificar tipos de colunas, basta substituir STRING por outro tipo v\u00e1lido. - Exemplo: `SAFE_CAST(column_name AS NUMERIC) column_name` - Mais detalhes: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types */ \"\"\" # table_columns = self._get_columns_from_api(mode=\"staging\") columns = self . _get_cross_columns_from_bq_api () # remove triple quotes extra space publish_txt = inspect . cleandoc ( publish_txt ) publish_txt = textwrap . dedent ( publish_txt ) # add create table statement project_id_prod = self . client [ \"bigquery_prod\" ] . project publish_txt += f \" \\n\\n CREATE OR REPLACE VIEW { project_id_prod } . { self . dataset_id } . { self . table_id } AS \\n SELECT \\n \" # sort columns by is_partition, partitions_columns come first # add columns in publish.sql for col in columns : name = col . get ( \"name\" ) bigquery_type = ( \"STRING\" if col . get ( \"type\" ) is None else col . get ( \"type\" ) . upper () ) publish_txt += f \"SAFE_CAST( { name } AS { bigquery_type } ) { name } , \\n \" # remove last comma publish_txt = publish_txt [: - 2 ] + \" \\n \" # add from statement project_id_staging = self . client [ \"bigquery_staging\" ] . project publish_txt += ( f \"FROM { project_id_staging } . { self . dataset_id } _staging. { self . table_id } AS t\" ) return publish_txt def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) def _get_biglake_connection ( self , set_biglake_connection_permissions = True , location = None , mode = \"staging\" ): connection = Connection ( name = \"biglake\" , location = location , mode = \"staging\" ) if not connection . exists : try : logger . info ( \"Creating BigLake connection...\" ) connection . create () logger . success ( \"BigLake connection created!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"You don't have permission to create a BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) raise BaseDosDadosException ( \"Something went wrong while creating the BigLake connection. \" \"Please contact an admin to create one for you.\" ) from exc if set_biglake_connection_permissions : try : logger . info ( \"Setting permissions for BigLake service account...\" ) connection . set_biglake_permissions () logger . success ( \"Permissions set successfully!\" ) except google . api_core . exceptions . Forbidden as exc : logger . error ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Could not set permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc except Exception as exc : logger . error ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) raise BaseDosDadosException ( \"Something went wrong while setting permissions for BigLake service account. \" \"Please make sure you have permissions to grant roles/storage.objectViewer\" f \" to the BigLake service account. ( { connection . service_account } ).\" \" If you don't, please ask an admin to do it for you or set \" \"set_biglake_connection_permissions=False.\" ) from exc return connection def _get_table_description ( self , mode = \"staging\" ): \"\"\"Adds table description to BigQuery table. Args: table_obj (google.cloud.bigquery.table.Table): Table object. mode (str): Which dataset to check [prod|staging]. \"\"\" table_path = self . table_full_name [ \"prod\" ] if mode == \"staging\" : description = f \"staging table for ` { table_path } `\" else : try : description = self . table_config . get ( \"descriptionPt\" , \"\" ) except BaseException : logger . warning ( f \"table { self . table_id } does not have a description in the API.\" ) description = \"description not available in the API.\" return description def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , ) def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) table_config property readonly Load table config append ( self , filepath , partitions = None , if_exists = 'replace' , chunk_size = None , ** upload_args ) Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Parameters: Name Type Description Default filepath str or pathlib.PosixPath Where to find the file that you want to upload to create a table with required partitions str, pathlib.PosixPath, dict Optional. Hive structured partition as a string or dict str : <key>=<value>/<key2>=<value2> dict: dict(key=value, key2=value2) None if_exists str 0ptional. What to do if data with same name exists in storage 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'replace' chunk_size int Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None Source code in basedosdados/upload/table.py def append ( self , filepath , partitions = None , if_exists = \"replace\" , chunk_size = None , ** upload_args , ): \"\"\"Appends new data to existing BigQuery table. As long as the data has the same schema. It appends the data in the filepath to the existing table. Args: filepath (str or pathlib.PosixPath): Where to find the file that you want to upload to create a table with partitions (str, pathlib.PosixPath, dict): Optional. Hive structured partition as a string or dict * str : `<key>=<value>/<key2>=<value2>` * dict: `dict(key=value, key2=value2)` if_exists (str): 0ptional. What to do if data with same name exists in storage * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing chunk_size (int): Optional The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. \"\"\" if not self . table_exists ( \"staging\" ): raise BaseDosDadosException ( \"You cannot append to a table that does not exist\" ) Storage ( self . dataset_id , self . table_id , ) . upload ( filepath , mode = \"staging\" , partitions = partitions , if_exists = if_exists , chunk_size = chunk_size , ** upload_args , ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"appended\" , ) create ( self , path = None , source_format = 'csv' , csv_delimiter = ',' , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = 'raise' , if_storage_data_exists = 'raise' , if_dataset_exists = 'pass' , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True ) Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at <dataset_id>_staging.<table_id> in BigQuery. Data can be found in Storage at <bucket_name>/staging/<dataset_id>/<table_id>/* and is used to build the table. The following data types are supported: Comma-Delimited CSV Apache Avro Apache Parquet Data can also be partitioned following the Hive partitioning scheme <key1>=<value1>/<key2>=<value2> ; for example, year=2012/country=BR . The partition is automatically detected by searching for partitions in the table_config.yaml file. Parameters: Name Type Description Default path str or pathlib.PosixPath The path to the file to be uploaded to create the table. None source_format str Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. 'csv' csv_delimiter str Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. ',' csv_skip_leading_rows(int) Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. required csv_allow_jagged_rows bool Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. False if_table_exists str Optional. Determines what to do if the table already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_storage_data_exists str Optional. Determines what to do if the data already exists on your bucket: 'raise' : Raises a Conflict exception 'replace' : Replaces the table 'pass' : Does nothing 'raise' if_dataset_exists str Optional. Determines what to do if the dataset already exists: 'raise' : Raises a Conflict exception 'replace' : Replaces the dataset 'pass' : Does nothing 'pass' dataset_is_public bool Optional. Controls if the prod dataset is public or not. By default, staging datasets like dataset_id_staging are not public. True location str Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations None chunk_size int Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. None biglake_table bool Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. False set_biglake_connection_permissions bool Optional. If set to True , attempts to grant the BigLake connection service account access to the table's data in GCS. True Source code in basedosdados/upload/table.py def create ( self , path = None , source_format = \"csv\" , csv_delimiter = \",\" , csv_skip_leading_rows = 1 , csv_allow_jagged_rows = False , if_table_exists = \"raise\" , if_storage_data_exists = \"raise\" , if_dataset_exists = \"pass\" , dataset_is_public = True , location = None , chunk_size = None , biglake_table = False , set_biglake_connection_permissions = True , ): \"\"\"Creates a BigQuery table in the staging dataset. If a path is provided, data is automatically saved in storage, and a datasets folder and BigQuery location are created, in addition to creating the table and its configuration files. The new table is located at `<dataset_id>_staging.<table_id>` in BigQuery. Data can be found in Storage at `<bucket_name>/staging/<dataset_id>/<table_id>/*` and is used to build the table. The following data types are supported: - Comma-Delimited CSV - Apache Avro - Apache Parquet Data can also be partitioned following the Hive partitioning scheme `<key1>=<value1>/<key2>=<value2>`; for example, `year=2012/country=BR`. The partition is automatically detected by searching for `partitions` in the `table_config.yaml` file. Args: path (str or pathlib.PosixPath): The path to the file to be uploaded to create the table. source_format (str): Optional. The format of the data source. Only 'csv', 'avro', and 'parquet' are supported. Defaults to 'csv'. csv_delimiter (str): Optional. The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character. Defaults to ','. csv_skip_leading_rows(int): Optional. The number of rows at the top of a CSV file that BigQuery will skip when loading the data. Defaults to 1. csv_allow_jagged_rows (bool): Optional. Indicates if BigQuery should allow extra values that are not represented in the table schema. Defaults to False. if_table_exists (str): Optional. Determines what to do if the table already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_storage_data_exists (str): Optional. Determines what to do if the data already exists on your bucket: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the table * 'pass' : Does nothing if_dataset_exists (str): Optional. Determines what to do if the dataset already exists: * 'raise' : Raises a Conflict exception * 'replace' : Replaces the dataset * 'pass' : Does nothing dataset_is_public (bool): Optional. Controls if the prod dataset is public or not. By default, staging datasets like `dataset_id_staging` are not public. location (str): Optional. The location of the dataset data. List of possible region names locations: https://cloud.google.com/bigquery/docs/locations chunk_size (int): Optional. The size of a chunk of data whenever iterating (in bytes). This must be a multiple of 256 KB per the API specification. If not specified, the chunk_size of the blob itself is used. If that is not specified, a default value of 40 MB is used. biglake_table (bool): Optional. Sets this as a BigLake table. BigLake tables allow end-users to query from external data (such as GCS) even if they don't have access to the source data. IAM is managed like any other BigQuery native table. See https://cloud.google.com/bigquery/docs/biglake-intro for more on BigLake. set_biglake_connection_permissions (bool): Optional. If set to `True`, attempts to grant the BigLake connection service account access to the table's data in GCS. \"\"\" if path is None : # Look if table data already exists at Storage data = self . client [ \"storage_staging\" ] . list_blobs ( self . bucket_name , prefix = f \"staging/ { self . dataset_id } / { self . table_id } \" ) # Raise: Cannot create table without external data if not data : raise BaseDosDadosException ( \"You must provide a path for uploading data\" ) # Add data to storage if isinstance ( path , ( str , Path , ), ): Storage ( dataset_id = self . dataset_id , table_id = self . table_id , config_path = self . config_path , bucket_name = self . bucket_name , ) . upload ( path = path , mode = \"staging\" , if_exists = if_storage_data_exists , chunk_size = chunk_size , ) # Create Dataset if it doesn't exist dataset_obj = Dataset ( self . dataset_id , ) dataset_obj . create ( if_exists = if_dataset_exists , mode = \"all\" , location = location , dataset_is_public = dataset_is_public , ) if biglake_table : biglake_connection = self . _get_biglake_connection ( set_biglake_connection_permissions = set_biglake_connection_permissions , location = location , mode = \"staging\" , ) biglake_connection_id = biglake_connection . connection_id table = bigquery . Table ( self . table_full_name [ \"staging\" ]) table . description = self . _get_table_description ( mode = \"staging\" ) table . external_data_configuration = Datatype ( dataset_id = self . dataset_id , table_id = self . table_id , schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), source_format = source_format , csv_skip_leading_rows = csv_skip_leading_rows , csv_delimiter = csv_delimiter , csv_allow_jagged_rows = csv_allow_jagged_rows , mode = \"staging\" , bucket_name = self . bucket_name , partitioned = self . _is_partitioned ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ), biglake_connection_id = biglake_connection_id if biglake_table else None , ) . external_config # When using BigLake tables, schema must be provided to the `Table` object if biglake_table : table . schema = self . _load_staging_schema_from_data ( data_sample_path = path , source_format = source_format , csv_delimiter = csv_delimiter , ) logger . info ( f \"Using BigLake connection { biglake_connection_id } \" ) # Lookup if table alreay exists table_ref = None with contextlib . suppress ( google . api_core . exceptions . NotFound ): table_ref = self . client [ \"bigquery_staging\" ] . get_table ( self . table_full_name [ \"staging\" ] ) if isinstance ( table_ref , google . cloud . bigquery . table . Table ): if if_table_exists == \"pass\" : return None if if_table_exists == \"raise\" : raise FileExistsError ( \"Table already exists, choose replace if you want to overwrite it\" ) if if_table_exists == \"replace\" and self . table_exists ( mode = \"staging\" ): self . delete ( mode = \"staging\" ) try : self . client [ \"bigquery_staging\" ] . create_table ( table ) except google . api_core . exceptions . Forbidden as exc : if biglake_table : raise BaseDosDadosException ( \"Permission denied. The service account used to create the BigLake connection\" \" does not have permission to read data from the source bucket. Please grant\" f \" the service account { biglake_connection . service_account } the Storage Object Viewer\" \" (roles/storage.objectViewer) role on the source bucket (or on the project).\" \" Or, you can try running this again with set_biglake_connection_permissions=True.\" ) from exc raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc except Exception as exc : raise BaseDosDadosException ( \"Something went wrong when creating the table. Please check the logs for more information.\" ) from exc logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = \"staging\" , object = \"Table\" , action = \"created\" , ) # return None delete ( self , mode = 'all' ) Deletes table in BigQuery. Parameters: Name Type Description Default mode str Table of which table to delete [prod|staging] 'all' Source code in basedosdados/upload/table.py def delete ( self , mode = \"all\" ): \"\"\"Deletes table in BigQuery. Args: mode (str): Table of which table to delete [prod|staging] \"\"\" self . _check_mode ( mode ) if mode == \"all\" : for m , n in self . table_full_name [ mode ] . items (): self . client [ f \"bigquery_ { m } \" ] . delete_table ( n , not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = m , object = \"Table\" , action = \"deleted\" , ) else : self . client [ f \"bigquery_ { mode } \" ] . delete_table ( self . table_full_name [ mode ], not_found_ok = True ) logger . info ( \" {object} {object_id} _ {mode} was {action} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"deleted\" , ) publish ( self , if_exists = 'raise' , custon_publish_sql = None , custom_schema = None ) Creates BigQuery table at production dataset. Table should be located at <dataset_id>.<table_id> . It creates a view that uses the query from <metadata_path>/<dataset_id>/<table_id>/publish.sql . Make sure that all columns from the query also exists at <metadata_path>/<dataset_id>/<table_id>/table_config.sql , including the partitions. Parameters: Name Type Description Default if_exists str Optional. What to do if table exists. 'raise' : Raises Conflict exception 'replace' : Replace table 'pass' : Do nothing 'raise' Todo: * Check if all required fields are filled Source code in basedosdados/upload/table.py def publish ( self , if_exists = \"raise\" , custon_publish_sql = None , custom_schema = None ): \"\"\"Creates BigQuery table at production dataset. Table should be located at `<dataset_id>.<table_id>`. It creates a view that uses the query from `<metadata_path>/<dataset_id>/<table_id>/publish.sql`. Make sure that all columns from the query also exists at `<metadata_path>/<dataset_id>/<table_id>/table_config.sql`, including the partitions. Args: if_exists (str): Optional. What to do if table exists. * 'raise' : Raises Conflict exception * 'replace' : Replace table * 'pass' : Do nothing Todo: * Check if all required fields are filled \"\"\" # TODO: review this method if if_exists == \"replace\" and self . table_exists ( mode = \"prod\" ): self . delete ( mode = \"prod\" ) publish_sql = self . _make_publish_sql () # create view using API metadata if custon_publish_sql is None : self . client [ \"bigquery_prod\" ] . query ( publish_sql ) . result () self . update ( mode = \"prod\" ) # create view using custon query if custon_publish_sql is not None : self . client [ \"bigquery_prod\" ] . query ( custon_publish_sql ) . result () # update schema using a custom schema if custom_schema is not None : self . update ( custom_schema = custom_schema ) logger . success ( \" {object} {object_id} was {action} !\" , object_id = self . table_id , object = \"Table\" , action = \"published\" , ) table_exists ( self , mode ) Check if table exists in BigQuery. Parameters: Name Type Description Default mode str Which dataset to check [prod|staging]. required Source code in basedosdados/upload/table.py def table_exists ( self , mode ): \"\"\"Check if table exists in BigQuery. Args: mode (str): Which dataset to check [prod|staging]. \"\"\" try : ref = self . _get_table_obj ( mode = mode ) except google . api_core . exceptions . NotFound : ref = None return bool ( ref ) update ( self , mode = 'prod' , custom_schema = None ) Updates BigQuery schema and description. Parameters: Name Type Description Default mode str Optional. Table of which table to update [prod] 'prod' not_found_ok bool Optional. What to do if table is not found required Source code in basedosdados/upload/table.py def update ( self , mode = \"prod\" , custom_schema = None ): \"\"\"Updates BigQuery schema and description. Args: mode (str): Optional. Table of which table to update [prod] not_found_ok (bool): Optional. What to do if table is not found \"\"\" self . _check_mode ( mode ) table = self . _get_table_obj ( mode ) table . description = self . _get_table_description () # when mode is staging the table schema already exists if mode == \"prod\" and custom_schema is None : table . schema = self . _load_schema_from_json ( columns = self . _get_cross_columns_from_bq_api () ) if mode == \"prod\" and custom_schema is not None : table . schema = self . _load_schema_from_json ( custom_schema ) fields = [ \"description\" , \"schema\" ] self . client [ \"bigquery_prod\" ] . update_table ( table , fields = fields ) logger . success ( \" {object} {object_id} was {action} in {mode} !\" , object_id = self . table_id , mode = mode , object = \"Table\" , action = \"updated\" , )","title":"Python"},{"location":"es/api_reference_python/#python","text":"Esta API est\u00e1 compuesta por funciones con 2 tipos de funcionalidad: M\u00f3dulos para solicitud de datos : para aquellos que desean solamente consultar los datos y metadatos de nuestro proyecto. Clases para gesti\u00f3n de datos en Google Cloud: para aquellos que desean subir datos en nuestro proyecto (o cualquier otro proyecto en Google Cloud, siguiendo nuestra metodolog\u00eda e infraestructura). Toda la documentaci\u00f3n del c\u00f3digo siguiente est\u00e1 en ingl\u00e9s","title":"Python"},{"location":"es/api_reference_python/#modulos-solicitud-de-datos","text":"Functions to get metadata from BD's API","title":"M\u00f3dulos (Solicitud de datos)"},{"location":"es/api_reference_python/#clases-gestion-de-datos","text":"Class for managing the files in cloud storage.","title":"Clases (Gesti\u00f3n de datos)"},{"location":"es/api_reference_r/","text":"R Esta API est\u00e1 compuesta solamente de m\u00f3dulos para solicitud de datos , es decir, descarga y/o carga de datos del proyecto en tu entorno de an\u00e1lisis. Para realizar la gesti\u00f3n de datos en Google Cloud, busca las funciones en la API de l\u00ednea de comandos o en Python . La documentaci\u00f3n completa se encuentra en la p\u00e1gina CRAN del proyecto, y sigue abajo. Toda la documentaci\u00f3n del c\u00f3digo abajo est\u00e1 en ingl\u00e9s Este navegador no soporta PDFs. Por favor descarga el PDF para verlo: Descargar PDF . \u00a1Ups, hubo un error! \u00bfY ahora qu\u00e9? Los principales errores encontrados en el paquete de Base de los Datos en Rstudio se derivan de dos factores: * Autenticaci\u00f3n * Versi\u00f3n del paquete `dbplyr` Por lo tanto, si aparece alg\u00fan error, por favor, primero intenta verificar si est\u00e1 relacionado con estos dos factores. Autenticaci\u00f3n La mayor\u00eda de los errores de nuestro paquete est\u00e1n relacionados con problemas de autenticaci\u00f3n. El paquete basedosdados requiere que el usuario proporcione todas las autenticaciones solicitadas por la funci\u00f3n basedosdados::set_billing_id , incluso aquellas que aparecen como opcionales. Por eso, es necesario estar atento si marcaste todas las casillas de selecci\u00f3n cuando Rstudio muestra esta pantalla en el navegador: Ten en cuenta que es necesario marcar incluso las dos \u00faltimas \"casillas\", que aparecen como opcionales . Si olvidaste marcarlas, todas las otras funciones del paquete no funcionar\u00e1n posteriormente. Si ya te has autenticado con autorizaci\u00f3n incompleta, es necesario repetir el proceso de autentificaci\u00f3n. Puedes hacer esto ejecutando gargle::gargle_oauth_sitrep() . Deber\u00e1s verificar la carpeta donde est\u00e1n guardadas las autenticaciones de tu R, entrar en esta carpeta y eliminar la referente a Google Cloud/Bigquery. Hecho esto, al ejecutar basedosdados::set_billing_id podr\u00e1s autenticarte nuevamente. Mira qu\u00e9 simple es: Realizados todos estos procedimientos, es muy probable que los errores anteriores no ocurran m\u00e1s. Versi\u00f3n del paquete dbplyr Otro error com\u00fan est\u00e1 relacionado con el uso de la funci\u00f3n basedosdados::bdplyr . Nuestro paquete en R fue construido utilizando otros paquetes disponibles en la comunidad. Esto significa que las actualizaciones de estos paquetes pueden alterar su funcionamiento y generar efectos en cascada en otros paquetes desarrollados sobre ellos. En este contexto, nuestro paquete funciona solo con la versi\u00f3n 2.1.1 del paquete dbplyr , y no funciona con versiones posteriores. Puedes verificar la versi\u00f3n de tu dbplyr ejecutando utils::packageVersion(\"dbplyr\") en tu R. Si es superior a la versi\u00f3n 2.1.1, necesitas dar un downgrade a la versi\u00f3n correcta. Para esto, puedes ejecutar devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") . Otros errores Caso los errores persistan, puedes abrir una issue en nuestro Github clicando aqui . Tambi\u00e9n puedes visitar las issues que ya fueron resueltas y est\u00e1n atribu\u00eddas con la etiqueta R en nuestro Github aqui .","title":"R"},{"location":"es/api_reference_r/#r","text":"Esta API est\u00e1 compuesta solamente de m\u00f3dulos para solicitud de datos , es decir, descarga y/o carga de datos del proyecto en tu entorno de an\u00e1lisis. Para realizar la gesti\u00f3n de datos en Google Cloud, busca las funciones en la API de l\u00ednea de comandos o en Python . La documentaci\u00f3n completa se encuentra en la p\u00e1gina CRAN del proyecto, y sigue abajo. Toda la documentaci\u00f3n del c\u00f3digo abajo est\u00e1 en ingl\u00e9s Este navegador no soporta PDFs. Por favor descarga el PDF para verlo: Descargar PDF .","title":"R"},{"location":"es/api_reference_r/#ups-hubo-un-error-y-ahora-que","text":"Los principales errores encontrados en el paquete de Base de los Datos en Rstudio se derivan de dos factores: * Autenticaci\u00f3n * Versi\u00f3n del paquete `dbplyr` Por lo tanto, si aparece alg\u00fan error, por favor, primero intenta verificar si est\u00e1 relacionado con estos dos factores.","title":"\u00a1Ups, hubo un error! \u00bfY ahora qu\u00e9?"},{"location":"es/api_reference_r/#autenticacion","text":"La mayor\u00eda de los errores de nuestro paquete est\u00e1n relacionados con problemas de autenticaci\u00f3n. El paquete basedosdados requiere que el usuario proporcione todas las autenticaciones solicitadas por la funci\u00f3n basedosdados::set_billing_id , incluso aquellas que aparecen como opcionales. Por eso, es necesario estar atento si marcaste todas las casillas de selecci\u00f3n cuando Rstudio muestra esta pantalla en el navegador: Ten en cuenta que es necesario marcar incluso las dos \u00faltimas \"casillas\", que aparecen como opcionales . Si olvidaste marcarlas, todas las otras funciones del paquete no funcionar\u00e1n posteriormente. Si ya te has autenticado con autorizaci\u00f3n incompleta, es necesario repetir el proceso de autentificaci\u00f3n. Puedes hacer esto ejecutando gargle::gargle_oauth_sitrep() . Deber\u00e1s verificar la carpeta donde est\u00e1n guardadas las autenticaciones de tu R, entrar en esta carpeta y eliminar la referente a Google Cloud/Bigquery. Hecho esto, al ejecutar basedosdados::set_billing_id podr\u00e1s autenticarte nuevamente. Mira qu\u00e9 simple es: Realizados todos estos procedimientos, es muy probable que los errores anteriores no ocurran m\u00e1s.","title":"Autenticaci\u00f3n"},{"location":"es/api_reference_r/#version-del-paquete-dbplyr","text":"Otro error com\u00fan est\u00e1 relacionado con el uso de la funci\u00f3n basedosdados::bdplyr . Nuestro paquete en R fue construido utilizando otros paquetes disponibles en la comunidad. Esto significa que las actualizaciones de estos paquetes pueden alterar su funcionamiento y generar efectos en cascada en otros paquetes desarrollados sobre ellos. En este contexto, nuestro paquete funciona solo con la versi\u00f3n 2.1.1 del paquete dbplyr , y no funciona con versiones posteriores. Puedes verificar la versi\u00f3n de tu dbplyr ejecutando utils::packageVersion(\"dbplyr\") en tu R. Si es superior a la versi\u00f3n 2.1.1, necesitas dar un downgrade a la versi\u00f3n correcta. Para esto, puedes ejecutar devtools::install_version(\"dbplyr\", version = \"2.1.1\", repos = \"http://cran.us.r-project.org\") .","title":"Versi\u00f3n del paquete dbplyr"},{"location":"es/api_reference_r/#otros-errores","text":"Caso los errores persistan, puedes abrir una issue en nuestro Github clicando aqui . Tambi\u00e9n puedes visitar las issues que ya fueron resueltas y est\u00e1n atribu\u00eddas con la etiqueta R en nuestro Github aqui .","title":"Otros errores"},{"location":"es/api_reference_stata/","text":"Stata Esta API est\u00e1 compuesta por m\u00f3dulos para solicitud de datos : para aquellos que desean solamente consultar los datos y metadatos de nuestro proyecto (o cualquier otro proyecto en Google Cloud). Toda la documentaci\u00f3n del c\u00f3digo siguiente est\u00e1 en ingl\u00e9s M\u00f3dulos (Solicitud de datos) Si es tu primera vez utilizando el paquete, escribe db basedosdados y confirma nuevamente si los pasos anteriores fueron completados con \u00e9xito. El paquete contiene 7 comandos, con sus funcionalidades descritas a continuaci\u00f3n: Comando Descripci\u00f3n bd_download descarga datos de Base de los Datos (BD). bd_read_sql descarga tablas usando consultas espec\u00edficas. bd_read_table descarga tablas usando dataset_id y table_id . bd_list_datasets lista el dataset_id de los conjuntos de datos disponibles en query_project_id . bd_list_dataset_tables lista table_id para tablas disponibles en el dataset_id especificado. bd_get_table_description muestra la descripci\u00f3n completa de la tabla. bd_get_table_columns muestra los nombres, tipos y descripciones de las columnas en la tabla especificada. Cada comando tiene un help file de apoyo, basta con abrir el help y seguir las instrucciones: help [comando]","title":"Stata"},{"location":"es/api_reference_stata/#stata","text":"Esta API est\u00e1 compuesta por m\u00f3dulos para solicitud de datos : para aquellos que desean solamente consultar los datos y metadatos de nuestro proyecto (o cualquier otro proyecto en Google Cloud). Toda la documentaci\u00f3n del c\u00f3digo siguiente est\u00e1 en ingl\u00e9s","title":"Stata"},{"location":"es/api_reference_stata/#modulos-solicitud-de-datos","text":"Si es tu primera vez utilizando el paquete, escribe db basedosdados y confirma nuevamente si los pasos anteriores fueron completados con \u00e9xito. El paquete contiene 7 comandos, con sus funcionalidades descritas a continuaci\u00f3n: Comando Descripci\u00f3n bd_download descarga datos de Base de los Datos (BD). bd_read_sql descarga tablas usando consultas espec\u00edficas. bd_read_table descarga tablas usando dataset_id y table_id . bd_list_datasets lista el dataset_id de los conjuntos de datos disponibles en query_project_id . bd_list_dataset_tables lista table_id para tablas disponibles en el dataset_id especificado. bd_get_table_description muestra la descripci\u00f3n completa de la tabla. bd_get_table_columns muestra los nombres, tipos y descripciones de las columnas en la tabla especificada. Cada comando tiene un help file de apoyo, basta con abrir el help y seguir las instrucciones: help [comando]","title":"M\u00f3dulos (Solicitud de datos)"},{"location":"es/colab_checks/","text":"Colaborando con pruebas en BD Para mantener la calidad de las bases de datos presentes en BD, contamos con un conjunto de verificaciones autom\u00e1ticas que se realizan durante la inserci\u00f3n y actualizaci\u00f3n de cada base. Estas verificaciones son necesarias, pero no suficientes para garantizar la calidad de los datos. Realizan consultas b\u00e1sicas, como si la tabla existe o si tiene columnas totalmente nulas. Puedes colaborar con BD aumentando la cobertura de las pruebas, disminuyendo as\u00ed el trabajo de revisi\u00f3n de los datos. Para esto basta con crear consultas que prueben la calidad de los datos en SQL, como las siguientes: Verificar si las columnas con proporci\u00f3n tienen valores entre 0 y 100 Verificar si las columnas con fechas siguen el patr\u00f3n YYYY-MM-DD HH:MM:SS \u00bfCu\u00e1l es el procedimiento? Incluir pruebas de datos debe seguir el flujo de trabajo: Colaborando con pruebas en BD \u00bfCu\u00e1l es el procedimiento? 1. Informa tu inter\u00e9s 2. Escribe tu consulta 3. Env\u00eda tu consulta \u00a1Sugerimos que te unas a nuestro canal de Discord para resolver dudas e interactuar con otros(as) colaboradores(as)! :) 1. Informa tu inter\u00e9s Conversa con nosotros en el chat de infraestructura en Discord. Si no tienes una sugerencia de mejora, podemos buscar alguna consulta que a\u00fan no haya sido escrita. 2. Escribe tu consulta Haz un fork del repositorio de Base de los Datos . Luego agrega nuevas consultas y sus respectivas funciones de ejecuci\u00f3n en los archivos checks.yaml y test_data.py . Las consultas se escriben en un archivo YAML con Jinja y SQL, de la siguiente forma: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure Y se ejecutan como pruebas del paquete pytest : def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False No te asustes si no conoces algo de la sintaxis anterior, podemos ayudarte durante el proceso. Ten en cuenta que los valores entre llaves son variables contenidas en archivos table_config.yaml , que contienen metadatos de las tablas. Por lo tanto, la escritura de consultas est\u00e1 limitada por los metadatos existentes. Recomendamos consultar estos archivos en el directorio de las bases . 3. Env\u00eda tu consulta Finalmente, realiza un pull request al repositorio principal para que se realice una revisi\u00f3n de la consulta.","title":"Pruebas"},{"location":"es/colab_checks/#colaborando-con-pruebas-en-bd","text":"Para mantener la calidad de las bases de datos presentes en BD, contamos con un conjunto de verificaciones autom\u00e1ticas que se realizan durante la inserci\u00f3n y actualizaci\u00f3n de cada base. Estas verificaciones son necesarias, pero no suficientes para garantizar la calidad de los datos. Realizan consultas b\u00e1sicas, como si la tabla existe o si tiene columnas totalmente nulas. Puedes colaborar con BD aumentando la cobertura de las pruebas, disminuyendo as\u00ed el trabajo de revisi\u00f3n de los datos. Para esto basta con crear consultas que prueben la calidad de los datos en SQL, como las siguientes: Verificar si las columnas con proporci\u00f3n tienen valores entre 0 y 100 Verificar si las columnas con fechas siguen el patr\u00f3n YYYY-MM-DD HH:MM:SS","title":"Colaborando con pruebas en BD"},{"location":"es/colab_checks/#cual-es-el-procedimiento","text":"Incluir pruebas de datos debe seguir el flujo de trabajo: Colaborando con pruebas en BD \u00bfCu\u00e1l es el procedimiento? 1. Informa tu inter\u00e9s 2. Escribe tu consulta 3. Env\u00eda tu consulta \u00a1Sugerimos que te unas a nuestro canal de Discord para resolver dudas e interactuar con otros(as) colaboradores(as)! :)","title":"\u00bfCu\u00e1l es el procedimiento?"},{"location":"es/colab_checks/#1-informa-tu-interes","text":"Conversa con nosotros en el chat de infraestructura en Discord. Si no tienes una sugerencia de mejora, podemos buscar alguna consulta que a\u00fan no haya sido escrita.","title":"1. Informa tu inter\u00e9s"},{"location":"es/colab_checks/#2-escribe-tu-consulta","text":"Haz un fork del repositorio de Base de los Datos . Luego agrega nuevas consultas y sus respectivas funciones de ejecuci\u00f3n en los archivos checks.yaml y test_data.py . Las consultas se escriben en un archivo YAML con Jinja y SQL, de la siguiente forma: test_select_all_works : name : Check if select query in {{ table_id }} works query : | SELECT NOT EXISTS ( SELECT * FROM `{{ project_id_staging }}.{{ dataset_id }}.{{ table_id }}` ) AS failure Y se ejecutan como pruebas del paquete pytest : def test_select_all_works ( configs ): result = fetch_data ( \"test_select_all_works\" , configs ) assert result . failure . values == False No te asustes si no conoces algo de la sintaxis anterior, podemos ayudarte durante el proceso. Ten en cuenta que los valores entre llaves son variables contenidas en archivos table_config.yaml , que contienen metadatos de las tablas. Por lo tanto, la escritura de consultas est\u00e1 limitada por los metadatos existentes. Recomendamos consultar estos archivos en el directorio de las bases .","title":"2. Escribe tu consulta"},{"location":"es/colab_checks/#3-envia-tu-consulta","text":"Finalmente, realiza un pull request al repositorio principal para que se realice una revisi\u00f3n de la consulta.","title":"3. Env\u00eda tu consulta"},{"location":"es/colab_data/","text":"Suba datos en BD \u00bfPor qu\u00e9 mi organizaci\u00f3n deber\u00eda subir datos a BD? Capacidad de cruzar sus bases con datos de diferentes organizaciones de forma simple y f\u00e1cil. Ya hay cientos de conjuntos de datos p\u00fablicos de las mayores organizaciones de Brasil y del mundo presentes en nuestro data lake . Compromiso con la transparencia, calidad de los datos y desarrollo de mejores investigaciones, an\u00e1lisis y soluciones para la sociedad. No solo democratizamos el acceso a datos abiertos, sino tambi\u00e9n datos de calidad. Tenemos un equipo especializado que revisa y garantiza la calidad de los datos a\u00f1adidos al data lake . Participaci\u00f3n en una comunidad que crece cada vez m\u00e1s : miles de periodistas, investigadores(as), desarrolladores(as), ya utilizan y siguen la Base de los Datos. Paso a paso para subir datos \u00bfQuieres subir datos a BD y ayudarnos a construir este repositorio? \u00a1 Maravilloso! Organizamos todo lo que necesitas en el manual a continuaci\u00f3n en 8 pasos Para facilitar la explicaci\u00f3n, seguiremos un ejemplo ya listo con datos de RAIS . Puedes navegar por las etapas en el men\u00fa de la izquierda. \u00a1Sugerimos encarecidamente que te unas a nuestro canal en Discord para resolver dudas e interactuar con el equipo y otros(as) colaboradores(as)! \ud83d\ude09 Antes de empezar Algunos conocimientos son necesarios para realizar este proceso: Python, R, SQL y/o Stata : para crear los c\u00f3digos de captura y limpieza de los datos. L\u00ednea de comandos : para configurar tu ambiente local y conexi\u00f3n con Google Cloud. Github : para subir tu c\u00f3digo para revisi\u00f3n de nuestro equipo. \u00bfNo tienes alguna de estas habilidades, pero quieres colaborar? Tenemos un equipo de datos que puede ayudarte, solo \u00fanete a nuestro Discord y env\u00eda un mensaje en #quiero-contribuir. \u00bfC\u00f3mo funciona el proceso? 1. Elegir la base y entender m\u00e1s de los datos - primero necesitamos conocer lo que estamos tratando. 2. Descargar nuestra carpeta template - es hora de estructurar el trabajo a realizar 3. Completar las tablas de arquitectura - es primordial definir la estructura de los datos antes de iniciar el tratamiento 4. Escribir c\u00f3digo de captura y limpieza de datos - \u00a1hora de poner manos a la obra! 5. (Si es necesario) Organizar archivos auxiliares - porque hasta los datos necesitan gu\u00edas 6. (Si es necesario) Crear tabla diccionario - momento de armar los diccionarios 7. Subir todo a Google Cloud - despu\u00e9s de todo, es all\u00ed donde est\u00e1n los datos de BD 8. Enviar todo para revisi\u00f3n - \u00a1una mirada de nuestro equipo para garantizar que todo est\u00e1 listo para producci\u00f3n! 1. Elegir la base y entender m\u00e1s de los datos Mantenemos la lista de conjuntos para voluntarios en nuestro Github . Para empezar a subir una base de tu inter\u00e9s, solo abre un nuevo issue de datos. Si tu base (conjunto) ya est\u00e1 listada, solo marca tu usuario de Github como assignee Tu primer trabajo es completar la informaci\u00f3n en el issue. Esta informaci\u00f3n te ayudar\u00e1 a entender mejor los datos y ser\u00e1 muy \u00fatil para el tratamiento y el llenado de metadatos. Cuando finalices esta etapa, llama a alguien del equipo de datos para que la informaci\u00f3n que has mapeado sobre el conjunto ya entre en nuestro sitio! 2. Descargar nuestra carpeta template Descarga aqu\u00ed la carpeta template y ren\u00f3mbrala como <dataset_id> (definido en el issue del paso 1 ). Esta carpeta template facilita y organiza todos los pasos de aqu\u00ed en adelante. Su estructura es la siguiente: <dataset_id>/ code/ : C\u00f3digos necesarios para captura y limpieza de los datos ( veremos m\u00e1s en el paso 4 ). input/ : Contiene todos los archivos con datos originales, exactamente como se descargaron de la fuente primaria. ( veremos m\u00e1s en el paso 4 ). output/ : Archivos finales, ya en el formato listo para subir a BD ( veremos m\u00e1s en el paso 4 ). tmp/ : Cualquier archivo temporal creado por el c\u00f3digo en /code en el proceso de limpieza y tratamiento ( veremos m\u00e1s en el paso 4 ). extra/ architecture/ : Tablas de arquitectura ( veremos m\u00e1s en el paso 3 ). auxiliary_files/ : Archivos auxiliares a los datos ( veremos m\u00e1s en el paso 5 ). dicionario.csv : Tabla diccionario de todo el conjunto de datos ( veremos m\u00e1s en el paso 6 ). Solo la carpeta code ser\u00e1 commitada para tu proyecto, los dem\u00e1s archivos existir\u00e1n solo localmente o en Google Cloud. 3. Completar las tablas de arquitectura Las tablas de arquitectura determinan cu\u00e1l es la estructura de cada tabla de tu conjunto de datos . Definen, por ejemplo, el nombre, orden y metadatos de las variables, adem\u00e1s de compatibilizaciones cuando hay cambios en versiones (por ejemplo, si una variable cambia de nombre de un a\u00f1o a otro). Cada tabla del conjunto de datos debe tener su propia tabla de arquitectura (hoja de c\u00e1lculo), que debe ser completada en Google Drive para permitir la correcci\u00f3n por nuestro equipo de datos. Ejemplo: RAIS - Tablas de arquitectura Las tablas de arquitectura de RAIS pueden ser consultadas aqu\u00ed . Son una excelente referencia para que empieces tu trabajo ya que tienen muchas variables y ejemplos de diversas situaciones que puedes encontrar. Para completar cada tabla de tu conjunto sigue este paso a paso: Al inicio y final de cada etapa consulta nuestro manual de estilo para garantizar que est\u00e1s siguiendo la estandarizaci\u00f3n de BD Listar todas las variables de los datos en la columna original_name Obs: Si la base cambia el nombre de las variables a lo largo de los a\u00f1os (como RAIS), es necesario hacer la compatibilizaci\u00f3n entre a\u00f1os para todas las variables completando la columna de original_name_YYYY para cada a\u00f1o o mes disponible Renombrar las variables seg\u00fan nuestro manual en la columna name Entender el tipo de variable y completar la columna bigquery_type Completar la descripci\u00f3n en description seg\u00fan el manual A partir de la compatibilizaci\u00f3n entre a\u00f1os y/o consultas a los datos brutos, completar la cobertura temporal en temporal_coverage de cada variable Obs: Si las variables tienen la misma cobertura temporal que la tabla completar solo con '(1)' Indicar con 'yes' o 'no' si hay diccionario para las variables en covered_by_dictionary Verificar si las variables representan alguna entidad presente en los directorios para completar el directory_column Para las variables del tipo int64 o float64 verificar si es necesario incluir una unidad de medida Reordenar las variables seg\u00fan el manual Cuando termines de completar las tablas de arquitectura, contacta con el equipo de Base de los Datos para validar todo. Es necesario que est\u00e9 claro el formato final que los datos deben tener antes de empezar a escribir el c\u00f3digo. As\u00ed evitamos el retrabajo. 4. Escribir c\u00f3digo de captura y limpieza de datos Despu\u00e9s de validadas las tablas de arquitectura, podemos escribir los c\u00f3digos de captura y limpieza de los datos. Captura : C\u00f3digo que descarga autom\u00e1ticamente todos los datos originales y los guarda en /input . Estos datos pueden estar disponibles en portales o enlaces FTP, pueden ser raspados de sitios, entre otros. Limpieza : C\u00f3digo que transforma los datos originales guardados en /input en datos limpios, guarda en la carpeta /output , para, posteriormente, ser subidos a BD. Cada tabla limpia para producci\u00f3n puede ser guardada como un archivo \u00fanico o, si es muy grande (por ejemplo, por encima de 200 mb), ser particionada en el formato Hive en varios sub-archivos. Los formatos aceptados son .csv o .parquet . Nuestra recomendaci\u00f3n es particionar tablas por ano , mes y sigla_uf . El particionamiento se hace a trav\u00e9s de la estructura de carpetas, ve el ejemplo abajo para visualizar c\u00f3mo. Ejemplo: RAIS - Particionamiento La tabla microdados_vinculos de RAIS, por ejemplo, es una tabla muy grande (+250GB) por eso nosotros particionamos por ano y sigla_uf . El particionamiento se hizo usando la estructura de carpetas /microdados_vinculos/ano=YYYY/sigla_uf=XX . Est\u00e1ndares necesarios en el c\u00f3digo Deben ser escritos en Python , R o Stata - para que la revisi\u00f3n pueda ser realizada por el equipo. Puede estar en script ( .py , .R , ...) o notebooks (Google Colab, Jupyter, Rmarkdown, etc). Las rutas de archivos deben ser atajos relativos a la carpeta ra\u00edz ( <dataset_id> ), es decir, no deben depender de las rutas de tu computadora. La limpieza debe seguir nuestro manual de estilo y las mejores pr\u00e1cticas de programaci\u00f3n . Ejemplo: PNAD Continua - C\u00f3digo de limpieza El c\u00f3digo de limpieza fue construido en R y puede ser consultado aqu\u00ed . Ejemplo: Actividad en la C\u00e1mara Legislativa - C\u00f3digo de descarga y limpieza El c\u00f3digo de limpieza fue construido en Python puede ser consultado aqu\u00ed 5. (Si es necesario) Organizar archivos auxiliares Es com\u00fan que las bases de datos sean disponibilizadas con archivos auxiliares. Estos pueden incluir notas t\u00e9cnicas, descripciones de recolecci\u00f3n y muestreo, etc. Para ayudar a los usuarios de Base de los Datos a tener m\u00e1s contexto y entender mejor los datos, organiza todos estos archivos auxiliares en /extra/auxiliary_files . Si\u00e9ntete libre de estructurar sub-carpetas como quieras all\u00ed dentro. Lo que importa es que quede claro qu\u00e9 son estos archivos. 6. (Si es necesario) Crear tabla diccionario Muchas veces, especialmente con bases antiguas, hay m\u00faltiples diccionarios en formatos Excel u otros. En Base de los Datos unificamos todo en un \u00fanico archivo en formato .csv - un \u00fanico diccionario para todas las columnas de todas las tablas de tu conjunto. Detalles importantes de c\u00f3mo construir tu diccionario est\u00e1n en nuestro manual de estilo . Ejemplo: RAIS - Diccionario El diccionario completo puede ser consultado aqu\u00ed . Ya posee la estructura est\u00e1ndar que utilizamos para diccionarios. 7. Subir todo a Google Cloud \u00a1Todo listo! Ahora solo falta subir a Google Cloud y enviar para revisi\u00f3n. Para esto, vamos a usar el cliente basedosdados (disponible en Python) que facilita las configuraciones y etapas del proceso. Como existe un costo para el almacenamiento en storage, para finalizar esta etapa necesitaremos proporcionarte una api_key espec\u00edfica para voluntarios para subir los datos en nuestro ambiente de desarrollo. As\u00ed que \u00fanete a nuestro canal en Discord y ll\u00e1manos en 'quiero-contribuir' Configura tus credenciales localmente 7.1 En tu terminal instala nuestro cliente: pip install basedosdados . 7.2 Ejecuta import basedosdados as bd en python y sigue el paso a paso para configurar localmente con las credenciales de tu proyecto en Google Cloud. Completa la informaci\u00f3n como sigue: * STEP 1: y * STEP 2: basedosdados-dev (colocar el .json pasado por el equipo de bd en la carpeta credentials) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql Sube los archivos a la Cloud Los datos pasar\u00e1n por 3 lugares en Google Cloud: Storage : tambi\u00e9n llamado GCS es el lugar donde ser\u00e1n almacenados los archivos \"fr\u00edos\" (arquitecturas, datos, archivos auxiliares). BigQuery-DEV-Staging : tabla que conecta los datos del storage al proyecto basedosdados-dev en bigquery BigQuery-DEV-Producci\u00f3n : tabla utilizada para pruebas y tratamiento v\u00eda SQL del conjunto de datos 7.3 Crea la tabla en el bucket del GCS y BigQuey-DEV-staging , usando la API de Python, de la siguiente forma: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<ruta_para_los_datos>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` Los siguientes par\u00e1metros pueden ser usados: - `path` (obligatorio): la ruta completa del archivo en tu computadora, como: `/Users/<tu_usuario>/proyectos/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"Si tus datos est\u00e1n particionados, la ruta debe apuntar a la carpeta donde est\u00e1n las particiones. En caso contrario, debe apuntar a un archivo `.csv` (por ejemplo, microdados.csv).\" - `force_dataset`: comando que crea los archivos de configuraci\u00f3n del dataset en BigQuery. - _True_: los archivos de configuraci\u00f3n del dataset ser\u00e1n creados en tu proyecto y, si no existe en BigQuery, ser\u00e1 creado autom\u00e1ticamente. **Si ya has creado y configurado el dataset, no uses esta opci\u00f3n, pues sobrescribir\u00e1 archivos**. - _False_: el dataset no ser\u00e1 recreado y, si no existe, ser\u00e1 creado autom\u00e1ticamente. - `if_table_exists` : comando utilizado si la **tabla ya existe en BQ**: - _raise_: retorna mensaje de error. - _replace_: sustituye la tabla. - _pass_: no hace nada. - `if_storage_data_exists`: comando utilizado si los **datos ya existen en Google Cloud Storage**: - _raise_: retorna mensaje de error - _replace_: sustituye los datos existentes. - _pass_: no hace nada. !!! Info \"Si el proyecto no existe en BigQuery, ser\u00e1 autom\u00e1ticamente creado\" Consulta tambi\u00e9n nuestra API para m\u00e1s detalles de cada m\u00e9todo. 7.4 Crea los archivos .sql y schema.yml a partir de la tabla de arquitectura siguiendo esta documentaci\u00f3n Si lo necesitas, en este momento puedes alterar la consulta en SQL para realizar tratamientos finales a partir de la tabla staging , puedes incluir columna, remover columna, hacer operaciones algebraicas, sustituir strings, etc. \u00a1El SQL es el l\u00edmite! 7.5 Ejecuta y prueba los modelos localmente siguiendo esta documentaci\u00f3n 7.6 Sube los metadatos de la tabla en el sitio: Por ahora solo el equipo de datos tiene permisos para subir los metadatos de la tabla en el sitio, por eso ser\u00e1 necesario contactar con nosotros. Ya estamos trabajando para que, en un futuro pr\u00f3ximo, los voluntarios tambi\u00e9n puedan actualizar datos en el sitio. 7.7 Sube los archivos auxiliares: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'ruta_para_los_archivos_auxiliares' , mode = 'auxiliary_files' , if_exists = 'raise' ) 8. Enviar todo para revisi\u00f3n \u00a1Uf, eso es todo! Ahora solo queda enviar todo para revisi\u00f3n en el repositorio de Base de los Datos. Clona nuestro repositorio localmente. Da un cd a la carpeta local del repositorio y abre una nueva branch con git checkout -b [dataset_id] . Todas las adiciones y modificaciones ser\u00e1n incluidas en esa branch . Para cada tabla nueva incluir el archivo con nombre table_id.sql en la carpeta queries-basedosdados/models/dataset_id/ copiando las queries que desarrollaste en el paso 7. Incluir el archivo schema.yaml desarrollado en el paso 7 Si es un dataset nuevo, incluir el dataset conforme las instrucciones del archivo queries-basedosdados/dbt_project.yaml (no te olvides de seguir el orden alfab\u00e9tico para no desordenar la organizaci\u00f3n) Incluye tu c\u00f3digo de captura y limpieza en la carpeta queries-basedosdados/models/dataset_id/code Ahora solo falta publicar la branch, abrir el PR con las labels 'table-approve' y marcar al equipo de datos para correcci\u00f3n \u00bfY ahora? Nuestro equipo revisar\u00e1 los datos y metadatos enviados v\u00eda Github. Podemos contactarte para resolver dudas o solicitar cambios en el c\u00f3digo. Cuando todo est\u00e9 OK, hacemos un merge de tu pull request y los datos son autom\u00e1ticamente publicados en nuestra plataforma!","title":"Datos"},{"location":"es/colab_data/#suba-datos-en-bd","text":"","title":"Suba datos en BD"},{"location":"es/colab_data/#por-que-mi-organizacion-deberia-subir-datos-a-bd","text":"Capacidad de cruzar sus bases con datos de diferentes organizaciones de forma simple y f\u00e1cil. Ya hay cientos de conjuntos de datos p\u00fablicos de las mayores organizaciones de Brasil y del mundo presentes en nuestro data lake . Compromiso con la transparencia, calidad de los datos y desarrollo de mejores investigaciones, an\u00e1lisis y soluciones para la sociedad. No solo democratizamos el acceso a datos abiertos, sino tambi\u00e9n datos de calidad. Tenemos un equipo especializado que revisa y garantiza la calidad de los datos a\u00f1adidos al data lake . Participaci\u00f3n en una comunidad que crece cada vez m\u00e1s : miles de periodistas, investigadores(as), desarrolladores(as), ya utilizan y siguen la Base de los Datos.","title":"\u00bfPor qu\u00e9 mi organizaci\u00f3n deber\u00eda subir datos a BD?"},{"location":"es/colab_data/#paso-a-paso-para-subir-datos","text":"\u00bfQuieres subir datos a BD y ayudarnos a construir este repositorio? \u00a1 Maravilloso! Organizamos todo lo que necesitas en el manual a continuaci\u00f3n en 8 pasos Para facilitar la explicaci\u00f3n, seguiremos un ejemplo ya listo con datos de RAIS . Puedes navegar por las etapas en el men\u00fa de la izquierda. \u00a1Sugerimos encarecidamente que te unas a nuestro canal en Discord para resolver dudas e interactuar con el equipo y otros(as) colaboradores(as)! \ud83d\ude09","title":"Paso a paso para subir datos"},{"location":"es/colab_data/#antes-de-empezar","text":"Algunos conocimientos son necesarios para realizar este proceso: Python, R, SQL y/o Stata : para crear los c\u00f3digos de captura y limpieza de los datos. L\u00ednea de comandos : para configurar tu ambiente local y conexi\u00f3n con Google Cloud. Github : para subir tu c\u00f3digo para revisi\u00f3n de nuestro equipo. \u00bfNo tienes alguna de estas habilidades, pero quieres colaborar? Tenemos un equipo de datos que puede ayudarte, solo \u00fanete a nuestro Discord y env\u00eda un mensaje en #quiero-contribuir.","title":"Antes de empezar"},{"location":"es/colab_data/#como-funciona-el-proceso","text":"1. Elegir la base y entender m\u00e1s de los datos - primero necesitamos conocer lo que estamos tratando. 2. Descargar nuestra carpeta template - es hora de estructurar el trabajo a realizar 3. Completar las tablas de arquitectura - es primordial definir la estructura de los datos antes de iniciar el tratamiento 4. Escribir c\u00f3digo de captura y limpieza de datos - \u00a1hora de poner manos a la obra! 5. (Si es necesario) Organizar archivos auxiliares - porque hasta los datos necesitan gu\u00edas 6. (Si es necesario) Crear tabla diccionario - momento de armar los diccionarios 7. Subir todo a Google Cloud - despu\u00e9s de todo, es all\u00ed donde est\u00e1n los datos de BD 8. Enviar todo para revisi\u00f3n - \u00a1una mirada de nuestro equipo para garantizar que todo est\u00e1 listo para producci\u00f3n!","title":"\u00bfC\u00f3mo funciona el proceso?"},{"location":"es/colab_data/#1-elegir-la-base-y-entender-mas-de-los-datos","text":"Mantenemos la lista de conjuntos para voluntarios en nuestro Github . Para empezar a subir una base de tu inter\u00e9s, solo abre un nuevo issue de datos. Si tu base (conjunto) ya est\u00e1 listada, solo marca tu usuario de Github como assignee Tu primer trabajo es completar la informaci\u00f3n en el issue. Esta informaci\u00f3n te ayudar\u00e1 a entender mejor los datos y ser\u00e1 muy \u00fatil para el tratamiento y el llenado de metadatos. Cuando finalices esta etapa, llama a alguien del equipo de datos para que la informaci\u00f3n que has mapeado sobre el conjunto ya entre en nuestro sitio!","title":"1. Elegir la base y entender m\u00e1s de los datos"},{"location":"es/colab_data/#2-descargar-nuestra-carpeta-template","text":"Descarga aqu\u00ed la carpeta template y ren\u00f3mbrala como <dataset_id> (definido en el issue del paso 1 ). Esta carpeta template facilita y organiza todos los pasos de aqu\u00ed en adelante. Su estructura es la siguiente: <dataset_id>/ code/ : C\u00f3digos necesarios para captura y limpieza de los datos ( veremos m\u00e1s en el paso 4 ). input/ : Contiene todos los archivos con datos originales, exactamente como se descargaron de la fuente primaria. ( veremos m\u00e1s en el paso 4 ). output/ : Archivos finales, ya en el formato listo para subir a BD ( veremos m\u00e1s en el paso 4 ). tmp/ : Cualquier archivo temporal creado por el c\u00f3digo en /code en el proceso de limpieza y tratamiento ( veremos m\u00e1s en el paso 4 ). extra/ architecture/ : Tablas de arquitectura ( veremos m\u00e1s en el paso 3 ). auxiliary_files/ : Archivos auxiliares a los datos ( veremos m\u00e1s en el paso 5 ). dicionario.csv : Tabla diccionario de todo el conjunto de datos ( veremos m\u00e1s en el paso 6 ). Solo la carpeta code ser\u00e1 commitada para tu proyecto, los dem\u00e1s archivos existir\u00e1n solo localmente o en Google Cloud.","title":"2. Descargar nuestra carpeta template"},{"location":"es/colab_data/#3-completar-las-tablas-de-arquitectura","text":"Las tablas de arquitectura determinan cu\u00e1l es la estructura de cada tabla de tu conjunto de datos . Definen, por ejemplo, el nombre, orden y metadatos de las variables, adem\u00e1s de compatibilizaciones cuando hay cambios en versiones (por ejemplo, si una variable cambia de nombre de un a\u00f1o a otro). Cada tabla del conjunto de datos debe tener su propia tabla de arquitectura (hoja de c\u00e1lculo), que debe ser completada en Google Drive para permitir la correcci\u00f3n por nuestro equipo de datos.","title":"3. Completar las tablas de arquitectura"},{"location":"es/colab_data/#ejemplo-rais-tablas-de-arquitectura","text":"Las tablas de arquitectura de RAIS pueden ser consultadas aqu\u00ed . Son una excelente referencia para que empieces tu trabajo ya que tienen muchas variables y ejemplos de diversas situaciones que puedes encontrar.","title":"Ejemplo: RAIS - Tablas de arquitectura"},{"location":"es/colab_data/#para-completar-cada-tabla-de-tu-conjunto-sigue-este-paso-a-paso","text":"Al inicio y final de cada etapa consulta nuestro manual de estilo para garantizar que est\u00e1s siguiendo la estandarizaci\u00f3n de BD Listar todas las variables de los datos en la columna original_name Obs: Si la base cambia el nombre de las variables a lo largo de los a\u00f1os (como RAIS), es necesario hacer la compatibilizaci\u00f3n entre a\u00f1os para todas las variables completando la columna de original_name_YYYY para cada a\u00f1o o mes disponible Renombrar las variables seg\u00fan nuestro manual en la columna name Entender el tipo de variable y completar la columna bigquery_type Completar la descripci\u00f3n en description seg\u00fan el manual A partir de la compatibilizaci\u00f3n entre a\u00f1os y/o consultas a los datos brutos, completar la cobertura temporal en temporal_coverage de cada variable Obs: Si las variables tienen la misma cobertura temporal que la tabla completar solo con '(1)' Indicar con 'yes' o 'no' si hay diccionario para las variables en covered_by_dictionary Verificar si las variables representan alguna entidad presente en los directorios para completar el directory_column Para las variables del tipo int64 o float64 verificar si es necesario incluir una unidad de medida Reordenar las variables seg\u00fan el manual Cuando termines de completar las tablas de arquitectura, contacta con el equipo de Base de los Datos para validar todo. Es necesario que est\u00e9 claro el formato final que los datos deben tener antes de empezar a escribir el c\u00f3digo. As\u00ed evitamos el retrabajo.","title":"Para completar cada tabla de tu conjunto sigue este paso a paso:"},{"location":"es/colab_data/#4-escribir-codigo-de-captura-y-limpieza-de-datos","text":"Despu\u00e9s de validadas las tablas de arquitectura, podemos escribir los c\u00f3digos de captura y limpieza de los datos. Captura : C\u00f3digo que descarga autom\u00e1ticamente todos los datos originales y los guarda en /input . Estos datos pueden estar disponibles en portales o enlaces FTP, pueden ser raspados de sitios, entre otros. Limpieza : C\u00f3digo que transforma los datos originales guardados en /input en datos limpios, guarda en la carpeta /output , para, posteriormente, ser subidos a BD. Cada tabla limpia para producci\u00f3n puede ser guardada como un archivo \u00fanico o, si es muy grande (por ejemplo, por encima de 200 mb), ser particionada en el formato Hive en varios sub-archivos. Los formatos aceptados son .csv o .parquet . Nuestra recomendaci\u00f3n es particionar tablas por ano , mes y sigla_uf . El particionamiento se hace a trav\u00e9s de la estructura de carpetas, ve el ejemplo abajo para visualizar c\u00f3mo.","title":"4. Escribir c\u00f3digo de captura y limpieza de datos"},{"location":"es/colab_data/#ejemplo-rais-particionamiento","text":"La tabla microdados_vinculos de RAIS, por ejemplo, es una tabla muy grande (+250GB) por eso nosotros particionamos por ano y sigla_uf . El particionamiento se hizo usando la estructura de carpetas /microdados_vinculos/ano=YYYY/sigla_uf=XX .","title":"Ejemplo: RAIS - Particionamiento"},{"location":"es/colab_data/#estandares-necesarios-en-el-codigo","text":"Deben ser escritos en Python , R o Stata - para que la revisi\u00f3n pueda ser realizada por el equipo. Puede estar en script ( .py , .R , ...) o notebooks (Google Colab, Jupyter, Rmarkdown, etc). Las rutas de archivos deben ser atajos relativos a la carpeta ra\u00edz ( <dataset_id> ), es decir, no deben depender de las rutas de tu computadora. La limpieza debe seguir nuestro manual de estilo y las mejores pr\u00e1cticas de programaci\u00f3n .","title":"Est\u00e1ndares necesarios en el c\u00f3digo"},{"location":"es/colab_data/#ejemplo-pnad-continua-codigo-de-limpieza","text":"El c\u00f3digo de limpieza fue construido en R y puede ser consultado aqu\u00ed .","title":"Ejemplo: PNAD Continua - C\u00f3digo de limpieza"},{"location":"es/colab_data/#ejemplo-actividad-en-la-camara-legislativa-codigo-de-descarga-y-limpieza","text":"El c\u00f3digo de limpieza fue construido en Python puede ser consultado aqu\u00ed","title":"Ejemplo: Actividad en la C\u00e1mara Legislativa - C\u00f3digo de descarga y limpieza"},{"location":"es/colab_data/#5-si-es-necesario-organizar-archivos-auxiliares","text":"Es com\u00fan que las bases de datos sean disponibilizadas con archivos auxiliares. Estos pueden incluir notas t\u00e9cnicas, descripciones de recolecci\u00f3n y muestreo, etc. Para ayudar a los usuarios de Base de los Datos a tener m\u00e1s contexto y entender mejor los datos, organiza todos estos archivos auxiliares en /extra/auxiliary_files . Si\u00e9ntete libre de estructurar sub-carpetas como quieras all\u00ed dentro. Lo que importa es que quede claro qu\u00e9 son estos archivos.","title":"5. (Si es necesario) Organizar archivos auxiliares"},{"location":"es/colab_data/#6-si-es-necesario-crear-tabla-diccionario","text":"Muchas veces, especialmente con bases antiguas, hay m\u00faltiples diccionarios en formatos Excel u otros. En Base de los Datos unificamos todo en un \u00fanico archivo en formato .csv - un \u00fanico diccionario para todas las columnas de todas las tablas de tu conjunto. Detalles importantes de c\u00f3mo construir tu diccionario est\u00e1n en nuestro manual de estilo .","title":"6. (Si es necesario) Crear tabla diccionario"},{"location":"es/colab_data/#ejemplo-rais-diccionario","text":"El diccionario completo puede ser consultado aqu\u00ed . Ya posee la estructura est\u00e1ndar que utilizamos para diccionarios.","title":"Ejemplo: RAIS - Diccionario"},{"location":"es/colab_data/#7-subir-todo-a-google-cloud","text":"\u00a1Todo listo! Ahora solo falta subir a Google Cloud y enviar para revisi\u00f3n. Para esto, vamos a usar el cliente basedosdados (disponible en Python) que facilita las configuraciones y etapas del proceso. Como existe un costo para el almacenamiento en storage, para finalizar esta etapa necesitaremos proporcionarte una api_key espec\u00edfica para voluntarios para subir los datos en nuestro ambiente de desarrollo. As\u00ed que \u00fanete a nuestro canal en Discord y ll\u00e1manos en 'quiero-contribuir'","title":"7. Subir todo a Google Cloud"},{"location":"es/colab_data/#configura-tus-credenciales-localmente","text":"7.1 En tu terminal instala nuestro cliente: pip install basedosdados . 7.2 Ejecuta import basedosdados as bd en python y sigue el paso a paso para configurar localmente con las credenciales de tu proyecto en Google Cloud. Completa la informaci\u00f3n como sigue: * STEP 1: y * STEP 2: basedosdados-dev (colocar el .json pasado por el equipo de bd en la carpeta credentials) * STEP 3: y * STEP 4: basedosdados-dev * STEP 5: https://api.basedosdados.org/api/v1/graphql","title":"Configura tus credenciales localmente"},{"location":"es/colab_data/#sube-los-archivos-a-la-cloud","text":"Los datos pasar\u00e1n por 3 lugares en Google Cloud: Storage : tambi\u00e9n llamado GCS es el lugar donde ser\u00e1n almacenados los archivos \"fr\u00edos\" (arquitecturas, datos, archivos auxiliares). BigQuery-DEV-Staging : tabla que conecta los datos del storage al proyecto basedosdados-dev en bigquery BigQuery-DEV-Producci\u00f3n : tabla utilizada para pruebas y tratamiento v\u00eda SQL del conjunto de datos 7.3 Crea la tabla en el bucket del GCS y BigQuey-DEV-staging , usando la API de Python, de la siguiente forma: ```python import basedosdados as bd tb = bd.Table( dataset_id='<dataset_id>', table_id='<table_id>') tb.create( path='<ruta_para_los_datos>', if_table_exists='raise', if_storage_data_exists='raise', ) ``` Los siguientes par\u00e1metros pueden ser usados: - `path` (obligatorio): la ruta completa del archivo en tu computadora, como: `/Users/<tu_usuario>/proyectos/basedosdados/mais/bases/[DATASET_ID]/output/microdados.csv`. !!! Tip \"Si tus datos est\u00e1n particionados, la ruta debe apuntar a la carpeta donde est\u00e1n las particiones. En caso contrario, debe apuntar a un archivo `.csv` (por ejemplo, microdados.csv).\" - `force_dataset`: comando que crea los archivos de configuraci\u00f3n del dataset en BigQuery. - _True_: los archivos de configuraci\u00f3n del dataset ser\u00e1n creados en tu proyecto y, si no existe en BigQuery, ser\u00e1 creado autom\u00e1ticamente. **Si ya has creado y configurado el dataset, no uses esta opci\u00f3n, pues sobrescribir\u00e1 archivos**. - _False_: el dataset no ser\u00e1 recreado y, si no existe, ser\u00e1 creado autom\u00e1ticamente. - `if_table_exists` : comando utilizado si la **tabla ya existe en BQ**: - _raise_: retorna mensaje de error. - _replace_: sustituye la tabla. - _pass_: no hace nada. - `if_storage_data_exists`: comando utilizado si los **datos ya existen en Google Cloud Storage**: - _raise_: retorna mensaje de error - _replace_: sustituye los datos existentes. - _pass_: no hace nada. !!! Info \"Si el proyecto no existe en BigQuery, ser\u00e1 autom\u00e1ticamente creado\" Consulta tambi\u00e9n nuestra API para m\u00e1s detalles de cada m\u00e9todo. 7.4 Crea los archivos .sql y schema.yml a partir de la tabla de arquitectura siguiendo esta documentaci\u00f3n Si lo necesitas, en este momento puedes alterar la consulta en SQL para realizar tratamientos finales a partir de la tabla staging , puedes incluir columna, remover columna, hacer operaciones algebraicas, sustituir strings, etc. \u00a1El SQL es el l\u00edmite! 7.5 Ejecuta y prueba los modelos localmente siguiendo esta documentaci\u00f3n 7.6 Sube los metadatos de la tabla en el sitio: Por ahora solo el equipo de datos tiene permisos para subir los metadatos de la tabla en el sitio, por eso ser\u00e1 necesario contactar con nosotros. Ya estamos trabajando para que, en un futuro pr\u00f3ximo, los voluntarios tambi\u00e9n puedan actualizar datos en el sitio. 7.7 Sube los archivos auxiliares: st = bd . Storage ( dataset_id = < dataset_id > , table_id = < table_id > ) st . upload ( path = 'ruta_para_los_archivos_auxiliares' , mode = 'auxiliary_files' , if_exists = 'raise' )","title":"Sube los archivos a la Cloud"},{"location":"es/colab_data/#8-enviar-todo-para-revision","text":"\u00a1Uf, eso es todo! Ahora solo queda enviar todo para revisi\u00f3n en el repositorio de Base de los Datos. Clona nuestro repositorio localmente. Da un cd a la carpeta local del repositorio y abre una nueva branch con git checkout -b [dataset_id] . Todas las adiciones y modificaciones ser\u00e1n incluidas en esa branch . Para cada tabla nueva incluir el archivo con nombre table_id.sql en la carpeta queries-basedosdados/models/dataset_id/ copiando las queries que desarrollaste en el paso 7. Incluir el archivo schema.yaml desarrollado en el paso 7 Si es un dataset nuevo, incluir el dataset conforme las instrucciones del archivo queries-basedosdados/dbt_project.yaml (no te olvides de seguir el orden alfab\u00e9tico para no desordenar la organizaci\u00f3n) Incluye tu c\u00f3digo de captura y limpieza en la carpeta queries-basedosdados/models/dataset_id/code Ahora solo falta publicar la branch, abrir el PR con las labels 'table-approve' y marcar al equipo de datos para correcci\u00f3n \u00bfY ahora? Nuestro equipo revisar\u00e1 los datos y metadatos enviados v\u00eda Github. Podemos contactarte para resolver dudas o solicitar cambios en el c\u00f3digo. Cuando todo est\u00e9 OK, hacemos un merge de tu pull request y los datos son autom\u00e1ticamente publicados en nuestra plataforma!","title":"8. Enviar todo para revisi\u00f3n"},{"location":"es/colab_infrastructure/","text":"Infraestructura de BD Nuestro equipo de infraestructura se asegura de que todos los paquetes y pipelines funcionen de la mejor manera para el p\u00fablico. Utilizamos Github para gestionar todo el c\u00f3digo y mantenerlo organizado, donde puedes encontrar issues de nuevas funcionalidades, errores y mejoras en las que estamos trabajando. C\u00f3mo funciona nuestra infraestructura Nuestra infraestructura se compone de 3 frentes principales: Sistema de ingesti\u00f3n de datos : desde la carga hasta la disponibilizaci\u00f3n en producci\u00f3n; Paquetes de acceso Sitio web : Front-end, Back-end y APIs. Actualmente es posible colaborar en todos los frentes, con \u00e9nfasis en el desarrollo de los pesos y contrapesos y la actualizaci\u00f3n del sitio. \u00a1Sugerimos que te unas a nuestro canal de Discord para resolver dudas e interactuar con otros(as) colaboradores(as)! :) Sistema de ingesti\u00f3n de datos El sistema tiene ambientes de desarrollo ( basedosdados-dev ), homologaci\u00f3n ( basedosdados-staging ) y producci\u00f3n ( basedosdados ) en BigQuery. Los procesos para la subida de datos est\u00e1n detallados en la imagen de abajo, siendo algunos de ellos automatizados v\u00eda Github Actions. Explicamos con m\u00e1s detalles el funcionamiento de este sistema en el blog . \u00bfC\u00f3mo contribuir? Mejorando la documentaci\u00f3n del sistema aqu\u00ed :) Creando verificaciones autom\u00e1ticas de calidad de datos y metadatos (en Python) Creando nuevos issues y sugerencias de mejoras Paquetes de acceso Los paquetes de acceso al datalake est\u00e1n en constante mejora y puedes colaborar con nosotros con nuevas funcionalidades, correcci\u00f3n de errores y mucho m\u00e1s. \u00bfC\u00f3mo contribuir? Explora los issues del paquete Python Explora los issues del paquete R Ayuda a desarrollar el paquete en Stata Sitio web Nuestro sitio web est\u00e1 desarrollado en Next.js y consume una API de metadatos de CKAN. El c\u00f3digo del sitio tambi\u00e9n est\u00e1 en nuestro Github . \u00bfC\u00f3mo contribuir? Mejora el UX del sitio (Next, CSS, HTML) Ayudando en issues abiertos de BE, FE o API Creando nuevos issues y sugerencias de mejoras","title":"Infraestructura"},{"location":"es/colab_infrastructure/#infraestructura-de-bd","text":"Nuestro equipo de infraestructura se asegura de que todos los paquetes y pipelines funcionen de la mejor manera para el p\u00fablico. Utilizamos Github para gestionar todo el c\u00f3digo y mantenerlo organizado, donde puedes encontrar issues de nuevas funcionalidades, errores y mejoras en las que estamos trabajando.","title":"Infraestructura de BD"},{"location":"es/colab_infrastructure/#como-funciona-nuestra-infraestructura","text":"Nuestra infraestructura se compone de 3 frentes principales: Sistema de ingesti\u00f3n de datos : desde la carga hasta la disponibilizaci\u00f3n en producci\u00f3n; Paquetes de acceso Sitio web : Front-end, Back-end y APIs. Actualmente es posible colaborar en todos los frentes, con \u00e9nfasis en el desarrollo de los pesos y contrapesos y la actualizaci\u00f3n del sitio. \u00a1Sugerimos que te unas a nuestro canal de Discord para resolver dudas e interactuar con otros(as) colaboradores(as)! :)","title":"C\u00f3mo funciona nuestra infraestructura"},{"location":"es/colab_infrastructure/#sistema-de-ingestion-de-datos","text":"El sistema tiene ambientes de desarrollo ( basedosdados-dev ), homologaci\u00f3n ( basedosdados-staging ) y producci\u00f3n ( basedosdados ) en BigQuery. Los procesos para la subida de datos est\u00e1n detallados en la imagen de abajo, siendo algunos de ellos automatizados v\u00eda Github Actions. Explicamos con m\u00e1s detalles el funcionamiento de este sistema en el blog .","title":"Sistema de ingesti\u00f3n de datos"},{"location":"es/colab_infrastructure/#como-contribuir","text":"Mejorando la documentaci\u00f3n del sistema aqu\u00ed :) Creando verificaciones autom\u00e1ticas de calidad de datos y metadatos (en Python) Creando nuevos issues y sugerencias de mejoras","title":"\u00bfC\u00f3mo contribuir?"},{"location":"es/colab_infrastructure/#paquetes-de-acceso","text":"Los paquetes de acceso al datalake est\u00e1n en constante mejora y puedes colaborar con nosotros con nuevas funcionalidades, correcci\u00f3n de errores y mucho m\u00e1s.","title":"Paquetes de acceso"},{"location":"es/colab_infrastructure/#como-contribuir_1","text":"Explora los issues del paquete Python Explora los issues del paquete R Ayuda a desarrollar el paquete en Stata","title":"\u00bfC\u00f3mo contribuir?"},{"location":"es/colab_infrastructure/#sitio-web","text":"Nuestro sitio web est\u00e1 desarrollado en Next.js y consume una API de metadatos de CKAN. El c\u00f3digo del sitio tambi\u00e9n est\u00e1 en nuestro Github .","title":"Sitio web"},{"location":"es/colab_infrastructure/#como-contribuir_2","text":"Mejora el UX del sitio (Next, CSS, HTML) Ayudando en issues abiertos de BE, FE o API Creando nuevos issues y sugerencias de mejoras","title":"\u00bfC\u00f3mo contribuir?"},{"location":"es/style_data/","text":"Manual de estilo En esta secci\u00f3n listamos todos los est\u00e1ndares de nuestro manual de estilo y directrices de datos que usamos en Base de los Datos. Estos nos ayudan a mantener los datos y metadatos que publicamos con alta calidad. Puedes usar el men\u00fa izquierdo para navegar por los diferentes temas de esta p\u00e1gina. Nomenclatura de bases y tablas Conjuntos de datos ( dataset_id ) Nombramos conjuntos en el formato <organization_id>_<descripci\u00f3n> , donde organization_id sigue por defecto la cobertura geogr\u00e1fica de la organizaci\u00f3n que publica el conjunto: organization_id Mundial mundo_<organizacion> Federal <sigla_pais>_<organizacion> Estatal <sigla_pais>_<sigla_estado>_<organizacion> Municipal <sigla_pais>_<sigla_estado>_<ciudad>_<organizacion> sigla_pais y sigla_estado son siempre 2 letras min\u00fasculas; organizacion es el nombre o sigla (preferentemente) de la organizaci\u00f3n que public\u00f3 los datos originales (ej: ibge , tse , inep ). descripcion es una breve descripci\u00f3n del conjunto de datos Por ejemplo, el conjunto de datos del PIB del IBGE tiene como dataset_id : br_ibge_pib \u00bfNo sabes c\u00f3mo nombrar la organizaci\u00f3n? Sugerimos que vayas al sitio web de la misma y veas c\u00f3mo se autodenomina (ej: DETRAN-RJ ser\u00eda br_rj_detran ) Tablas Nombrar tablas es algo menos estructurado y, por eso, requiere sentido com\u00fan. Pero tenemos algunas reglas: Si hay tablas para diferentes entidades, incluir la entidad al principio del nombre. Ejemplo: municipio_valor , uf_valor . No incluir la unidad temporal en el nombre. Ejemplo: nombrar municipio , y no municipio_ano . Dejar nombres en singular. Ejemplo: escuela , y no escuelas . Nombrar como microdatos las tablas m\u00e1s desagregadas. En general estas tienen datos a nivel de persona o transacci\u00f3n. Ejemplos de dataset_id.table_id Mundial mundo_waze.alertas Datos de alertas de Waze de diferentes ciudades. Federal br_tse_eleicoes.candidatos Datos de candidatos a cargos pol\u00edticos del TSE. Federal br_ibge_pnad.microdados Microdatos de la Encuesta Nacional por Muestra de Hogares producidos por el IBGE. Federal br_ibge_pnadc.microdados Microdatos de la Encuesta Nacional por Muestra de Hogares Continua (PNAD-C) producidos por el IBGE. Estatal br_sp_see_docentes.carga_horaria Carga horaria anonimizada de docentes activos de la red estatal de ense\u00f1anza de SP. Municipal br_rj_riodejaneiro_cmrj_legislativo.votaciones Datos de votaci\u00f3n de la C\u00e1mara Municipal de R\u00edo de Janeiro (RJ). Formatos de tablas Las tablas deben, en la medida de lo posible, estar en formato long , en lugar de wide . Nomenclatura de variables Los nombres de variables deben respetar algunas reglas: Usar al m\u00e1ximo nombres ya presentes en el repositorio. Ejemplos: ano , mes , id_municipio , sigla_uf , edad , cargo , resultado , votos , ingreso , gasto , precio , etc. Respetar patrones de las tablas de directorios. Ser lo m\u00e1s intuitivo, claro y extenso posible. Tener todas las letras min\u00fasculas (inclusive siglas), sin acentos, conectados por _ . No incluir conectores como de , la , los , y , en , etc. Solo tener el prefijo id_ cuando la variable represente claves primarias de entidades (que eventualmente tendr\u00edan una tabla de directorio). Ejemplos que tienen: id_municipio , id_uf , id_escuela , id_persona . Ejemplos que no tienen: red , localizacion . Importante : cuando la base est\u00e1 en ingl\u00e9s id se convierte en un sufijo Solo tener sufijos de entidad cuando la entidad de la columna sea diferente de la entidad de la tabla. Ejemplos que tienen: en una tabla con entidad persona , una columna sobre PIB municipal se llamar\u00eda pib_municipio . Ejemplos que no tienen: en una tabla con entidad persona , caracter\u00edsticas de la persona se llamar\u00edan nombre , edad , sexo , etc. Lista de prefijos permitidos nombre_ , fecha_ , numero_ , cantidad_ , proporcion_ (variables de porcentaje 0-100%), tasa_ , razon_ , indice_ , indicador_ (variables de tipo booleano), tipo_ , sigla_ , secuencial_ . Lista de sufijos comunes _pc (per c\u00e1pita) Ordenamiento de variables El orden de variables en tablas est\u00e1 estandarizado para mantener una consistencia en el repositorio. Nuestras reglas son: Claves primarias a la izquierda, en orden descendente de cobertura; En el medio deben estar variables cualitativas de la l\u00ednea; Las \u00faltimas variables deben ser los valores cuantitativos en orden creciente de relevancia; Ejemplo de orden: ano , sigla_uf , id_municipio , id_escuela , red , nota_ideb ; Dependiendo de la tabla, puede ser recomendado agrupar y ordenar variables por temas. Tipos de variables Utilizamos algunas de las opciones de tipos de BigQuery : string , int64 , float64 , date , time , geography . Cu\u00e1ndo elegir: string : Variables de texto Claves de variables categ\u00f3ricas con diccionario o directorio int64 : Variables de n\u00fameros enteros con las que es posible hacer c\u00e1lculos (adici\u00f3n, sustracci\u00f3n) Variables de tipo booleanas que llenamos con 0 o 1 float64 : Variables de n\u00fameros con decimales con las que es posible hacer c\u00e1lculos (adici\u00f3n, sustracci\u00f3n) date : Variables de fecha en formato YYYY-MM-DD time : Variables de tiempo en formato HH:MM:SS geography : Variables de geograf\u00eda Unidades de medida La regla es mantener variables con sus unidades de medida originales listadas en este c\u00f3digo , con la excepci\u00f3n de variables financieras donde convertimos monedas antiguas a las actuales (ej. Cruzeiro a Real). Catalogamos unidades de medida en formato est\u00e1ndar en la tabla de arquitectura. Lista completa aqu\u00ed Ejemplos: m , km/h , BRL . Para columnas financieras deflactadas, listamos la moneda con el a\u00f1o base. Ejemplo: una columna medida en reales de 2010 tiene unidad BRL_2010 . Las variables deben tener siempre unidades de medida con base 1. Es decir, tener BRL en lugar de 1000 BRL , o persona en lugar de 1000 personas . Esta informaci\u00f3n, como otros metadatos de columnas, se registra en la tabla de arquitectura de la tabla. Qu\u00e9 variables mantener, cu\u00e1les a\u00f1adir y cu\u00e1les eliminar Mantenemos nuestras tablas parcialmente normalizadas , y tenemos reglas para qu\u00e9 variables incluir en producci\u00f3n. Estas son: Eliminar variables de nombres de entidades que ya est\u00e1n en directorios. Ejemplo: retirar municipio de la tabla que ya incluye id_municipio . Eliminar variables que sirven de partici\u00f3n. Ejemplo: eliminar ano y sigla_uf si la tabla est\u00e1 particionada en estas dos dimensiones. A\u00f1adir claves primarias principales para cada entidad ya existente. Ejemplo: a\u00f1adir id_municipio a tablas que solo incluyen id_municipio_tse . Mantener todas las claves primarias que ya vienen con la tabla, pero (1) a\u00f1adir claves relevantes (ej. sigla_uf , id_municipio ) y (2) retirar claves irrelevantes (ej. region ). Cobertura temporal Llenar la columna cobertura_temporal en los metadatos de tabla, columna y clave (en diccionarios) sigue el siguiente patr\u00f3n. Formato general: fecha_inicial(unidad_temporal)fecha_final fecha_inicial y fecha_final est\u00e1n en la correspondiente unidad temporal. Ejemplo: tabla con unidad ano tiene cobertura 2005(1)2018 . Ejemplo: tabla con unidad mes tiene cobertura 2005-08(1)2018-12 . Ejemplo: tabla con unidad semana tiene cobertura 2005-08-01(7)2018-08-31 . Ejemplo: tabla con unidad dia tiene cobertura 2005-08-01(1)2018-12-31 . Reglas para llenado Metadatos de tabla Llenar en el formato general. Metadatos de columna Llenar en el formato general, excepto cuando la fecha_inicial o fecha_final sean iguales a las de la tabla. En ese caso dejar vac\u00edo. Ejemplo: suponga que la cobertura de la tabla sea 2005(1)2018 . Si una columna aparece solo en 2012 y existe hasta 2018, llenamos su cobertura como 2012(1) . Si una columna desaparece en 2013, llenamos su cobertura como (1)2013 . Si una columna existe en la misma cobertura temporal que la tabla, llenamos su cobertura como (1) . Metadatos de clave Llenar en el mismo patr\u00f3n de columnas, pero la referencia siendo la columna correspondiente, y no la tabla. Limpiando STRINGs Variables categ\u00f3ricas: inicial may\u00fascula y resto min\u00fascula, con acentos. STRINGs no estructuradas: mantener igual a los datos originales. Formatos de valores Decimal: formato americano, es decir siempre . (punto) en lugar de , (coma). Fecha: YYYY-MM-DD Horario (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Valor nulo: \"\" (csv), NULL (Python), NA (R), . o \"\" (Stata) Proporci\u00f3n/porcentaje: entre 0-100 Particionamiento de tablas \u00bfQu\u00e9 es el particionamiento y cu\u00e1l es su objetivo? De forma resumida, particionar una tabla es dividirla en varios bloques/partes. El objetivo central es disminuir los costos financieros y aumentar el rendimiento, ya que, cuanto mayor sea el volumen de datos, consecuentemente ser\u00e1 mayor el costo de almacenamiento y consulta. La reducci\u00f3n de costos y el aumento de rendimiento ocurre, principalmente, porque la partici\u00f3n permite la reorganizaci\u00f3n del conjunto de datos en peque\u00f1os bloques agrupados . En la pr\u00e1ctica, realizando el particionamiento, es posible evitar que una consulta recorra toda la tabla solo para traer un peque\u00f1o recorte de datos. Un ejemplo pr\u00e1ctico de nuestra querida RAIS: Sin utilizar filtro de partici\u00f3n: Para este caso, BigQuery recorri\u00f3 todas (*) las columnas y filas del conjunto. Vale se\u00f1alar que este costo a\u00fan no es tan grande, ya que la base ya fue particionada. Si este conjunto no hubiera pasado por el proceso de particionamiento, esta consulta costar\u00eda mucho m\u00e1s dinero y tiempo, ya que se trata de un volumen considerable de datos. Con filtro de partici\u00f3n: Aqu\u00ed, filtramos por las columnas particionadas ano y sigla_uf . De esta forma, BigQuery solo consulta y retorna los valores de la carpeta ano y la subcarpeta sigla_uf . \u00bfCu\u00e1ndo particionar una tabla? La primera pregunta que surge cuando se trata de particionamiento es: \u00bfa partir de qu\u00e9 cantidad de filas una tabla debe ser particionada? La documentaci\u00f3n de GCP no define una cantidad x o y de filas que debe ser particionada. Lo ideal es que las tablas sean particionadas, con pocas excepciones. Por ejemplo, tablas con menos de 10.000 filas, que no recibir\u00e1n m\u00e1s ingesti\u00f3n de datos, no tienen un costo de almacenamiento y procesamiento altos y, por lo tanto, no hay necesidad de ser particionadas. \u00bfC\u00f3mo particionar una tabla? Si los datos est\u00e1n guardados localmente, es necesario: Crear las carpetas particionadas en tu carpeta de /output , en el lenguaje que est\u00e9s utilizando. Ejemplo de una tabla particionada por ano y mes , utilizando python : for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: particion = output + f 'table_id/ano= { ano } /mes= { mes } ' if not os . path . exists ( particion ): os . makedirs ( particion ) 2. Guardar los archivos particionados. for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: df_particion = df [ df [ 'ano' ] == ano ] . copy () # El .copy no es necesario, es solo una buena pr\u00e1ctica df_particion = df_particion [ df_particion [ 'mes' ] == mes ] df_particion . drop ([ 'ano' , 'mes' ], axis = 1 , inplace = True ) # Es necesario excluir las columnas utilizadas para partici\u00f3n particion = output + f 'table_id/ano= { ano } /mes= { mes } /tabla.csv' df_particion . to_csv ( particion , index = False , encoding = 'utf-8' , na_rep = '' ) Ejemplos de tablas particionadas en R : PNADC PAM Ejemplo de c\u00f3mo particionar una tabla en SQL : CREATE TABLE ` dataset_id . table_id ` as ( ano INT64 , mes INT64 , col1 STRING , col1 STRING ) PARTITION BY ano , mes OPTIONS ( Description = 'Descripci\u00f3n de la tabla' ) Reglas importantes de particionamiento Los tipos de columnas que BigQuery acepta como partici\u00f3n son: Columna de unidad de tiempo : las tablas son particionadas con base en una columna de TIMESTAMP , DATE o DATETIME . Tiempo de procesamiento : las tablas son particionadas con base en el sello de fecha/hora cuando BigQuery procesa los datos. Intervalo de n\u00fameros enteros : las tablas son particionadas con base en una columna de n\u00fameros enteros. Los tipos de columnas que BigQuery no acepta como partici\u00f3n son: BOOL , FLOAT64 , BYTES , etc. BigQuery acepta como m\u00e1ximo 4.000 particiones por tabla. Aqu\u00ed en BD las tablas generalmente son particionadas por: ano , mes , trimestre y sigla_uf . Note que al particionar una tabla es necesario excluir la columna correspondiente. Ejemplo: es necesario excluir la columna ano al particionar por ano . N\u00famero de bases por pull request Los pull requests en Github deben incluir como m\u00e1ximo un conjunto, pero pueden incluir m\u00e1s de una base. Es decir, pueden involucrar una o m\u00e1s tablas dentro del mismo conjunto. Diccionarios Cada base incluye solamente un diccionario (que cubre una o m\u00e1s tablas). Para cada tabla, columna, y cobertura temporal, cada clave mapea \u00fanicamente un valor. Las claves no pueden tener valores nulos. Los diccionarios deben cubrir todas las claves disponibles en las tablas originales. Las claves solo pueden poseer ceros a la izquierda cuando el n\u00famero de d\u00edgitos de la variable tenga significado. Cuando la variable sea enum est\u00e1ndar, excluimos los ceros a la izquierda. Ejemplo: mantenemos el cero a la izquierda de la variable br_bd_diretorios_brasil.cbo_2002:cbo_2002 , que tiene seis d\u00edgitos, pues el primer d\u00edgito 0 significa que la categor\u00eda es del gran grupo = \"Miembros de las fuerzas armadas, polic\u00edas y bomberos militares\" . Para otros casos, como por ejemplo br_inep_censo_escolar.turma:etapa_ensino , excluimos los ceros a la izquierda. Es decir, cambiamos 01 por 1 . Los valores son estandarizados: sin espacios extras, inicial may\u00fascula y resto min\u00fascula, etc. \u00bfC\u00f3mo llenar los metadatos de la tabla diccionario? No llenar el spatial_coverage ( cobertura_espacial ), es decir, dejar el campo vac\u00edo. No llenar el temporal_coverage ( cobertura_temporal ), es decir, dejar el campo vac\u00edo. No llenar el observation_level ( nivel_observacion ), es decir, dejar el campo vac\u00edo. Directorios Los directorios son las piedras fundamentales de la estructura de nuestro data lake . Nuestras reglas para gestionar directorios son: Los directorios representan entidades del repositorio que tengan claves primarias (ej. uf , municipio , escuela ) y unidades de fecha-tiempo (ej. fecha , tiempo , dia , mes , ano ). Cada tabla de directorio tiene al menos una clave primaria con valores \u00fanicos y sin nulos. Ejemplos: municipio:id_municipio , uf:sigla_uf . Los nombres de variables con prefijo id_ est\u00e1n reservados para claves primarias de entidades. Vea todas las tablas ya disponibles aqu\u00ed. \u00bfC\u00f3mo llenar los metadatos de las tablas de directorio? Llenar el spatial_coverage ( cobertura_espacial ), que es la m\u00e1xima unidad espacial que la tabla cubre. Ejemplo: sa.br, que significa que el nivel de agregaci\u00f3n espacial de la tabla es Brasil. No llenar el temporal_coverage ( cobertura_temporal ), es decir, dejar el campo vac\u00edo. Llenar el observation_level ( nivel_observacion ), que consiste en el nivel de observaci\u00f3n de la tabla, es decir, lo que representa cada fila. No llenar el temporal_coverage ( cobertura_temporal ) de las columnas de la tabla, es decir, dejar el campo vac\u00edo. Fuentes Originales El campo se refiere a los datos en la fuente original, que a\u00fan no han pasado por la metodolog\u00eda de tratamiento de Base de los Datos, es decir, nuestro _input_ . Al hacer clic en \u00e9l, la idea es redirigir al usuario a la p\u00e1gina de la fuente original de los datos. Las reglas para gestionar las Fuentes Originales son: Incluir el nombre del enlace externo que lleva a la fuente original. Como est\u00e1ndar, este nombre debe ser de la organizaci\u00f3n o del portal que almacena los datos. Ejemplos: Sinopsis Estad\u00edsticas de la Educaci\u00f3n B\u00e1sica: Datos Abiertos del Inep , Penn World Tables: Groningen Growth and Development Centre . Llenar los metadatos de Fuentes Originales: Descripci\u00f3n, URL, Idioma, Tiene Datos Estructurados, Tiene una API, Es Gratuito, Requiere Registro, Disponibilidad, Requiere IP de Alg\u00fan Pa\u00eds, Tipo de Licencia, Cobertura Temporal, Cobertura Espacial y Nivel de Observaci\u00f3n. \u00bfPensaste en mejoras para los est\u00e1ndares definidos? Abre un issue en nuestro Github o env\u00eda un mensaje en Discord para conversar :)","title":"Manual de estilo"},{"location":"es/style_data/#manual-de-estilo","text":"En esta secci\u00f3n listamos todos los est\u00e1ndares de nuestro manual de estilo y directrices de datos que usamos en Base de los Datos. Estos nos ayudan a mantener los datos y metadatos que publicamos con alta calidad. Puedes usar el men\u00fa izquierdo para navegar por los diferentes temas de esta p\u00e1gina.","title":"Manual de estilo"},{"location":"es/style_data/#nomenclatura-de-bases-y-tablas","text":"","title":"Nomenclatura de bases y tablas"},{"location":"es/style_data/#conjuntos-de-datos-dataset_id","text":"Nombramos conjuntos en el formato <organization_id>_<descripci\u00f3n> , donde organization_id sigue por defecto la cobertura geogr\u00e1fica de la organizaci\u00f3n que publica el conjunto: organization_id Mundial mundo_<organizacion> Federal <sigla_pais>_<organizacion> Estatal <sigla_pais>_<sigla_estado>_<organizacion> Municipal <sigla_pais>_<sigla_estado>_<ciudad>_<organizacion> sigla_pais y sigla_estado son siempre 2 letras min\u00fasculas; organizacion es el nombre o sigla (preferentemente) de la organizaci\u00f3n que public\u00f3 los datos originales (ej: ibge , tse , inep ). descripcion es una breve descripci\u00f3n del conjunto de datos Por ejemplo, el conjunto de datos del PIB del IBGE tiene como dataset_id : br_ibge_pib \u00bfNo sabes c\u00f3mo nombrar la organizaci\u00f3n? Sugerimos que vayas al sitio web de la misma y veas c\u00f3mo se autodenomina (ej: DETRAN-RJ ser\u00eda br_rj_detran )","title":"Conjuntos de datos (dataset_id)"},{"location":"es/style_data/#tablas","text":"Nombrar tablas es algo menos estructurado y, por eso, requiere sentido com\u00fan. Pero tenemos algunas reglas: Si hay tablas para diferentes entidades, incluir la entidad al principio del nombre. Ejemplo: municipio_valor , uf_valor . No incluir la unidad temporal en el nombre. Ejemplo: nombrar municipio , y no municipio_ano . Dejar nombres en singular. Ejemplo: escuela , y no escuelas . Nombrar como microdatos las tablas m\u00e1s desagregadas. En general estas tienen datos a nivel de persona o transacci\u00f3n.","title":"Tablas"},{"location":"es/style_data/#ejemplos-de-dataset_idtable_id","text":"Mundial mundo_waze.alertas Datos de alertas de Waze de diferentes ciudades. Federal br_tse_eleicoes.candidatos Datos de candidatos a cargos pol\u00edticos del TSE. Federal br_ibge_pnad.microdados Microdatos de la Encuesta Nacional por Muestra de Hogares producidos por el IBGE. Federal br_ibge_pnadc.microdados Microdatos de la Encuesta Nacional por Muestra de Hogares Continua (PNAD-C) producidos por el IBGE. Estatal br_sp_see_docentes.carga_horaria Carga horaria anonimizada de docentes activos de la red estatal de ense\u00f1anza de SP. Municipal br_rj_riodejaneiro_cmrj_legislativo.votaciones Datos de votaci\u00f3n de la C\u00e1mara Municipal de R\u00edo de Janeiro (RJ).","title":"Ejemplos de dataset_id.table_id"},{"location":"es/style_data/#formatos-de-tablas","text":"Las tablas deben, en la medida de lo posible, estar en formato long , en lugar de wide .","title":"Formatos de tablas"},{"location":"es/style_data/#nomenclatura-de-variables","text":"Los nombres de variables deben respetar algunas reglas: Usar al m\u00e1ximo nombres ya presentes en el repositorio. Ejemplos: ano , mes , id_municipio , sigla_uf , edad , cargo , resultado , votos , ingreso , gasto , precio , etc. Respetar patrones de las tablas de directorios. Ser lo m\u00e1s intuitivo, claro y extenso posible. Tener todas las letras min\u00fasculas (inclusive siglas), sin acentos, conectados por _ . No incluir conectores como de , la , los , y , en , etc. Solo tener el prefijo id_ cuando la variable represente claves primarias de entidades (que eventualmente tendr\u00edan una tabla de directorio). Ejemplos que tienen: id_municipio , id_uf , id_escuela , id_persona . Ejemplos que no tienen: red , localizacion . Importante : cuando la base est\u00e1 en ingl\u00e9s id se convierte en un sufijo Solo tener sufijos de entidad cuando la entidad de la columna sea diferente de la entidad de la tabla. Ejemplos que tienen: en una tabla con entidad persona , una columna sobre PIB municipal se llamar\u00eda pib_municipio . Ejemplos que no tienen: en una tabla con entidad persona , caracter\u00edsticas de la persona se llamar\u00edan nombre , edad , sexo , etc. Lista de prefijos permitidos nombre_ , fecha_ , numero_ , cantidad_ , proporcion_ (variables de porcentaje 0-100%), tasa_ , razon_ , indice_ , indicador_ (variables de tipo booleano), tipo_ , sigla_ , secuencial_ . Lista de sufijos comunes _pc (per c\u00e1pita)","title":"Nomenclatura de variables"},{"location":"es/style_data/#ordenamiento-de-variables","text":"El orden de variables en tablas est\u00e1 estandarizado para mantener una consistencia en el repositorio. Nuestras reglas son: Claves primarias a la izquierda, en orden descendente de cobertura; En el medio deben estar variables cualitativas de la l\u00ednea; Las \u00faltimas variables deben ser los valores cuantitativos en orden creciente de relevancia; Ejemplo de orden: ano , sigla_uf , id_municipio , id_escuela , red , nota_ideb ; Dependiendo de la tabla, puede ser recomendado agrupar y ordenar variables por temas.","title":"Ordenamiento de variables"},{"location":"es/style_data/#tipos-de-variables","text":"Utilizamos algunas de las opciones de tipos de BigQuery : string , int64 , float64 , date , time , geography . Cu\u00e1ndo elegir: string : Variables de texto Claves de variables categ\u00f3ricas con diccionario o directorio int64 : Variables de n\u00fameros enteros con las que es posible hacer c\u00e1lculos (adici\u00f3n, sustracci\u00f3n) Variables de tipo booleanas que llenamos con 0 o 1 float64 : Variables de n\u00fameros con decimales con las que es posible hacer c\u00e1lculos (adici\u00f3n, sustracci\u00f3n) date : Variables de fecha en formato YYYY-MM-DD time : Variables de tiempo en formato HH:MM:SS geography : Variables de geograf\u00eda","title":"Tipos de variables"},{"location":"es/style_data/#unidades-de-medida","text":"La regla es mantener variables con sus unidades de medida originales listadas en este c\u00f3digo , con la excepci\u00f3n de variables financieras donde convertimos monedas antiguas a las actuales (ej. Cruzeiro a Real). Catalogamos unidades de medida en formato est\u00e1ndar en la tabla de arquitectura. Lista completa aqu\u00ed Ejemplos: m , km/h , BRL . Para columnas financieras deflactadas, listamos la moneda con el a\u00f1o base. Ejemplo: una columna medida en reales de 2010 tiene unidad BRL_2010 . Las variables deben tener siempre unidades de medida con base 1. Es decir, tener BRL en lugar de 1000 BRL , o persona en lugar de 1000 personas . Esta informaci\u00f3n, como otros metadatos de columnas, se registra en la tabla de arquitectura de la tabla.","title":"Unidades de medida"},{"location":"es/style_data/#que-variables-mantener-cuales-anadir-y-cuales-eliminar","text":"Mantenemos nuestras tablas parcialmente normalizadas , y tenemos reglas para qu\u00e9 variables incluir en producci\u00f3n. Estas son: Eliminar variables de nombres de entidades que ya est\u00e1n en directorios. Ejemplo: retirar municipio de la tabla que ya incluye id_municipio . Eliminar variables que sirven de partici\u00f3n. Ejemplo: eliminar ano y sigla_uf si la tabla est\u00e1 particionada en estas dos dimensiones. A\u00f1adir claves primarias principales para cada entidad ya existente. Ejemplo: a\u00f1adir id_municipio a tablas que solo incluyen id_municipio_tse . Mantener todas las claves primarias que ya vienen con la tabla, pero (1) a\u00f1adir claves relevantes (ej. sigla_uf , id_municipio ) y (2) retirar claves irrelevantes (ej. region ).","title":"Qu\u00e9 variables mantener, cu\u00e1les a\u00f1adir y cu\u00e1les eliminar"},{"location":"es/style_data/#cobertura-temporal","text":"Llenar la columna cobertura_temporal en los metadatos de tabla, columna y clave (en diccionarios) sigue el siguiente patr\u00f3n. Formato general: fecha_inicial(unidad_temporal)fecha_final fecha_inicial y fecha_final est\u00e1n en la correspondiente unidad temporal. Ejemplo: tabla con unidad ano tiene cobertura 2005(1)2018 . Ejemplo: tabla con unidad mes tiene cobertura 2005-08(1)2018-12 . Ejemplo: tabla con unidad semana tiene cobertura 2005-08-01(7)2018-08-31 . Ejemplo: tabla con unidad dia tiene cobertura 2005-08-01(1)2018-12-31 . Reglas para llenado Metadatos de tabla Llenar en el formato general. Metadatos de columna Llenar en el formato general, excepto cuando la fecha_inicial o fecha_final sean iguales a las de la tabla. En ese caso dejar vac\u00edo. Ejemplo: suponga que la cobertura de la tabla sea 2005(1)2018 . Si una columna aparece solo en 2012 y existe hasta 2018, llenamos su cobertura como 2012(1) . Si una columna desaparece en 2013, llenamos su cobertura como (1)2013 . Si una columna existe en la misma cobertura temporal que la tabla, llenamos su cobertura como (1) . Metadatos de clave Llenar en el mismo patr\u00f3n de columnas, pero la referencia siendo la columna correspondiente, y no la tabla.","title":"Cobertura temporal"},{"location":"es/style_data/#limpiando-strings","text":"Variables categ\u00f3ricas: inicial may\u00fascula y resto min\u00fascula, con acentos. STRINGs no estructuradas: mantener igual a los datos originales.","title":"Limpiando STRINGs"},{"location":"es/style_data/#formatos-de-valores","text":"Decimal: formato americano, es decir siempre . (punto) en lugar de , (coma). Fecha: YYYY-MM-DD Horario (24h): HH:MM:SS Datetime ( ISO-8601 ): YYYY-MM-DDTHH:MM:SS.sssZ Valor nulo: \"\" (csv), NULL (Python), NA (R), . o \"\" (Stata) Proporci\u00f3n/porcentaje: entre 0-100","title":"Formatos de valores"},{"location":"es/style_data/#particionamiento-de-tablas","text":"","title":"Particionamiento de tablas"},{"location":"es/style_data/#que-es-el-particionamiento-y-cual-es-su-objetivo","text":"De forma resumida, particionar una tabla es dividirla en varios bloques/partes. El objetivo central es disminuir los costos financieros y aumentar el rendimiento, ya que, cuanto mayor sea el volumen de datos, consecuentemente ser\u00e1 mayor el costo de almacenamiento y consulta. La reducci\u00f3n de costos y el aumento de rendimiento ocurre, principalmente, porque la partici\u00f3n permite la reorganizaci\u00f3n del conjunto de datos en peque\u00f1os bloques agrupados . En la pr\u00e1ctica, realizando el particionamiento, es posible evitar que una consulta recorra toda la tabla solo para traer un peque\u00f1o recorte de datos. Un ejemplo pr\u00e1ctico de nuestra querida RAIS: Sin utilizar filtro de partici\u00f3n: Para este caso, BigQuery recorri\u00f3 todas (*) las columnas y filas del conjunto. Vale se\u00f1alar que este costo a\u00fan no es tan grande, ya que la base ya fue particionada. Si este conjunto no hubiera pasado por el proceso de particionamiento, esta consulta costar\u00eda mucho m\u00e1s dinero y tiempo, ya que se trata de un volumen considerable de datos. Con filtro de partici\u00f3n: Aqu\u00ed, filtramos por las columnas particionadas ano y sigla_uf . De esta forma, BigQuery solo consulta y retorna los valores de la carpeta ano y la subcarpeta sigla_uf .","title":"\u00bfQu\u00e9 es el particionamiento y cu\u00e1l es su objetivo?"},{"location":"es/style_data/#cuando-particionar-una-tabla","text":"La primera pregunta que surge cuando se trata de particionamiento es: \u00bfa partir de qu\u00e9 cantidad de filas una tabla debe ser particionada? La documentaci\u00f3n de GCP no define una cantidad x o y de filas que debe ser particionada. Lo ideal es que las tablas sean particionadas, con pocas excepciones. Por ejemplo, tablas con menos de 10.000 filas, que no recibir\u00e1n m\u00e1s ingesti\u00f3n de datos, no tienen un costo de almacenamiento y procesamiento altos y, por lo tanto, no hay necesidad de ser particionadas.","title":"\u00bfCu\u00e1ndo particionar una tabla?"},{"location":"es/style_data/#como-particionar-una-tabla","text":"Si los datos est\u00e1n guardados localmente, es necesario: Crear las carpetas particionadas en tu carpeta de /output , en el lenguaje que est\u00e9s utilizando. Ejemplo de una tabla particionada por ano y mes , utilizando python : for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: particion = output + f 'table_id/ano= { ano } /mes= { mes } ' if not os . path . exists ( particion ): os . makedirs ( particion ) 2. Guardar los archivos particionados. for ano in [ * range ( 2005 , 2020 )]: for mes in [ * range ( 1 , 13 )]: df_particion = df [ df [ 'ano' ] == ano ] . copy () # El .copy no es necesario, es solo una buena pr\u00e1ctica df_particion = df_particion [ df_particion [ 'mes' ] == mes ] df_particion . drop ([ 'ano' , 'mes' ], axis = 1 , inplace = True ) # Es necesario excluir las columnas utilizadas para partici\u00f3n particion = output + f 'table_id/ano= { ano } /mes= { mes } /tabla.csv' df_particion . to_csv ( particion , index = False , encoding = 'utf-8' , na_rep = '' ) Ejemplos de tablas particionadas en R : PNADC PAM Ejemplo de c\u00f3mo particionar una tabla en SQL : CREATE TABLE ` dataset_id . table_id ` as ( ano INT64 , mes INT64 , col1 STRING , col1 STRING ) PARTITION BY ano , mes OPTIONS ( Description = 'Descripci\u00f3n de la tabla' )","title":"\u00bfC\u00f3mo particionar una tabla?"},{"location":"es/style_data/#reglas-importantes-de-particionamiento","text":"Los tipos de columnas que BigQuery acepta como partici\u00f3n son: Columna de unidad de tiempo : las tablas son particionadas con base en una columna de TIMESTAMP , DATE o DATETIME . Tiempo de procesamiento : las tablas son particionadas con base en el sello de fecha/hora cuando BigQuery procesa los datos. Intervalo de n\u00fameros enteros : las tablas son particionadas con base en una columna de n\u00fameros enteros. Los tipos de columnas que BigQuery no acepta como partici\u00f3n son: BOOL , FLOAT64 , BYTES , etc. BigQuery acepta como m\u00e1ximo 4.000 particiones por tabla. Aqu\u00ed en BD las tablas generalmente son particionadas por: ano , mes , trimestre y sigla_uf . Note que al particionar una tabla es necesario excluir la columna correspondiente. Ejemplo: es necesario excluir la columna ano al particionar por ano .","title":"Reglas importantes de particionamiento"},{"location":"es/style_data/#numero-de-bases-por-pull-request","text":"Los pull requests en Github deben incluir como m\u00e1ximo un conjunto, pero pueden incluir m\u00e1s de una base. Es decir, pueden involucrar una o m\u00e1s tablas dentro del mismo conjunto.","title":"N\u00famero de bases por pull request"},{"location":"es/style_data/#diccionarios","text":"Cada base incluye solamente un diccionario (que cubre una o m\u00e1s tablas). Para cada tabla, columna, y cobertura temporal, cada clave mapea \u00fanicamente un valor. Las claves no pueden tener valores nulos. Los diccionarios deben cubrir todas las claves disponibles en las tablas originales. Las claves solo pueden poseer ceros a la izquierda cuando el n\u00famero de d\u00edgitos de la variable tenga significado. Cuando la variable sea enum est\u00e1ndar, excluimos los ceros a la izquierda. Ejemplo: mantenemos el cero a la izquierda de la variable br_bd_diretorios_brasil.cbo_2002:cbo_2002 , que tiene seis d\u00edgitos, pues el primer d\u00edgito 0 significa que la categor\u00eda es del gran grupo = \"Miembros de las fuerzas armadas, polic\u00edas y bomberos militares\" . Para otros casos, como por ejemplo br_inep_censo_escolar.turma:etapa_ensino , excluimos los ceros a la izquierda. Es decir, cambiamos 01 por 1 . Los valores son estandarizados: sin espacios extras, inicial may\u00fascula y resto min\u00fascula, etc.","title":"Diccionarios"},{"location":"es/style_data/#como-llenar-los-metadatos-de-la-tabla-diccionario","text":"No llenar el spatial_coverage ( cobertura_espacial ), es decir, dejar el campo vac\u00edo. No llenar el temporal_coverage ( cobertura_temporal ), es decir, dejar el campo vac\u00edo. No llenar el observation_level ( nivel_observacion ), es decir, dejar el campo vac\u00edo.","title":"\u00bfC\u00f3mo llenar los metadatos de la tabla diccionario?"},{"location":"es/style_data/#directorios","text":"Los directorios son las piedras fundamentales de la estructura de nuestro data lake . Nuestras reglas para gestionar directorios son: Los directorios representan entidades del repositorio que tengan claves primarias (ej. uf , municipio , escuela ) y unidades de fecha-tiempo (ej. fecha , tiempo , dia , mes , ano ). Cada tabla de directorio tiene al menos una clave primaria con valores \u00fanicos y sin nulos. Ejemplos: municipio:id_municipio , uf:sigla_uf . Los nombres de variables con prefijo id_ est\u00e1n reservados para claves primarias de entidades. Vea todas las tablas ya disponibles aqu\u00ed.","title":"Directorios"},{"location":"es/style_data/#como-llenar-los-metadatos-de-las-tablas-de-directorio","text":"Llenar el spatial_coverage ( cobertura_espacial ), que es la m\u00e1xima unidad espacial que la tabla cubre. Ejemplo: sa.br, que significa que el nivel de agregaci\u00f3n espacial de la tabla es Brasil. No llenar el temporal_coverage ( cobertura_temporal ), es decir, dejar el campo vac\u00edo. Llenar el observation_level ( nivel_observacion ), que consiste en el nivel de observaci\u00f3n de la tabla, es decir, lo que representa cada fila. No llenar el temporal_coverage ( cobertura_temporal ) de las columnas de la tabla, es decir, dejar el campo vac\u00edo.","title":"\u00bfC\u00f3mo llenar los metadatos de las tablas de directorio?"},{"location":"es/style_data/#fuentes-originales","text":"El campo se refiere a los datos en la fuente original, que a\u00fan no han pasado por la metodolog\u00eda de tratamiento de Base de los Datos, es decir, nuestro _input_ . Al hacer clic en \u00e9l, la idea es redirigir al usuario a la p\u00e1gina de la fuente original de los datos. Las reglas para gestionar las Fuentes Originales son: Incluir el nombre del enlace externo que lleva a la fuente original. Como est\u00e1ndar, este nombre debe ser de la organizaci\u00f3n o del portal que almacena los datos. Ejemplos: Sinopsis Estad\u00edsticas de la Educaci\u00f3n B\u00e1sica: Datos Abiertos del Inep , Penn World Tables: Groningen Growth and Development Centre . Llenar los metadatos de Fuentes Originales: Descripci\u00f3n, URL, Idioma, Tiene Datos Estructurados, Tiene una API, Es Gratuito, Requiere Registro, Disponibilidad, Requiere IP de Alg\u00fan Pa\u00eds, Tipo de Licencia, Cobertura Temporal, Cobertura Espacial y Nivel de Observaci\u00f3n.","title":"Fuentes Originales"},{"location":"es/style_data/#pensaste-en-mejoras-para-los-estandares-definidos","text":"Abre un issue en nuestro Github o env\u00eda un mensaje en Discord para conversar :)","title":"\u00bfPensaste en mejoras para los est\u00e1ndares definidos?"},{"location":"es/tutorial_join_tables/","text":"C\u00f3mo unir tablas en el datalake Organizamos los datos de manera que la uni\u00f3n de tablas de diferentes instituciones y temas sea tan simple como cualquier otra consulta. Para ello, definimos una metodolog\u00eda est\u00e1ndar para el tratamiento de datos, nomenclatura de columnas, tablas y conjuntos. \u00bfC\u00f3mo funciona la metodolog\u00eda BD? Alguna frase sobre .... Para saber m\u00e1s, lea la documentaci\u00f3n sobre tratamiento y arquitectura de datos. La informaci\u00f3n de diferentes tablas se puede agregar mediante claves identificadoras . Una clave identificadora es una columna cuyo nombre es \u00fanico en todas las tablas del data lake y se utiliza para identificar una entidad. Ejemplo de clave identificadora La columna ano tiene el mismo nombre en todas las tablas del data lake - siempre se refiere a la variable que tiene como valor cualquier a\u00f1o de nuestro calendario. Cuando trabajamos con datos de poblaci\u00f3n del IBGE, la columna ano , junto con la columna municipio , identifican de manera \u00fanica cada fila de la tabla: No existe m\u00e1s de una fila con el mismo a\u00f1o y municipio; No existe fila con valor nulo de ano o municipio en la tabla; \u00a1Pru\u00e9balo t\u00fa mismo(a): las siguientes consultas deben retornar vac\u00edo! R library ( \"basedosdados\" ) # Busca alguna fila que tenga a\u00f1o y municipio repetido query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Busca filas con a\u00f1o o municipio nulos query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Busca alguna fila que tenga a\u00f1o y municipio repetido query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Busca filas con a\u00f1o o municipio nulos query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ... Uniendo tablas con claves identificadoras La indicaci\u00f3n de un conjunto de columnas como clave identificadora se hace directamente en los metadatos de la tabla. As\u00ed, puedes saber qu\u00e9 tablas pueden unirse comparando el conjunto de claves identificadoras de cada una. A continuaci\u00f3n, haremos un ejemplo de c\u00f3mo unir las tablas de poblaci\u00f3n y PIB del IBGE para obtener el PIB per c\u00e1pita de todos los municipios brasile\u00f1os. En las tablas de poblaci\u00f3n y PIB, la columna ano y municipio son claves identificadoras. Por lo tanto, usaremos estas columnas en nuestra funci\u00f3n JOIN para determinar c\u00f3mo unir las tablas. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # Puedes descargar en tu computadora dir <- tempdir () data <- download ( query , file.path ( dir , \"pib_per_capita.csv\" )) # O cargar el resultado de la consulta en tu ambiente de an\u00e1lisis data <- read_sql ( query ) Python import basedadosdados as bd pib_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # Puedes descargar en tu computadora bd . download ( query = pib_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # O cargar el resultado de la consulta en pandas df = bd . read_sql ( pib_per_capita , billing_project_id =< YOUR_PROJECT_ID > ) Lista de claves identificadoras Claves geogr\u00e1ficas Sector censal: id_setor_censitario Municipio: id_municipio (est\u00e1ndar), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb \u00c1rea M\u00ednima Comparable: id_AMC Regi\u00f3n inmediata: id_regiao_imediata Regi\u00f3n intermediaria: id_regiao_intermediaria Microrregi\u00f3n: id_microrregiao Mesorregi\u00f3n: id_mesorregiao Unidad de la federaci\u00f3n (UF): sigla_uf (est\u00e1ndar), id_uf , uf Regi\u00f3n: regiao Claves temporales ano , semestre , mes , semana , dia , hora Claves de personas f\u00edsicas cpf , pis , nis Claves de personas jur\u00eddicas Empresa: cnpj Escuela: id_escola Claves en pol\u00edtica Candidato(a): id_candidato_bd Partido: sigla_partido , partido","title":"C\u00f3mo unir tablas en el datalake"},{"location":"es/tutorial_join_tables/#como-unir-tablas-en-el-datalake","text":"Organizamos los datos de manera que la uni\u00f3n de tablas de diferentes instituciones y temas sea tan simple como cualquier otra consulta. Para ello, definimos una metodolog\u00eda est\u00e1ndar para el tratamiento de datos, nomenclatura de columnas, tablas y conjuntos. \u00bfC\u00f3mo funciona la metodolog\u00eda BD? Alguna frase sobre .... Para saber m\u00e1s, lea la documentaci\u00f3n sobre tratamiento y arquitectura de datos. La informaci\u00f3n de diferentes tablas se puede agregar mediante claves identificadoras . Una clave identificadora es una columna cuyo nombre es \u00fanico en todas las tablas del data lake y se utiliza para identificar una entidad.","title":"C\u00f3mo unir tablas en el datalake"},{"location":"es/tutorial_join_tables/#ejemplo-de-clave-identificadora","text":"La columna ano tiene el mismo nombre en todas las tablas del data lake - siempre se refiere a la variable que tiene como valor cualquier a\u00f1o de nuestro calendario. Cuando trabajamos con datos de poblaci\u00f3n del IBGE, la columna ano , junto con la columna municipio , identifican de manera \u00fanica cada fila de la tabla: No existe m\u00e1s de una fila con el mismo a\u00f1o y municipio; No existe fila con valor nulo de ano o municipio en la tabla; \u00a1Pru\u00e9balo t\u00fa mismo(a): las siguientes consultas deben retornar vac\u00edo! R library ( \"basedosdados\" ) # Busca alguna fila que tenga a\u00f1o y municipio repetido query <- \"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\" read_sql ( query = query ) # Busca filas con a\u00f1o o municipio nulos query <- \"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\" read_sql ( query = query ) Python import basedadosdados as bd # Busca alguna fila que tenga a\u00f1o y municipio repetido query = \"\"\"SELECT ano, municipio, count(*) as total FROM `basedosdados.br_ibge_populacao.municipios` GROUP BY ano, municipio WHERE total > 1\"\"\" bd . read_sql ( query = query ) # Busca filas con a\u00f1o o municipio nulos query = \"\"\"SELECT * FROM `basedosdados.br_ibge_populacao.municipios` WHERE ano IS NULL OR municipio IS NULL\"\"\" bd . read_sql ( query = query ) CLI ...","title":"Ejemplo de clave identificadora"},{"location":"es/tutorial_join_tables/#uniendo-tablas-con-claves-identificadoras","text":"La indicaci\u00f3n de un conjunto de columnas como clave identificadora se hace directamente en los metadatos de la tabla. As\u00ed, puedes saber qu\u00e9 tablas pueden unirse comparando el conjunto de claves identificadoras de cada una. A continuaci\u00f3n, haremos un ejemplo de c\u00f3mo unir las tablas de poblaci\u00f3n y PIB del IBGE para obtener el PIB per c\u00e1pita de todos los municipios brasile\u00f1os. En las tablas de poblaci\u00f3n y PIB, la columna ano y municipio son claves identificadoras. Por lo tanto, usaremos estas columnas en nuestra funci\u00f3n JOIN para determinar c\u00f3mo unir las tablas. R library ( \"basedosdados\" ) set_billing_id ( \"<YOUR_PROJECT_ID>\" ) query <- \"SELECT pib.id_municipio, pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano\" # Puedes descargar en tu computadora dir <- tempdir () data <- download ( query , file.path ( dir , \"pib_per_capita.csv\" )) # O cargar el resultado de la consulta en tu ambiente de an\u00e1lisis data <- read_sql ( query ) Python import basedadosdados as bd pib_per_capita = \"\"\"SELECT pib.id_municipio , pop.ano, pib.PIB / pop.populacao as pib_per_capita FROM `basedosdados.br_ibge_pib.municipio` as pib INNER JOIN `basedosdados.br_ibge_populacao.municipio` as pop ON pib.id_municipio = pop.id_municipio AND pib.ano = pop.ano \"\"\" # Puedes descargar en tu computadora bd . download ( query = pib_per_capita , savepath = \"where/to/save/file\" , billing_project_id =< YOUR_PROJECT_ID > ) # O cargar el resultado de la consulta en pandas df = bd . read_sql ( pib_per_capita , billing_project_id =< YOUR_PROJECT_ID > )","title":"Uniendo tablas con claves identificadoras"},{"location":"es/tutorial_join_tables/#lista-de-claves-identificadoras","text":"","title":"Lista de claves identificadoras"},{"location":"es/tutorial_join_tables/#claves-geograficas","text":"Sector censal: id_setor_censitario Municipio: id_municipio (est\u00e1ndar), id_municipio_6 , id_municipio_tse , id_municipio_rf , id_municipio_bcb \u00c1rea M\u00ednima Comparable: id_AMC Regi\u00f3n inmediata: id_regiao_imediata Regi\u00f3n intermediaria: id_regiao_intermediaria Microrregi\u00f3n: id_microrregiao Mesorregi\u00f3n: id_mesorregiao Unidad de la federaci\u00f3n (UF): sigla_uf (est\u00e1ndar), id_uf , uf Regi\u00f3n: regiao","title":"Claves geogr\u00e1ficas"},{"location":"es/tutorial_join_tables/#claves-temporales","text":"ano , semestre , mes , semana , dia , hora","title":"Claves temporales"},{"location":"es/tutorial_join_tables/#claves-de-personas-fisicas","text":"cpf , pis , nis","title":"Claves de personas f\u00edsicas"},{"location":"es/tutorial_join_tables/#claves-de-personas-juridicas","text":"Empresa: cnpj Escuela: id_escola","title":"Claves de personas jur\u00eddicas"},{"location":"es/tutorial_join_tables/#claves-en-politica","text":"Candidato(a): id_candidato_bd Partido: sigla_partido , partido","title":"Claves en pol\u00edtica"}]}